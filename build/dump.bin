
bin/LudOS.bin:     format de fichier elf32-i386


Déassemblage de la section .text :

00101000 <_Z10detect_cpuv>:
int do_amd(void);
void printregs(int eax, int ebx, int ecx, int edx);

/* Simply call this function detect_cpu(); */
int detect_cpu()
{ /* or main() if your trying to port this as an independant application */
  101000:	53                   	push   %ebx
  101001:	83 ec 18             	sub    $0x18,%esp
        unsigned long ebx, unused;
        cpuid(0, unused, ebx, unused, unused);
  101004:	b8 00 00 00 00       	mov    $0x0,%eax
  101009:	0f a2                	cpuid  
  10100b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10100f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  101013:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101017:	89 14 24             	mov    %edx,(%esp)
        log("CPU Info :\n");
  10101a:	83 ec 0c             	sub    $0xc,%esp
  10101d:	68 3e 80 10 00       	push   $0x10803e
  101022:	e8 01 64 00 00       	call   107428 <_Z3logPKcz>
  101027:	83 c4 10             	add    $0x10,%esp
        switch(ebx) {
  10102a:	8b 44 24 08          	mov    0x8(%esp),%eax
  10102e:	3d 41 75 74 68       	cmp    $0x68747541,%eax
  101033:	74 0e                	je     101043 <_Z10detect_cpuv+0x43>
  101035:	3d 47 65 6e 75       	cmp    $0x756e6547,%eax
  10103a:	75 0e                	jne    10104a <_Z10detect_cpuv+0x4a>
                case 0x756e6547: /* Intel Magic Code */
                do_intel();
  10103c:	e8 24 00 00 00       	call   101065 <_Z8do_intelv>
                break;
  101041:	eb 18                	jmp    10105b <_Z10detect_cpuv+0x5b>
                case 0x68747541: /* AMD Magic Code */
                do_amd();
  101043:	e8 0f 06 00 00       	call   101657 <_Z6do_amdv>
                break;
  101048:	eb 11                	jmp    10105b <_Z10detect_cpuv+0x5b>
                default:
                log("Unknown x86 CPU Detected\n");
  10104a:	83 ec 0c             	sub    $0xc,%esp
  10104d:	68 4a 80 10 00       	push   $0x10804a
  101052:	e8 d1 63 00 00       	call   107428 <_Z3logPKcz>
  101057:	83 c4 10             	add    $0x10,%esp
                break;
  10105a:	90                   	nop
        }
        return 0;
  10105b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  101060:	83 c4 18             	add    $0x18,%esp
  101063:	5b                   	pop    %ebx
  101064:	c3                   	ret    

00101065 <_Z8do_intelv>:
        "Reserved",
        "Reserved"
};

/* Intel-specific information */
int do_intel(void) {
  101065:	53                   	push   %ebx
  101066:	83 ec 58             	sub    $0x58,%esp
        log("Intel Specific Features:\n");
  101069:	83 ec 0c             	sub    $0xc,%esp
  10106c:	68 a3 82 10 00       	push   $0x1082a3
  101071:	e8 b2 63 00 00       	call   107428 <_Z3logPKcz>
  101076:	83 c4 10             	add    $0x10,%esp
        unsigned long eax, ebx, ecx, edx, max_eax, signature, unused;
        int model, family, type, brand, stepping, reserved;
        int extended_family = -1;
  101079:	c7 44 24 4c ff ff ff 	movl   $0xffffffff,0x4c(%esp)
  101080:	ff 
        cpuid(1, eax, ebx, unused, unused);
  101081:	b8 01 00 00 00       	mov    $0x1,%eax
  101086:	0f a2                	cpuid  
  101088:	89 44 24 48          	mov    %eax,0x48(%esp)
  10108c:	89 5c 24 44          	mov    %ebx,0x44(%esp)
  101090:	89 4c 24 40          	mov    %ecx,0x40(%esp)
  101094:	89 54 24 3c          	mov    %edx,0x3c(%esp)
        model = (eax >> 4) & 0xf;
  101098:	8b 44 24 48          	mov    0x48(%esp),%eax
  10109c:	c1 e8 04             	shr    $0x4,%eax
  10109f:	83 e0 0f             	and    $0xf,%eax
  1010a2:	89 44 24 38          	mov    %eax,0x38(%esp)
        family = (eax >> 8) & 0xf;
  1010a6:	8b 44 24 48          	mov    0x48(%esp),%eax
  1010aa:	c1 e8 08             	shr    $0x8,%eax
  1010ad:	83 e0 0f             	and    $0xf,%eax
  1010b0:	89 44 24 34          	mov    %eax,0x34(%esp)
        type = (eax >> 12) & 0x3;
  1010b4:	8b 44 24 48          	mov    0x48(%esp),%eax
  1010b8:	c1 e8 0c             	shr    $0xc,%eax
  1010bb:	83 e0 03             	and    $0x3,%eax
  1010be:	89 44 24 30          	mov    %eax,0x30(%esp)
        brand = ebx & 0xff;
  1010c2:	8b 44 24 44          	mov    0x44(%esp),%eax
  1010c6:	25 ff 00 00 00       	and    $0xff,%eax
  1010cb:	89 44 24 2c          	mov    %eax,0x2c(%esp)
        stepping = eax & 0xf;
  1010cf:	8b 44 24 48          	mov    0x48(%esp),%eax
  1010d3:	83 e0 0f             	and    $0xf,%eax
  1010d6:	89 44 24 28          	mov    %eax,0x28(%esp)
        reserved = eax >> 14;
  1010da:	8b 44 24 48          	mov    0x48(%esp),%eax
  1010de:	c1 e8 0e             	shr    $0xe,%eax
  1010e1:	89 44 24 24          	mov    %eax,0x24(%esp)
        signature = eax;
  1010e5:	8b 44 24 48          	mov    0x48(%esp),%eax
  1010e9:	89 44 24 20          	mov    %eax,0x20(%esp)
        log(" Type %d - ", type);
  1010ed:	83 ec 08             	sub    $0x8,%esp
  1010f0:	ff 74 24 38          	pushl  0x38(%esp)
  1010f4:	68 bd 82 10 00       	push   $0x1082bd
  1010f9:	e8 2a 63 00 00       	call   107428 <_Z3logPKcz>
  1010fe:	83 c4 10             	add    $0x10,%esp
        switch(type) {
  101101:	8b 44 24 30          	mov    0x30(%esp),%eax
  101105:	83 f8 01             	cmp    $0x1,%eax
  101108:	74 29                	je     101133 <_Z8do_intelv+0xce>
  10110a:	83 f8 01             	cmp    $0x1,%eax
  10110d:	7f 06                	jg     101115 <_Z8do_intelv+0xb0>
  10110f:	85 c0                	test   %eax,%eax
  101111:	74 0e                	je     101121 <_Z8do_intelv+0xbc>
  101113:	eb 53                	jmp    101168 <_Z8do_intelv+0x103>
  101115:	83 f8 02             	cmp    $0x2,%eax
  101118:	74 2b                	je     101145 <_Z8do_intelv+0xe0>
  10111a:	83 f8 03             	cmp    $0x3,%eax
  10111d:	74 38                	je     101157 <_Z8do_intelv+0xf2>
  10111f:	eb 47                	jmp    101168 <_Z8do_intelv+0x103>
                case 0:
                printf("  Original OEM");
  101121:	83 ec 0c             	sub    $0xc,%esp
  101124:	68 c9 82 10 00       	push   $0x1082c9
  101129:	e8 a4 57 00 00       	call   1068d2 <tfp_printf>
  10112e:	83 c4 10             	add    $0x10,%esp
                break;
  101131:	eb 35                	jmp    101168 <_Z8do_intelv+0x103>
                case 1:
                printf("  Overdrive");
  101133:	83 ec 0c             	sub    $0xc,%esp
  101136:	68 d8 82 10 00       	push   $0x1082d8
  10113b:	e8 92 57 00 00       	call   1068d2 <tfp_printf>
  101140:	83 c4 10             	add    $0x10,%esp
                break;
  101143:	eb 23                	jmp    101168 <_Z8do_intelv+0x103>
                case 2:
                printf("  Dual-capable");
  101145:	83 ec 0c             	sub    $0xc,%esp
  101148:	68 e4 82 10 00       	push   $0x1082e4
  10114d:	e8 80 57 00 00       	call   1068d2 <tfp_printf>
  101152:	83 c4 10             	add    $0x10,%esp
                break;
  101155:	eb 11                	jmp    101168 <_Z8do_intelv+0x103>
                case 3:
                printf("  Reserved");
  101157:	83 ec 0c             	sub    $0xc,%esp
  10115a:	68 f3 82 10 00       	push   $0x1082f3
  10115f:	e8 6e 57 00 00       	call   1068d2 <tfp_printf>
  101164:	83 c4 10             	add    $0x10,%esp
                break;
  101167:	90                   	nop
        }
        printf("\n");
  101168:	83 ec 0c             	sub    $0xc,%esp
  10116b:	68 fe 82 10 00       	push   $0x1082fe
  101170:	e8 5d 57 00 00       	call   1068d2 <tfp_printf>
  101175:	83 c4 10             	add    $0x10,%esp
        log(" Family %d - ", family);
  101178:	83 ec 08             	sub    $0x8,%esp
  10117b:	ff 74 24 3c          	pushl  0x3c(%esp)
  10117f:	68 00 83 10 00       	push   $0x108300
  101184:	e8 9f 62 00 00       	call   107428 <_Z3logPKcz>
  101189:	83 c4 10             	add    $0x10,%esp
        switch(family) {
  10118c:	8b 44 24 34          	mov    0x34(%esp),%eax
  101190:	83 e8 03             	sub    $0x3,%eax
  101193:	83 f8 0c             	cmp    $0xc,%eax
  101196:	77 61                	ja     1011f9 <_Z8do_intelv+0x194>
  101198:	8b 04 85 b8 84 10 00 	mov    0x1084b8(,%eax,4),%eax
  10119f:	ff e0                	jmp    *%eax
                case 3:
                printf("  i386");
  1011a1:	83 ec 0c             	sub    $0xc,%esp
  1011a4:	68 0e 83 10 00       	push   $0x10830e
  1011a9:	e8 24 57 00 00       	call   1068d2 <tfp_printf>
  1011ae:	83 c4 10             	add    $0x10,%esp
                break;
  1011b1:	eb 46                	jmp    1011f9 <_Z8do_intelv+0x194>
                case 4:
                printf("  i486");
  1011b3:	83 ec 0c             	sub    $0xc,%esp
  1011b6:	68 15 83 10 00       	push   $0x108315
  1011bb:	e8 12 57 00 00       	call   1068d2 <tfp_printf>
  1011c0:	83 c4 10             	add    $0x10,%esp
                break;
  1011c3:	eb 34                	jmp    1011f9 <_Z8do_intelv+0x194>
                case 5:
                printf("  Pentium");
  1011c5:	83 ec 0c             	sub    $0xc,%esp
  1011c8:	68 1c 83 10 00       	push   $0x10831c
  1011cd:	e8 00 57 00 00       	call   1068d2 <tfp_printf>
  1011d2:	83 c4 10             	add    $0x10,%esp
                break;
  1011d5:	eb 22                	jmp    1011f9 <_Z8do_intelv+0x194>
                case 6:
                printf("  Pentium Pro");
  1011d7:	83 ec 0c             	sub    $0xc,%esp
  1011da:	68 26 83 10 00       	push   $0x108326
  1011df:	e8 ee 56 00 00       	call   1068d2 <tfp_printf>
  1011e4:	83 c4 10             	add    $0x10,%esp
                break;
  1011e7:	eb 10                	jmp    1011f9 <_Z8do_intelv+0x194>
                case 15:
                printf("  Pentium 4");
  1011e9:	83 ec 0c             	sub    $0xc,%esp
  1011ec:	68 34 83 10 00       	push   $0x108334
  1011f1:	e8 dc 56 00 00       	call   1068d2 <tfp_printf>
  1011f6:	83 c4 10             	add    $0x10,%esp
        }
        printf("\n");
  1011f9:	83 ec 0c             	sub    $0xc,%esp
  1011fc:	68 fe 82 10 00       	push   $0x1082fe
  101201:	e8 cc 56 00 00       	call   1068d2 <tfp_printf>
  101206:	83 c4 10             	add    $0x10,%esp
        if(family == 15) {
  101209:	83 7c 24 34 0f       	cmpl   $0xf,0x34(%esp)
  10120e:	75 24                	jne    101234 <_Z8do_intelv+0x1cf>
                extended_family = (eax >> 20) & 0xff;
  101210:	8b 44 24 48          	mov    0x48(%esp),%eax
  101214:	c1 e8 14             	shr    $0x14,%eax
  101217:	25 ff 00 00 00       	and    $0xff,%eax
  10121c:	89 44 24 4c          	mov    %eax,0x4c(%esp)
                log(" Extended family %d\n", extended_family);
  101220:	83 ec 08             	sub    $0x8,%esp
  101223:	ff 74 24 54          	pushl  0x54(%esp)
  101227:	68 40 83 10 00       	push   $0x108340
  10122c:	e8 f7 61 00 00       	call   107428 <_Z3logPKcz>
  101231:	83 c4 10             	add    $0x10,%esp
        }
        log(" Model %d - ", model);
  101234:	83 ec 08             	sub    $0x8,%esp
  101237:	ff 74 24 40          	pushl  0x40(%esp)
  10123b:	68 55 83 10 00       	push   $0x108355
  101240:	e8 e3 61 00 00       	call   107428 <_Z3logPKcz>
  101245:	83 c4 10             	add    $0x10,%esp
        switch(family) {
  101248:	8b 44 24 34          	mov    0x34(%esp),%eax
  10124c:	83 e8 03             	sub    $0x3,%eax
  10124f:	83 f8 0c             	cmp    $0xc,%eax
  101252:	0f 87 a5 01 00 00    	ja     1013fd <_Z8do_intelv+0x398>
  101258:	8b 04 85 ec 84 10 00 	mov    0x1084ec(,%eax,4),%eax
  10125f:	ff e0                	jmp    *%eax
                case 3:
                break;
                case 4:
                switch(model) {
  101261:	83 7c 24 38 08       	cmpl   $0x8,0x38(%esp)
  101266:	0f 87 8d 01 00 00    	ja     1013f9 <_Z8do_intelv+0x394>
  10126c:	8b 44 24 38          	mov    0x38(%esp),%eax
  101270:	c1 e0 02             	shl    $0x2,%eax
  101273:	05 20 85 10 00       	add    $0x108520,%eax
  101278:	8b 00                	mov    (%eax),%eax
  10127a:	ff e0                	jmp    *%eax
                        case 0:
                        case 1:
                        printf("  DX");
  10127c:	83 ec 0c             	sub    $0xc,%esp
  10127f:	68 62 83 10 00       	push   $0x108362
  101284:	e8 49 56 00 00       	call   1068d2 <tfp_printf>
  101289:	83 c4 10             	add    $0x10,%esp
                        break;
  10128c:	eb 6b                	jmp    1012f9 <_Z8do_intelv+0x294>
                        case 2:
                        printf("  SX");
  10128e:	83 ec 0c             	sub    $0xc,%esp
  101291:	68 67 83 10 00       	push   $0x108367
  101296:	e8 37 56 00 00       	call   1068d2 <tfp_printf>
  10129b:	83 c4 10             	add    $0x10,%esp
                        break;
  10129e:	eb 59                	jmp    1012f9 <_Z8do_intelv+0x294>
                        case 3:
                        printf("  487/DX2");
  1012a0:	83 ec 0c             	sub    $0xc,%esp
  1012a3:	68 6c 83 10 00       	push   $0x10836c
  1012a8:	e8 25 56 00 00       	call   1068d2 <tfp_printf>
  1012ad:	83 c4 10             	add    $0x10,%esp
                        break;
  1012b0:	eb 47                	jmp    1012f9 <_Z8do_intelv+0x294>
                        case 4:
                        printf("  SL");
  1012b2:	83 ec 0c             	sub    $0xc,%esp
  1012b5:	68 76 83 10 00       	push   $0x108376
  1012ba:	e8 13 56 00 00       	call   1068d2 <tfp_printf>
  1012bf:	83 c4 10             	add    $0x10,%esp
                        break;
  1012c2:	eb 35                	jmp    1012f9 <_Z8do_intelv+0x294>
                        case 5:
                        printf("  SX2");
  1012c4:	83 ec 0c             	sub    $0xc,%esp
  1012c7:	68 7b 83 10 00       	push   $0x10837b
  1012cc:	e8 01 56 00 00       	call   1068d2 <tfp_printf>
  1012d1:	83 c4 10             	add    $0x10,%esp
                        break;
  1012d4:	eb 23                	jmp    1012f9 <_Z8do_intelv+0x294>
                        case 7:
                        printf("  Write-back enhanced DX2");
  1012d6:	83 ec 0c             	sub    $0xc,%esp
  1012d9:	68 81 83 10 00       	push   $0x108381
  1012de:	e8 ef 55 00 00       	call   1068d2 <tfp_printf>
  1012e3:	83 c4 10             	add    $0x10,%esp
                        break;
  1012e6:	eb 11                	jmp    1012f9 <_Z8do_intelv+0x294>
                        case 8:
                        printf("  DX4");
  1012e8:	83 ec 0c             	sub    $0xc,%esp
  1012eb:	68 9b 83 10 00       	push   $0x10839b
  1012f0:	e8 dd 55 00 00       	call   1068d2 <tfp_printf>
  1012f5:	83 c4 10             	add    $0x10,%esp
                        break;
  1012f8:	90                   	nop
                }
                break;
  1012f9:	e9 fb 00 00 00       	jmp    1013f9 <_Z8do_intelv+0x394>
                case 5:
                switch(model) {
  1012fe:	8b 44 24 38          	mov    0x38(%esp),%eax
  101302:	83 f8 02             	cmp    $0x2,%eax
  101305:	74 30                	je     101337 <_Z8do_intelv+0x2d2>
  101307:	83 f8 02             	cmp    $0x2,%eax
  10130a:	7f 0a                	jg     101316 <_Z8do_intelv+0x2b1>
  10130c:	83 f8 01             	cmp    $0x1,%eax
  10130f:	74 14                	je     101325 <_Z8do_intelv+0x2c0>
                        break;
                        case 4:
                        printf("  MMX");
                        break;
                }
                break;
  101311:	e9 e7 00 00 00       	jmp    1013fd <_Z8do_intelv+0x398>
                switch(model) {
  101316:	83 f8 03             	cmp    $0x3,%eax
  101319:	74 2e                	je     101349 <_Z8do_intelv+0x2e4>
  10131b:	83 f8 04             	cmp    $0x4,%eax
  10131e:	74 3b                	je     10135b <_Z8do_intelv+0x2f6>
                break;
  101320:	e9 d8 00 00 00       	jmp    1013fd <_Z8do_intelv+0x398>
                        printf("  60/66");
  101325:	83 ec 0c             	sub    $0xc,%esp
  101328:	68 a1 83 10 00       	push   $0x1083a1
  10132d:	e8 a0 55 00 00       	call   1068d2 <tfp_printf>
  101332:	83 c4 10             	add    $0x10,%esp
                        break;
  101335:	eb 35                	jmp    10136c <_Z8do_intelv+0x307>
                        printf("  75-200");
  101337:	83 ec 0c             	sub    $0xc,%esp
  10133a:	68 a9 83 10 00       	push   $0x1083a9
  10133f:	e8 8e 55 00 00       	call   1068d2 <tfp_printf>
  101344:	83 c4 10             	add    $0x10,%esp
                        break;
  101347:	eb 23                	jmp    10136c <_Z8do_intelv+0x307>
                        printf("  for 486 system");
  101349:	83 ec 0c             	sub    $0xc,%esp
  10134c:	68 b2 83 10 00       	push   $0x1083b2
  101351:	e8 7c 55 00 00       	call   1068d2 <tfp_printf>
  101356:	83 c4 10             	add    $0x10,%esp
                        break;
  101359:	eb 11                	jmp    10136c <_Z8do_intelv+0x307>
                        printf("  MMX");
  10135b:	83 ec 0c             	sub    $0xc,%esp
  10135e:	68 c3 83 10 00       	push   $0x1083c3
  101363:	e8 6a 55 00 00       	call   1068d2 <tfp_printf>
  101368:	83 c4 10             	add    $0x10,%esp
                        break;
  10136b:	90                   	nop
                break;
  10136c:	e9 8c 00 00 00       	jmp    1013fd <_Z8do_intelv+0x398>
                case 6:
                switch(model) {
  101371:	83 7c 24 38 08       	cmpl   $0x8,0x38(%esp)
  101376:	0f 87 80 00 00 00    	ja     1013fc <_Z8do_intelv+0x397>
  10137c:	8b 44 24 38          	mov    0x38(%esp),%eax
  101380:	c1 e0 02             	shl    $0x2,%eax
  101383:	05 44 85 10 00       	add    $0x108544,%eax
  101388:	8b 00                	mov    (%eax),%eax
  10138a:	ff e0                	jmp    *%eax
                        case 1:
                        printf("  Pentium Pro");
  10138c:	83 ec 0c             	sub    $0xc,%esp
  10138f:	68 26 83 10 00       	push   $0x108326
  101394:	e8 39 55 00 00       	call   1068d2 <tfp_printf>
  101399:	83 c4 10             	add    $0x10,%esp
                        break;
  10139c:	eb 59                	jmp    1013f7 <_Z8do_intelv+0x392>
                        case 3:
                        printf("  Pentium II Model 3");
  10139e:	83 ec 0c             	sub    $0xc,%esp
  1013a1:	68 c9 83 10 00       	push   $0x1083c9
  1013a6:	e8 27 55 00 00       	call   1068d2 <tfp_printf>
  1013ab:	83 c4 10             	add    $0x10,%esp
                        break;
  1013ae:	eb 47                	jmp    1013f7 <_Z8do_intelv+0x392>
                        case 5:
                        printf("  Pentium II Model 5/Xeon/Celeron");
  1013b0:	83 ec 0c             	sub    $0xc,%esp
  1013b3:	68 e0 83 10 00       	push   $0x1083e0
  1013b8:	e8 15 55 00 00       	call   1068d2 <tfp_printf>
  1013bd:	83 c4 10             	add    $0x10,%esp
                        break;
  1013c0:	eb 35                	jmp    1013f7 <_Z8do_intelv+0x392>
                        case 6:
                        printf("  Celeron");
  1013c2:	83 ec 0c             	sub    $0xc,%esp
  1013c5:	68 02 84 10 00       	push   $0x108402
  1013ca:	e8 03 55 00 00       	call   1068d2 <tfp_printf>
  1013cf:	83 c4 10             	add    $0x10,%esp
                        break;
  1013d2:	eb 23                	jmp    1013f7 <_Z8do_intelv+0x392>
                        case 7:
                        printf("  Pentium III/Pentium III Xeon - external L2 cache");
  1013d4:	83 ec 0c             	sub    $0xc,%esp
  1013d7:	68 0c 84 10 00       	push   $0x10840c
  1013dc:	e8 f1 54 00 00       	call   1068d2 <tfp_printf>
  1013e1:	83 c4 10             	add    $0x10,%esp
                        break;
  1013e4:	eb 11                	jmp    1013f7 <_Z8do_intelv+0x392>
                        case 8:
                        printf("  Pentium III/Pentium III Xeon - internal L2 cache");
  1013e6:	83 ec 0c             	sub    $0xc,%esp
  1013e9:	68 40 84 10 00       	push   $0x108440
  1013ee:	e8 df 54 00 00       	call   1068d2 <tfp_printf>
  1013f3:	83 c4 10             	add    $0x10,%esp
                        break;
  1013f6:	90                   	nop
                }
                break;
  1013f7:	eb 03                	jmp    1013fc <_Z8do_intelv+0x397>
                break;
  1013f9:	90                   	nop
  1013fa:	eb 01                	jmp    1013fd <_Z8do_intelv+0x398>
                break;
  1013fc:	90                   	nop
                case 15:
                break;
        }
        printf("\n");
  1013fd:	83 ec 0c             	sub    $0xc,%esp
  101400:	68 fe 82 10 00       	push   $0x1082fe
  101405:	e8 c8 54 00 00       	call   1068d2 <tfp_printf>
  10140a:	83 c4 10             	add    $0x10,%esp
        cpuid(0x80000000, max_eax, unused, unused, unused);
  10140d:	b8 00 00 00 80       	mov    $0x80000000,%eax
  101412:	0f a2                	cpuid  
  101414:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  101418:	89 5c 24 40          	mov    %ebx,0x40(%esp)
  10141c:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  101420:	89 54 24 14          	mov    %edx,0x14(%esp)
        /* Quok said: If the max extended eax value is high enough to support the processor brand string
        (values 0x80000002 to 0x80000004), then we'll use that information to return the brand information.
        Otherwise, we'll refer back to the brand tables above for backwards compatibility with older processors.
        According to the Sept. 2006 Intel Arch Software Developer's Guide, if extended eax values are supported,
        then all 3 values for the processor brand string are supported, but we'll test just to make sure and be safe. */
        if(max_eax >= 0x80000004) {
  101424:	81 7c 24 1c 03 00 00 	cmpl   $0x80000003,0x1c(%esp)
  10142b:	80 
  10142c:	0f 86 dc 00 00 00    	jbe    10150e <_Z8do_intelv+0x4a9>
                log(" Brand: ");
  101432:	83 ec 0c             	sub    $0xc,%esp
  101435:	68 73 84 10 00       	push   $0x108473
  10143a:	e8 e9 5f 00 00       	call   107428 <_Z3logPKcz>
  10143f:	83 c4 10             	add    $0x10,%esp
                if(max_eax >= 0x80000002) {
  101442:	81 7c 24 1c 01 00 00 	cmpl   $0x80000001,0x1c(%esp)
  101449:	80 
  10144a:	76 33                	jbe    10147f <_Z8do_intelv+0x41a>
                        cpuid(0x80000002, eax, ebx, ecx, edx);
  10144c:	b8 02 00 00 80       	mov    $0x80000002,%eax
  101451:	0f a2                	cpuid  
  101453:	89 44 24 48          	mov    %eax,0x48(%esp)
  101457:	89 5c 24 44          	mov    %ebx,0x44(%esp)
  10145b:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  10145f:	89 54 24 0c          	mov    %edx,0xc(%esp)
                        printregs(eax, ebx, ecx, edx);
  101463:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  101467:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  10146b:	8b 54 24 44          	mov    0x44(%esp),%edx
  10146f:	8b 44 24 48          	mov    0x48(%esp),%eax
  101473:	53                   	push   %ebx
  101474:	51                   	push   %ecx
  101475:	52                   	push   %edx
  101476:	50                   	push   %eax
  101477:	e8 36 01 00 00       	call   1015b2 <_Z9printregsiiii>
  10147c:	83 c4 10             	add    $0x10,%esp
                }
                if(max_eax >= 0x80000003) {
  10147f:	81 7c 24 1c 02 00 00 	cmpl   $0x80000002,0x1c(%esp)
  101486:	80 
  101487:	76 33                	jbe    1014bc <_Z8do_intelv+0x457>
                        cpuid(0x80000003, eax, ebx, ecx, edx);
  101489:	b8 03 00 00 80       	mov    $0x80000003,%eax
  10148e:	0f a2                	cpuid  
  101490:	89 44 24 48          	mov    %eax,0x48(%esp)
  101494:	89 5c 24 44          	mov    %ebx,0x44(%esp)
  101498:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  10149c:	89 54 24 0c          	mov    %edx,0xc(%esp)
                        printregs(eax, ebx, ecx, edx);
  1014a0:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  1014a4:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  1014a8:	8b 54 24 44          	mov    0x44(%esp),%edx
  1014ac:	8b 44 24 48          	mov    0x48(%esp),%eax
  1014b0:	53                   	push   %ebx
  1014b1:	51                   	push   %ecx
  1014b2:	52                   	push   %edx
  1014b3:	50                   	push   %eax
  1014b4:	e8 f9 00 00 00       	call   1015b2 <_Z9printregsiiii>
  1014b9:	83 c4 10             	add    $0x10,%esp
                }
                if(max_eax >= 0x80000004) {
  1014bc:	81 7c 24 1c 03 00 00 	cmpl   $0x80000003,0x1c(%esp)
  1014c3:	80 
  1014c4:	76 33                	jbe    1014f9 <_Z8do_intelv+0x494>
                        cpuid(0x80000004, eax, ebx, ecx, edx);
  1014c6:	b8 04 00 00 80       	mov    $0x80000004,%eax
  1014cb:	0f a2                	cpuid  
  1014cd:	89 44 24 48          	mov    %eax,0x48(%esp)
  1014d1:	89 5c 24 44          	mov    %ebx,0x44(%esp)
  1014d5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  1014d9:	89 54 24 0c          	mov    %edx,0xc(%esp)
                        printregs(eax, ebx, ecx, edx);
  1014dd:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  1014e1:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  1014e5:	8b 54 24 44          	mov    0x44(%esp),%edx
  1014e9:	8b 44 24 48          	mov    0x48(%esp),%eax
  1014ed:	53                   	push   %ebx
  1014ee:	51                   	push   %ecx
  1014ef:	52                   	push   %edx
  1014f0:	50                   	push   %eax
  1014f1:	e8 bc 00 00 00       	call   1015b2 <_Z9printregsiiii>
  1014f6:	83 c4 10             	add    $0x10,%esp
                }
                printf("\n");
  1014f9:	83 ec 0c             	sub    $0xc,%esp
  1014fc:	68 fe 82 10 00       	push   $0x1082fe
  101501:	e8 cc 53 00 00       	call   1068d2 <tfp_printf>
  101506:	83 c4 10             	add    $0x10,%esp
  101509:	e9 82 00 00 00       	jmp    101590 <_Z8do_intelv+0x52b>
        } else if(brand > 0) {
  10150e:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
  101513:	7e 7b                	jle    101590 <_Z8do_intelv+0x52b>
                log(" Brand %d - ", brand);
  101515:	83 ec 08             	sub    $0x8,%esp
  101518:	ff 74 24 34          	pushl  0x34(%esp)
  10151c:	68 7c 84 10 00       	push   $0x10847c
  101521:	e8 02 5f 00 00       	call   107428 <_Z3logPKcz>
  101526:	83 c4 10             	add    $0x10,%esp
                if(brand < 0x18) {
  101529:	83 7c 24 2c 17       	cmpl   $0x17,0x2c(%esp)
  10152e:	7f 50                	jg     101580 <_Z8do_intelv+0x51b>
                        if(signature == 0x000006B1 || signature == 0x00000F13) {
  101530:	81 7c 24 20 b1 06 00 	cmpl   $0x6b1,0x20(%esp)
  101537:	00 
  101538:	74 0a                	je     101544 <_Z8do_intelv+0x4df>
  10153a:	81 7c 24 20 13 0f 00 	cmpl   $0xf13,0x20(%esp)
  101541:	00 
  101542:	75 1e                	jne    101562 <_Z8do_intelv+0x4fd>
                                printf("  %s\n", Intel_Other[brand]);
  101544:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  101548:	8b 04 85 60 e0 10 00 	mov    0x10e060(,%eax,4),%eax
  10154f:	83 ec 08             	sub    $0x8,%esp
  101552:	50                   	push   %eax
  101553:	68 89 84 10 00       	push   $0x108489
  101558:	e8 75 53 00 00       	call   1068d2 <tfp_printf>
  10155d:	83 c4 10             	add    $0x10,%esp
  101560:	eb 2e                	jmp    101590 <_Z8do_intelv+0x52b>
                        } else {
                                printf("  %s\n", Intel[brand]);
  101562:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  101566:	8b 04 85 00 e0 10 00 	mov    0x10e000(,%eax,4),%eax
  10156d:	83 ec 08             	sub    $0x8,%esp
  101570:	50                   	push   %eax
  101571:	68 89 84 10 00       	push   $0x108489
  101576:	e8 57 53 00 00       	call   1068d2 <tfp_printf>
  10157b:	83 c4 10             	add    $0x10,%esp
  10157e:	eb 10                	jmp    101590 <_Z8do_intelv+0x52b>
                        }
                } else {
                        printf("  Reserved\n");
  101580:	83 ec 0c             	sub    $0xc,%esp
  101583:	68 8f 84 10 00       	push   $0x10848f
  101588:	e8 45 53 00 00       	call   1068d2 <tfp_printf>
  10158d:	83 c4 10             	add    $0x10,%esp
                }
        }
        log(" Stepping: %d Reserved: %d\n", stepping, reserved);
  101590:	83 ec 04             	sub    $0x4,%esp
  101593:	ff 74 24 28          	pushl  0x28(%esp)
  101597:	ff 74 24 30          	pushl  0x30(%esp)
  10159b:	68 9b 84 10 00       	push   $0x10849b
  1015a0:	e8 83 5e 00 00       	call   107428 <_Z3logPKcz>
  1015a5:	83 c4 10             	add    $0x10,%esp
        return 0;
  1015a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1015ad:	83 c4 58             	add    $0x58,%esp
  1015b0:	5b                   	pop    %ebx
  1015b1:	c3                   	ret    

001015b2 <_Z9printregsiiii>:

/* Print Registers */
void printregs(int eax, int ebx, int ecx, int edx) {
  1015b2:	83 ec 2c             	sub    $0x2c,%esp
        int j;
        char string[17];
        string[16] = '\0';
  1015b5:	c6 44 24 1b 00       	movb   $0x0,0x1b(%esp)
        for(j = 0; j < 4; j++) {
  1015ba:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
  1015c1:	00 
  1015c2:	83 7c 24 1c 03       	cmpl   $0x3,0x1c(%esp)
  1015c7:	7f 74                	jg     10163d <_Z9printregsiiii+0x8b>
                string[j] = eax >> (8 * j);
  1015c9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1015cd:	c1 e0 03             	shl    $0x3,%eax
  1015d0:	8b 54 24 30          	mov    0x30(%esp),%edx
  1015d4:	89 c1                	mov    %eax,%ecx
  1015d6:	d3 fa                	sar    %cl,%edx
  1015d8:	89 d0                	mov    %edx,%eax
  1015da:	89 c1                	mov    %eax,%ecx
  1015dc:	8d 54 24 0b          	lea    0xb(%esp),%edx
  1015e0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1015e4:	01 d0                	add    %edx,%eax
  1015e6:	88 08                	mov    %cl,(%eax)
                string[j + 4] = ebx >> (8 * j);
  1015e8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1015ec:	c1 e0 03             	shl    $0x3,%eax
  1015ef:	8b 54 24 34          	mov    0x34(%esp),%edx
  1015f3:	89 c1                	mov    %eax,%ecx
  1015f5:	d3 fa                	sar    %cl,%edx
  1015f7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1015fb:	83 c0 04             	add    $0x4,%eax
  1015fe:	88 54 04 0b          	mov    %dl,0xb(%esp,%eax,1)
                string[j + 8] = ecx >> (8 * j);
  101602:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  101606:	c1 e0 03             	shl    $0x3,%eax
  101609:	8b 54 24 38          	mov    0x38(%esp),%edx
  10160d:	89 c1                	mov    %eax,%ecx
  10160f:	d3 fa                	sar    %cl,%edx
  101611:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  101615:	83 c0 08             	add    $0x8,%eax
  101618:	88 54 04 0b          	mov    %dl,0xb(%esp,%eax,1)
                string[j + 12] = edx >> (8 * j);
  10161c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  101620:	c1 e0 03             	shl    $0x3,%eax
  101623:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  101627:	89 c1                	mov    %eax,%ecx
  101629:	d3 fa                	sar    %cl,%edx
  10162b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10162f:	83 c0 0c             	add    $0xc,%eax
  101632:	88 54 04 0b          	mov    %dl,0xb(%esp,%eax,1)
        for(j = 0; j < 4; j++) {
  101636:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
  10163b:	eb 85                	jmp    1015c2 <_Z9printregsiiii+0x10>
        }
        printf("  %s", string);
  10163d:	83 ec 08             	sub    $0x8,%esp
  101640:	8d 44 24 13          	lea    0x13(%esp),%eax
  101644:	50                   	push   %eax
  101645:	68 68 85 10 00       	push   $0x108568
  10164a:	e8 83 52 00 00       	call   1068d2 <tfp_printf>
  10164f:	83 c4 10             	add    $0x10,%esp
}
  101652:	90                   	nop
  101653:	83 c4 2c             	add    $0x2c,%esp
  101656:	c3                   	ret    

00101657 <_Z6do_amdv>:

/* AMD-specific information */
int do_amd(void) {
  101657:	53                   	push   %ebx
  101658:	83 ec 58             	sub    $0x58,%esp
        log(" AMD Specific Features:\n");
  10165b:	83 ec 0c             	sub    $0xc,%esp
  10165e:	68 6d 85 10 00       	push   $0x10856d
  101663:	e8 c0 5d 00 00       	call   107428 <_Z3logPKcz>
  101668:	83 c4 10             	add    $0x10,%esp
        unsigned long extended, eax, ebx, ecx, edx, unused;
        int family, model, stepping, reserved;
        cpuid(1, eax, unused, unused, unused);
  10166b:	b8 01 00 00 00       	mov    $0x1,%eax
  101670:	0f a2                	cpuid  
  101672:	89 44 24 48          	mov    %eax,0x48(%esp)
  101676:	89 5c 24 44          	mov    %ebx,0x44(%esp)
  10167a:	89 4c 24 40          	mov    %ecx,0x40(%esp)
  10167e:	89 54 24 3c          	mov    %edx,0x3c(%esp)
        model = (eax >> 4) & 0xf;
  101682:	8b 44 24 48          	mov    0x48(%esp),%eax
  101686:	c1 e8 04             	shr    $0x4,%eax
  101689:	83 e0 0f             	and    $0xf,%eax
  10168c:	89 44 24 38          	mov    %eax,0x38(%esp)
        family = (eax >> 8) & 0xf;
  101690:	8b 44 24 48          	mov    0x48(%esp),%eax
  101694:	c1 e8 08             	shr    $0x8,%eax
  101697:	83 e0 0f             	and    $0xf,%eax
  10169a:	89 44 24 34          	mov    %eax,0x34(%esp)
        stepping = eax & 0xf;
  10169e:	8b 44 24 48          	mov    0x48(%esp),%eax
  1016a2:	83 e0 0f             	and    $0xf,%eax
  1016a5:	89 44 24 30          	mov    %eax,0x30(%esp)
        reserved = eax >> 12;
  1016a9:	8b 44 24 48          	mov    0x48(%esp),%eax
  1016ad:	c1 e8 0c             	shr    $0xc,%eax
  1016b0:	89 44 24 2c          	mov    %eax,0x2c(%esp)
        log(" Family: %d Model: %d [", family, model);
  1016b4:	83 ec 04             	sub    $0x4,%esp
  1016b7:	ff 74 24 3c          	pushl  0x3c(%esp)
  1016bb:	ff 74 24 3c          	pushl  0x3c(%esp)
  1016bf:	68 86 85 10 00       	push   $0x108586
  1016c4:	e8 5f 5d 00 00       	call   107428 <_Z3logPKcz>
  1016c9:	83 c4 10             	add    $0x10,%esp
        switch(family) {
  1016cc:	8b 44 24 34          	mov    0x34(%esp),%eax
  1016d0:	83 f8 05             	cmp    $0x5,%eax
  1016d3:	74 2b                	je     101700 <_Z6do_amdv+0xa9>
  1016d5:	83 f8 06             	cmp    $0x6,%eax
  1016d8:	0f 84 8a 00 00 00    	je     101768 <_Z6do_amdv+0x111>
  1016de:	83 f8 04             	cmp    $0x4,%eax
  1016e1:	0f 85 fa 00 00 00    	jne    1017e1 <_Z6do_amdv+0x18a>
                case 4:
                printf("  486 Model %d", model);
  1016e7:	83 ec 08             	sub    $0x8,%esp
  1016ea:	ff 74 24 40          	pushl  0x40(%esp)
  1016ee:	68 9e 85 10 00       	push   $0x10859e
  1016f3:	e8 da 51 00 00       	call   1068d2 <tfp_printf>
  1016f8:	83 c4 10             	add    $0x10,%esp
                break;
  1016fb:	e9 e1 00 00 00       	jmp    1017e1 <_Z6do_amdv+0x18a>
                case 5:
                switch(model) {
  101700:	83 7c 24 38 09       	cmpl   $0x9,0x38(%esp)
  101705:	77 4a                	ja     101751 <_Z6do_amdv+0xfa>
  101707:	8b 44 24 38          	mov    0x38(%esp),%eax
  10170b:	c1 e0 02             	shl    $0x2,%eax
  10170e:	05 a8 86 10 00       	add    $0x1086a8,%eax
  101713:	8b 00                	mov    (%eax),%eax
  101715:	ff e0                	jmp    *%eax
                        case 1:
                        case 2:
                        case 3:
                        case 6:
                        case 7:
                        printf("  K6 Model %d", model);
  101717:	83 ec 08             	sub    $0x8,%esp
  10171a:	ff 74 24 40          	pushl  0x40(%esp)
  10171e:	68 ad 85 10 00       	push   $0x1085ad
  101723:	e8 aa 51 00 00       	call   1068d2 <tfp_printf>
  101728:	83 c4 10             	add    $0x10,%esp
                        break;
  10172b:	eb 39                	jmp    101766 <_Z6do_amdv+0x10f>
                        case 8:
                        printf("  K6-2 Model 8");
  10172d:	83 ec 0c             	sub    $0xc,%esp
  101730:	68 bb 85 10 00       	push   $0x1085bb
  101735:	e8 98 51 00 00       	call   1068d2 <tfp_printf>
  10173a:	83 c4 10             	add    $0x10,%esp
                        break;
  10173d:	eb 27                	jmp    101766 <_Z6do_amdv+0x10f>
                        case 9:
                        printf("  K6-III Model 9");
  10173f:	83 ec 0c             	sub    $0xc,%esp
  101742:	68 ca 85 10 00       	push   $0x1085ca
  101747:	e8 86 51 00 00       	call   1068d2 <tfp_printf>
  10174c:	83 c4 10             	add    $0x10,%esp
                        break;
  10174f:	eb 15                	jmp    101766 <_Z6do_amdv+0x10f>
                        default:
                        printf("  K5/K6 Model %d", model);
  101751:	83 ec 08             	sub    $0x8,%esp
  101754:	ff 74 24 40          	pushl  0x40(%esp)
  101758:	68 db 85 10 00       	push   $0x1085db
  10175d:	e8 70 51 00 00       	call   1068d2 <tfp_printf>
  101762:	83 c4 10             	add    $0x10,%esp
                        break;
  101765:	90                   	nop
                }
                break;
  101766:	eb 79                	jmp    1017e1 <_Z6do_amdv+0x18a>
                case 6:
                switch(model) {
  101768:	83 7c 24 38 07       	cmpl   $0x7,0x38(%esp)
  10176d:	77 5c                	ja     1017cb <_Z6do_amdv+0x174>
  10176f:	8b 44 24 38          	mov    0x38(%esp),%eax
  101773:	c1 e0 02             	shl    $0x2,%eax
  101776:	05 d0 86 10 00       	add    $0x1086d0,%eax
  10177b:	8b 00                	mov    (%eax),%eax
  10177d:	ff e0                	jmp    *%eax
                        case 1:
                        case 2:
                        case 4:
                        printf("  Athlon Model %d", model);
  10177f:	83 ec 08             	sub    $0x8,%esp
  101782:	ff 74 24 40          	pushl  0x40(%esp)
  101786:	68 ec 85 10 00       	push   $0x1085ec
  10178b:	e8 42 51 00 00       	call   1068d2 <tfp_printf>
  101790:	83 c4 10             	add    $0x10,%esp
                        break;
  101793:	eb 4b                	jmp    1017e0 <_Z6do_amdv+0x189>
                        case 3:
                        printf("  Duron Model 3");
  101795:	83 ec 0c             	sub    $0xc,%esp
  101798:	68 fe 85 10 00       	push   $0x1085fe
  10179d:	e8 30 51 00 00       	call   1068d2 <tfp_printf>
  1017a2:	83 c4 10             	add    $0x10,%esp
                        break;
  1017a5:	eb 39                	jmp    1017e0 <_Z6do_amdv+0x189>
                        case 6:
                        printf("  Athlon MP/Mobile Athlon Model 6");
  1017a7:	83 ec 0c             	sub    $0xc,%esp
  1017aa:	68 10 86 10 00       	push   $0x108610
  1017af:	e8 1e 51 00 00       	call   1068d2 <tfp_printf>
  1017b4:	83 c4 10             	add    $0x10,%esp
                        break;
  1017b7:	eb 27                	jmp    1017e0 <_Z6do_amdv+0x189>
                        case 7:
                        printf("  Mobile Duron Model 7");
  1017b9:	83 ec 0c             	sub    $0xc,%esp
  1017bc:	68 32 86 10 00       	push   $0x108632
  1017c1:	e8 0c 51 00 00       	call   1068d2 <tfp_printf>
  1017c6:	83 c4 10             	add    $0x10,%esp
                        break;
  1017c9:	eb 15                	jmp    1017e0 <_Z6do_amdv+0x189>
                        default:
                        printf("  Duron/Athlon Model %d", model);
  1017cb:	83 ec 08             	sub    $0x8,%esp
  1017ce:	ff 74 24 40          	pushl  0x40(%esp)
  1017d2:	68 49 86 10 00       	push   $0x108649
  1017d7:	e8 f6 50 00 00       	call   1068d2 <tfp_printf>
  1017dc:	83 c4 10             	add    $0x10,%esp
                        break;
  1017df:	90                   	nop
                }
                break;
  1017e0:	90                   	nop
        }
        puts("]");
  1017e1:	83 ec 0c             	sub    $0xc,%esp
  1017e4:	68 61 86 10 00       	push   $0x108661
  1017e9:	e8 84 58 00 00       	call   107072 <puts>
  1017ee:	83 c4 10             	add    $0x10,%esp
        cpuid(0x80000000, extended, unused, unused, unused);
  1017f1:	b8 00 00 00 80       	mov    $0x80000000,%eax
  1017f6:	0f a2                	cpuid  
  1017f8:	89 44 24 28          	mov    %eax,0x28(%esp)
  1017fc:	89 5c 24 44          	mov    %ebx,0x44(%esp)
  101800:	89 4c 24 24          	mov    %ecx,0x24(%esp)
  101804:	89 54 24 20          	mov    %edx,0x20(%esp)
        if(extended == 0) {
  101808:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
  10180d:	75 0a                	jne    101819 <_Z6do_amdv+0x1c2>
                return 0;
  10180f:	b8 00 00 00 00       	mov    $0x0,%eax
  101814:	e9 ce 00 00 00       	jmp    1018e7 <_Z6do_amdv+0x290>
        }
        if(extended >= 0x80000002) {
  101819:	81 7c 24 28 01 00 00 	cmpl   $0x80000001,0x28(%esp)
  101820:	80 
  101821:	76 6b                	jbe    10188e <_Z6do_amdv+0x237>
                unsigned int j;
                log(" Detected Processor Name: ");
  101823:	83 ec 0c             	sub    $0xc,%esp
  101826:	68 63 86 10 00       	push   $0x108663
  10182b:	e8 f8 5b 00 00       	call   107428 <_Z3logPKcz>
  101830:	83 c4 10             	add    $0x10,%esp
                for(j = 0x80000002; j <= 0x80000004; j++) {
  101833:	c7 44 24 4c 02 00 00 	movl   $0x80000002,0x4c(%esp)
  10183a:	80 
  10183b:	81 7c 24 4c 04 00 00 	cmpl   $0x80000004,0x4c(%esp)
  101842:	80 
  101843:	77 39                	ja     10187e <_Z6do_amdv+0x227>
                        cpuid(j, eax, ebx, ecx, edx);
  101845:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  101849:	0f a2                	cpuid  
  10184b:	89 44 24 48          	mov    %eax,0x48(%esp)
  10184f:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
  101853:	89 4c 24 18          	mov    %ecx,0x18(%esp)
  101857:	89 54 24 14          	mov    %edx,0x14(%esp)
                        printregs(eax, ebx, ecx, edx);
  10185b:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  10185f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  101863:	8b 54 24 1c          	mov    0x1c(%esp),%edx
  101867:	8b 44 24 48          	mov    0x48(%esp),%eax
  10186b:	53                   	push   %ebx
  10186c:	51                   	push   %ecx
  10186d:	52                   	push   %edx
  10186e:	50                   	push   %eax
  10186f:	e8 3e fd ff ff       	call   1015b2 <_Z9printregsiiii>
  101874:	83 c4 10             	add    $0x10,%esp
                for(j = 0x80000002; j <= 0x80000004; j++) {
  101877:	83 44 24 4c 01       	addl   $0x1,0x4c(%esp)
  10187c:	eb bd                	jmp    10183b <_Z6do_amdv+0x1e4>
                }
                printf("\n");
  10187e:	83 ec 0c             	sub    $0xc,%esp
  101881:	68 fe 82 10 00       	push   $0x1082fe
  101886:	e8 47 50 00 00       	call   1068d2 <tfp_printf>
  10188b:	83 c4 10             	add    $0x10,%esp
        }
        if(extended >= 0x80000007) {
  10188e:	81 7c 24 28 06 00 00 	cmpl   $0x80000006,0x28(%esp)
  101895:	80 
  101896:	76 32                	jbe    1018ca <_Z6do_amdv+0x273>
                cpuid(0x80000007, unused, unused, unused, edx);
  101898:	b8 07 00 00 80       	mov    $0x80000007,%eax
  10189d:	0f a2                	cpuid  
  10189f:	89 44 24 44          	mov    %eax,0x44(%esp)
  1018a3:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  1018a7:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  1018ab:	89 54 24 14          	mov    %edx,0x14(%esp)
                if(edx & 1) {
  1018af:	8b 44 24 14          	mov    0x14(%esp),%eax
  1018b3:	83 e0 01             	and    $0x1,%eax
  1018b6:	85 c0                	test   %eax,%eax
  1018b8:	74 10                	je     1018ca <_Z6do_amdv+0x273>
                        log(" Temperature Sensing Diode Detected!\n");
  1018ba:	83 ec 0c             	sub    $0xc,%esp
  1018bd:	68 80 86 10 00       	push   $0x108680
  1018c2:	e8 61 5b 00 00       	call   107428 <_Z3logPKcz>
  1018c7:	83 c4 10             	add    $0x10,%esp
                }
        }
        log(" Stepping: %d Reserved: %d\n", stepping, reserved);
  1018ca:	83 ec 04             	sub    $0x4,%esp
  1018cd:	ff 74 24 30          	pushl  0x30(%esp)
  1018d1:	ff 74 24 38          	pushl  0x38(%esp)
  1018d5:	68 9b 84 10 00       	push   $0x10849b
  1018da:	e8 49 5b 00 00       	call   107428 <_Z3logPKcz>
  1018df:	83 c4 10             	add    $0x10,%esp
        return 0;
  1018e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1018e7:	83 c4 58             	add    $0x58,%esp
  1018ea:	5b                   	pop    %ebx
  1018eb:	c3                   	ret    

001018ec <_Z41__static_initialization_and_destruction_0ii>:
  1018ec:	83 ec 0c             	sub    $0xc,%esp
  1018ef:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  1018f4:	75 2e                	jne    101924 <_Z41__static_initialization_and_destruction_0ii+0x38>
  1018f6:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  1018fd:	00 
  1018fe:	75 24                	jne    101924 <_Z41__static_initialization_and_destruction_0ii+0x38>
    static void pop_color() { impl.pop_color(); }
    static void show_history(int page) { impl.show_history(page); }
    static uint8_t current_history() { return impl.current_history(); }

private:
    static inline detail::TerminalImpl impl;
  101900:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  101905:	0f b6 00             	movzbl (%eax),%eax
  101908:	84 c0                	test   %al,%al
  10190a:	75 18                	jne    101924 <_Z41__static_initialization_and_destruction_0ii+0x38>
  10190c:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  101911:	c6 00 01             	movb   $0x1,(%eax)
  101914:	83 ec 0c             	sub    $0xc,%esp
  101917:	68 60 53 11 00       	push   $0x115360
  10191c:	e8 19 18 00 00       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  101921:	83 c4 10             	add    $0x10,%esp
  101924:	90                   	nop
  101925:	83 c4 0c             	add    $0xc,%esp
  101928:	c3                   	ret    

00101929 <_GLOBAL__sub_I__Z10detect_cpuv>:
  101929:	83 ec 0c             	sub    $0xc,%esp
  10192c:	83 ec 08             	sub    $0x8,%esp
  10192f:	68 ff ff 00 00       	push   $0xffff
  101934:	6a 01                	push   $0x1
  101936:	e8 b1 ff ff ff       	call   1018ec <_Z41__static_initialization_and_destruction_0ii>
  10193b:	83 c4 10             	add    $0x10,%esp
  10193e:	83 c4 0c             	add    $0xc,%esp
  101941:	c3                   	ret    

00101942 <_ZN3FPU4initEv>:
#include "utils/bitops.hpp"

#include "utils/logging.hpp"

void FPU::init()
{
  101942:	83 ec 0c             	sub    $0xc,%esp
    log("Initializing FPU...\n");
  101945:	83 ec 0c             	sub    $0xc,%esp
  101948:	68 fa 86 10 00       	push   $0x1086fa
  10194d:	e8 d6 5a 00 00       	call   107428 <_Z3logPKcz>
  101952:	83 c4 10             	add    $0x10,%esp

    if (!check_cpuid() && !check_fpu_presence())
  101955:	e8 4a 00 00 00       	call   1019a4 <_ZN3FPU11check_cpuidEv>
  10195a:	83 f0 01             	xor    $0x1,%eax
  10195d:	84 c0                	test   %al,%al
  10195f:	74 13                	je     101974 <_ZN3FPU4initEv+0x32>
  101961:	e8 3a 15 00 00       	call   102ea0 <check_fpu_presence>
  101966:	83 f0 01             	xor    $0x1,%eax
  101969:	84 c0                	test   %al,%al
  10196b:	74 07                	je     101974 <_ZN3FPU4initEv+0x32>
  10196d:	b8 01 00 00 00       	mov    $0x1,%eax
  101972:	eb 05                	jmp    101979 <_ZN3FPU4initEv+0x37>
  101974:	b8 00 00 00 00       	mov    $0x0,%eax
  101979:	84 c0                	test   %al,%al
  10197b:	74 0d                	je     10198a <_ZN3FPU4initEv+0x48>
    {
        panic("No FPU found !\n");
  10197d:	83 ec 0c             	sub    $0xc,%esp
  101980:	68 0f 87 10 00       	push   $0x10870f
  101985:	e8 78 30 00 00       	call   104a02 <_Z5panicPKcz>
    }

    setup_fpu();
  10198a:	e8 39 15 00 00       	call   102ec8 <setup_fpu>

    log("FPU Initialized\n");
  10198f:	83 ec 0c             	sub    $0xc,%esp
  101992:	68 1f 87 10 00       	push   $0x10871f
  101997:	e8 8c 5a 00 00       	call   107428 <_Z3logPKcz>
  10199c:	83 c4 10             	add    $0x10,%esp
}
  10199f:	90                   	nop
  1019a0:	83 c4 0c             	add    $0xc,%esp
  1019a3:	c3                   	ret    

001019a4 <_ZN3FPU11check_cpuidEv>:

bool FPU::check_cpuid()
{
  1019a4:	53                   	push   %ebx
  1019a5:	83 ec 18             	sub    $0x18,%esp
    unsigned long edx, unused;
    cpuid(1, unused, unused, unused, edx);
  1019a8:	b8 01 00 00 00       	mov    $0x1,%eax
  1019ad:	0f a2                	cpuid  
  1019af:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1019b3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1019b7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1019bb:	89 14 24             	mov    %edx,(%esp)

    return bit_check(edx, 0);
  1019be:	83 ec 08             	sub    $0x8,%esp
  1019c1:	6a 00                	push   $0x0
  1019c3:	8d 44 24 0c          	lea    0xc(%esp),%eax
  1019c7:	50                   	push   %eax
  1019c8:	e8 ad 5a 00 00       	call   10747a <_Z9bit_checkImEbRT_m>
  1019cd:	83 c4 10             	add    $0x10,%esp
}
  1019d0:	83 c4 18             	add    $0x18,%esp
  1019d3:	5b                   	pop    %ebx
  1019d4:	c3                   	ret    

001019d5 <_Z41__static_initialization_and_destruction_0ii>:
  1019d5:	83 ec 0c             	sub    $0xc,%esp
  1019d8:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  1019dd:	75 2e                	jne    101a0d <_Z41__static_initialization_and_destruction_0ii+0x38>
  1019df:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  1019e6:	00 
  1019e7:	75 24                	jne    101a0d <_Z41__static_initialization_and_destruction_0ii+0x38>
  1019e9:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  1019ee:	0f b6 00             	movzbl (%eax),%eax
  1019f1:	84 c0                	test   %al,%al
  1019f3:	75 18                	jne    101a0d <_Z41__static_initialization_and_destruction_0ii+0x38>
  1019f5:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  1019fa:	c6 00 01             	movb   $0x1,(%eax)
  1019fd:	83 ec 0c             	sub    $0xc,%esp
  101a00:	68 60 53 11 00       	push   $0x115360
  101a05:	e8 30 17 00 00       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  101a0a:	83 c4 10             	add    $0x10,%esp
  101a0d:	90                   	nop
  101a0e:	83 c4 0c             	add    $0xc,%esp
  101a11:	c3                   	ret    

00101a12 <_GLOBAL__sub_I__ZN3FPU4initEv>:
  101a12:	83 ec 0c             	sub    $0xc,%esp
  101a15:	83 ec 08             	sub    $0x8,%esp
  101a18:	68 ff ff 00 00       	push   $0xffff
  101a1d:	6a 01                	push   $0x1
  101a1f:	e8 b1 ff ff ff       	call   1019d5 <_Z41__static_initialization_and_destruction_0ii>
  101a24:	83 c4 10             	add    $0x10,%esp
  101a27:	83 c4 0c             	add    $0xc,%esp
  101a2a:	c3                   	ret    

00101a2b <_ZN3gdt8set_gateEmmmhh>:

entry entries[6];
ptr gdt_ptr;

void set_gate(size_t num, uint32_t base, uint32_t limit, uint8_t access, uint8_t gran)
{
  101a2b:	83 ec 1c             	sub    $0x1c,%esp
  101a2e:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  101a32:	8b 44 24 30          	mov    0x30(%esp),%eax
  101a36:	88 54 24 0c          	mov    %dl,0xc(%esp)
  101a3a:	88 44 24 08          	mov    %al,0x8(%esp)
    if (num >= sizeof(entries))
  101a3e:	83 7c 24 20 2f       	cmpl   $0x2f,0x20(%esp)
  101a43:	76 0d                	jbe    101a52 <_ZN3gdt8set_gateEmmmhh+0x27>
    {
        panic("Invalid GDT entry : num is larger than entries");
  101a45:	83 ec 0c             	sub    $0xc,%esp
  101a48:	68 34 87 10 00       	push   $0x108734
  101a4d:	e8 b0 2f 00 00       	call   104a02 <_Z5panicPKcz>
    }

    entries[num].base_low    = (base & 0xFFFF);
  101a52:	8b 44 24 24          	mov    0x24(%esp),%eax
  101a56:	89 c2                	mov    %eax,%edx
  101a58:	8b 44 24 20          	mov    0x20(%esp),%eax
  101a5c:	66 89 14 c5 22 00 11 	mov    %dx,0x110022(,%eax,8)
  101a63:	00 
    entries[num].base_middle = (base >> 16) & 0xFF;
  101a64:	8b 44 24 24          	mov    0x24(%esp),%eax
  101a68:	c1 e8 10             	shr    $0x10,%eax
  101a6b:	89 c2                	mov    %eax,%edx
  101a6d:	8b 44 24 20          	mov    0x20(%esp),%eax
  101a71:	88 14 c5 24 00 11 00 	mov    %dl,0x110024(,%eax,8)
    entries[num].base_high   = (base >> 24) & 0xFF;
  101a78:	8b 44 24 24          	mov    0x24(%esp),%eax
  101a7c:	c1 e8 18             	shr    $0x18,%eax
  101a7f:	89 c2                	mov    %eax,%edx
  101a81:	8b 44 24 20          	mov    0x20(%esp),%eax
  101a85:	88 14 c5 27 00 11 00 	mov    %dl,0x110027(,%eax,8)

    entries[num].limit_low   = (limit & 0xFFFF);
  101a8c:	8b 44 24 28          	mov    0x28(%esp),%eax
  101a90:	89 c2                	mov    %eax,%edx
  101a92:	8b 44 24 20          	mov    0x20(%esp),%eax
  101a96:	66 89 14 c5 20 00 11 	mov    %dx,0x110020(,%eax,8)
  101a9d:	00 
    entries[num].granularity = (limit >> 16) & 0x0F;
  101a9e:	8b 44 24 28          	mov    0x28(%esp),%eax
  101aa2:	c1 e8 10             	shr    $0x10,%eax
  101aa5:	83 e0 0f             	and    $0xf,%eax
  101aa8:	89 c2                	mov    %eax,%edx
  101aaa:	8b 44 24 20          	mov    0x20(%esp),%eax
  101aae:	88 14 c5 26 00 11 00 	mov    %dl,0x110026(,%eax,8)

    entries[num].granularity |= gran & 0xF0;
  101ab5:	8b 44 24 20          	mov    0x20(%esp),%eax
  101ab9:	0f b6 14 c5 26 00 11 	movzbl 0x110026(,%eax,8),%edx
  101ac0:	00 
  101ac1:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
  101ac6:	83 e0 f0             	and    $0xfffffff0,%eax
  101ac9:	09 c2                	or     %eax,%edx
  101acb:	8b 44 24 20          	mov    0x20(%esp),%eax
  101acf:	88 14 c5 26 00 11 00 	mov    %dl,0x110026(,%eax,8)
    entries[num].access      = access;
  101ad6:	8b 44 24 20          	mov    0x20(%esp),%eax
  101ada:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
  101adf:	88 14 c5 25 00 11 00 	mov    %dl,0x110025(,%eax,8)
}
  101ae6:	90                   	nop
  101ae7:	83 c4 1c             	add    $0x1c,%esp
  101aea:	c3                   	ret    

00101aeb <_ZN3gdt4initEv>:

void init()
{
  101aeb:	83 ec 0c             	sub    $0xc,%esp
    gdt_ptr.limit = (sizeof(entry) * size(entries)) - 1;
  101aee:	83 ec 0c             	sub    $0xc,%esp
  101af1:	68 20 00 11 00       	push   $0x110020
  101af6:	e8 98 59 00 00       	call   107493 <_Z4sizeIN3gdt5entryELm6EEmRAT0__T_>
  101afb:	83 c4 10             	add    $0x10,%esp
  101afe:	c1 e0 03             	shl    $0x3,%eax
  101b01:	83 e8 01             	sub    $0x1,%eax
  101b04:	66 a3 50 00 11 00    	mov    %ax,0x110050
    gdt_ptr.base  = reinterpret_cast<uint32_t>(&entries);
  101b0a:	b8 20 00 11 00       	mov    $0x110020,%eax
  101b0f:	a3 52 00 11 00       	mov    %eax,0x110052

    tss.trap = 0x00;
  101b14:	66 c7 05 04 0d 11 00 	movw   $0x0,0x110d04
  101b1b:	00 00 
    tss.iomap = 0x00;
  101b1d:	66 c7 05 06 0d 11 00 	movw   $0x0,0x110d06
  101b24:	00 00 
    tss.esp0 = 0x20000;
  101b26:	c7 05 a4 0c 11 00 00 	movl   $0x20000,0x110ca4
  101b2d:	00 02 00 
    tss.ss0 = 0x18;
  101b30:	66 c7 05 a8 0c 11 00 	movw   $0x18,0x110ca8
  101b37:	18 00 

    set_gate(0, 0, 0, 0, 0);                // Null segment
  101b39:	83 ec 0c             	sub    $0xc,%esp
  101b3c:	6a 00                	push   $0x0
  101b3e:	6a 00                	push   $0x0
  101b40:	6a 00                	push   $0x0
  101b42:	6a 00                	push   $0x0
  101b44:	6a 00                	push   $0x0
  101b46:	e8 e0 fe ff ff       	call   101a2b <_ZN3gdt8set_gateEmmmhh>
  101b4b:	83 c4 20             	add    $0x20,%esp
    set_gate(1, 0, 0xFFFFFFFF, 0x9A, 0xCF); // Code segment
  101b4e:	83 ec 0c             	sub    $0xc,%esp
  101b51:	68 cf 00 00 00       	push   $0xcf
  101b56:	68 9a 00 00 00       	push   $0x9a
  101b5b:	6a ff                	push   $0xffffffff
  101b5d:	6a 00                	push   $0x0
  101b5f:	6a 01                	push   $0x1
  101b61:	e8 c5 fe ff ff       	call   101a2b <_ZN3gdt8set_gateEmmmhh>
  101b66:	83 c4 20             	add    $0x20,%esp
    set_gate(2, 0, 0xFFFFFFFF, 0x92, 0xCF); // Data segment
  101b69:	83 ec 0c             	sub    $0xc,%esp
  101b6c:	68 cf 00 00 00       	push   $0xcf
  101b71:	68 92 00 00 00       	push   $0x92
  101b76:	6a ff                	push   $0xffffffff
  101b78:	6a 00                	push   $0x0
  101b7a:	6a 02                	push   $0x2
  101b7c:	e8 aa fe ff ff       	call   101a2b <_ZN3gdt8set_gateEmmmhh>
  101b81:	83 c4 20             	add    $0x20,%esp
    set_gate(3, 0, 0xFFFFFFFF, 0xFA, 0xCF); // User mode code segment
  101b84:	83 ec 0c             	sub    $0xc,%esp
  101b87:	68 cf 00 00 00       	push   $0xcf
  101b8c:	68 fa 00 00 00       	push   $0xfa
  101b91:	6a ff                	push   $0xffffffff
  101b93:	6a 00                	push   $0x0
  101b95:	6a 03                	push   $0x3
  101b97:	e8 8f fe ff ff       	call   101a2b <_ZN3gdt8set_gateEmmmhh>
  101b9c:	83 c4 20             	add    $0x20,%esp
    set_gate(4, 0, 0xFFFFFFFF, 0xF2, 0xCF); // User mode data segment
  101b9f:	83 ec 0c             	sub    $0xc,%esp
  101ba2:	68 cf 00 00 00       	push   $0xcf
  101ba7:	68 f2 00 00 00       	push   $0xf2
  101bac:	6a ff                	push   $0xffffffff
  101bae:	6a 00                	push   $0x0
  101bb0:	6a 04                	push   $0x4
  101bb2:	e8 74 fe ff ff       	call   101a2b <_ZN3gdt8set_gateEmmmhh>
  101bb7:	83 c4 20             	add    $0x20,%esp
    set_gate(5, reinterpret_cast<uint32_t>(&tss), sizeof(tss), 0x89, 0xCF);
  101bba:	b8 a0 0c 11 00       	mov    $0x110ca0,%eax
  101bbf:	83 ec 0c             	sub    $0xc,%esp
  101bc2:	68 cf 00 00 00       	push   $0xcf
  101bc7:	68 89 00 00 00       	push   $0x89
  101bcc:	6a 68                	push   $0x68
  101bce:	50                   	push   %eax
  101bcf:	6a 05                	push   $0x5
  101bd1:	e8 55 fe ff ff       	call   101a2b <_ZN3gdt8set_gateEmmmhh>
  101bd6:	83 c4 20             	add    $0x20,%esp

    gdt_flush(reinterpret_cast<uint32_t>(&gdt_ptr));
  101bd9:	b8 50 00 11 00       	mov    $0x110050,%eax
  101bde:	83 ec 0c             	sub    $0xc,%esp
  101be1:	50                   	push   %eax
  101be2:	e8 f9 12 00 00       	call   102ee0 <gdt_flush>
  101be7:	83 c4 10             	add    $0x10,%esp

    puts("GDT initialized.");
  101bea:	83 ec 0c             	sub    $0xc,%esp
  101bed:	68 63 87 10 00       	push   $0x108763
  101bf2:	e8 7b 54 00 00       	call   107072 <puts>
  101bf7:	83 c4 10             	add    $0x10,%esp
}
  101bfa:	90                   	nop
  101bfb:	83 c4 0c             	add    $0xc,%esp
  101bfe:	c3                   	ret    

00101bff <_Z41__static_initialization_and_destruction_0ii>:

}
  101bff:	83 ec 0c             	sub    $0xc,%esp
  101c02:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  101c07:	75 2e                	jne    101c37 <_Z41__static_initialization_and_destruction_0ii+0x38>
  101c09:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  101c10:	00 
  101c11:	75 24                	jne    101c37 <_Z41__static_initialization_and_destruction_0ii+0x38>
  101c13:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  101c18:	0f b6 00             	movzbl (%eax),%eax
  101c1b:	84 c0                	test   %al,%al
  101c1d:	75 18                	jne    101c37 <_Z41__static_initialization_and_destruction_0ii+0x38>
  101c1f:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  101c24:	c6 00 01             	movb   $0x1,(%eax)
  101c27:	83 ec 0c             	sub    $0xc,%esp
  101c2a:	68 60 53 11 00       	push   $0x115360
  101c2f:	e8 06 15 00 00       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  101c34:	83 c4 10             	add    $0x10,%esp
  101c37:	90                   	nop
  101c38:	83 c4 0c             	add    $0xc,%esp
  101c3b:	c3                   	ret    

00101c3c <_GLOBAL__sub_I__ZN3gdt7entriesE>:
  101c3c:	83 ec 0c             	sub    $0xc,%esp
  101c3f:	83 ec 08             	sub    $0x8,%esp
  101c42:	68 ff ff 00 00       	push   $0xffff
  101c47:	6a 01                	push   $0x1
  101c49:	e8 b1 ff ff ff       	call   101bff <_Z41__static_initialization_and_destruction_0ii>
  101c4e:	83 c4 10             	add    $0x10,%esp
  101c51:	83 c4 0c             	add    $0xc,%esp
  101c54:	c3                   	ret    

00101c55 <_ZN3idt8set_gateEhmth>:

entry idt_entries[256];
ptr  idt_ptr;

void set_gate(uint8_t num, uint32_t base, uint16_t sel, uint8_t flags)
{
  101c55:	83 ec 0c             	sub    $0xc,%esp
  101c58:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  101c5c:	8b 54 24 18          	mov    0x18(%esp),%edx
  101c60:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  101c64:	88 4c 24 08          	mov    %cl,0x8(%esp)
  101c68:	66 89 54 24 04       	mov    %dx,0x4(%esp)
  101c6d:	88 04 24             	mov    %al,(%esp)
    idt_entries[num].base_lo = base & 0xFFFF;
  101c70:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
  101c75:	8b 54 24 14          	mov    0x14(%esp),%edx
  101c79:	66 89 14 c5 60 00 11 	mov    %dx,0x110060(,%eax,8)
  101c80:	00 
    idt_entries[num].base_hi = (base >> 16) & 0xFFFF;
  101c81:	8b 44 24 14          	mov    0x14(%esp),%eax
  101c85:	c1 e8 10             	shr    $0x10,%eax
  101c88:	89 c2                	mov    %eax,%edx
  101c8a:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
  101c8f:	66 89 14 c5 66 00 11 	mov    %dx,0x110066(,%eax,8)
  101c96:	00 

    idt_entries[num].sel     = sel;
  101c97:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
  101c9c:	0f b7 54 24 04       	movzwl 0x4(%esp),%edx
  101ca1:	66 89 14 c5 62 00 11 	mov    %dx,0x110062(,%eax,8)
  101ca8:	00 
    idt_entries[num].always0 = 0;
  101ca9:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
  101cae:	c6 04 c5 64 00 11 00 	movb   $0x0,0x110064(,%eax,8)
  101cb5:	00 
    // We must uncomment the OR below when we get to using user-mode.
    // It sets the interrupt gate's privilege level to 3.
    idt_entries[num].flags   = flags /* | 0x60 */;
  101cb6:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
  101cbb:	0f b6 14 24          	movzbl (%esp),%edx
  101cbf:	88 14 c5 65 00 11 00 	mov    %dl,0x110065(,%eax,8)
}
  101cc6:	90                   	nop
  101cc7:	83 c4 0c             	add    $0xc,%esp
  101cca:	c3                   	ret    

00101ccb <_ZN3idt4initEv>:

void init()
{
  101ccb:	83 ec 0c             	sub    $0xc,%esp
    puts("Initializing ISRs");
  101cce:	83 ec 0c             	sub    $0xc,%esp
  101cd1:	68 78 87 10 00       	push   $0x108778
  101cd6:	e8 97 53 00 00       	call   107072 <puts>
  101cdb:	83 c4 10             	add    $0x10,%esp

    idt_ptr.limit = sizeof(entry) * size(idt_entries) -1;
  101cde:	83 ec 0c             	sub    $0xc,%esp
  101ce1:	68 60 00 11 00       	push   $0x110060
  101ce6:	e8 b1 57 00 00       	call   10749c <_Z4sizeIN3idt5entryELm256EEmRAT0__T_>
  101ceb:	83 c4 10             	add    $0x10,%esp
  101cee:	c1 e0 03             	shl    $0x3,%eax
  101cf1:	83 e8 01             	sub    $0x1,%eax
  101cf4:	66 a3 60 08 11 00    	mov    %ax,0x110860
    idt_ptr.base  = reinterpret_cast<uint32_t>(&idt_entries);
  101cfa:	b8 60 00 11 00       	mov    $0x110060,%eax
  101cff:	a3 62 08 11 00       	mov    %eax,0x110862

    memset(&idt_entries, 0, sizeof(entry)*size(idt_entries));
  101d04:	83 ec 0c             	sub    $0xc,%esp
  101d07:	68 60 00 11 00       	push   $0x110060
  101d0c:	e8 8b 57 00 00       	call   10749c <_Z4sizeIN3idt5entryELm256EEmRAT0__T_>
  101d11:	83 c4 10             	add    $0x10,%esp
  101d14:	c1 e0 03             	shl    $0x3,%eax
  101d17:	83 ec 04             	sub    $0x4,%esp
  101d1a:	50                   	push   %eax
  101d1b:	6a 00                	push   $0x0
  101d1d:	68 60 00 11 00       	push   $0x110060
  101d22:	e8 b4 53 00 00       	call   1070db <memset>
  101d27:	83 c4 10             	add    $0x10,%esp

    set_gate( 0, reinterpret_cast<uint32_t>(isr0) , 0x08, 0x8E);
  101d2a:	b8 08 2f 10 00       	mov    $0x102f08,%eax
  101d2f:	68 8e 00 00 00       	push   $0x8e
  101d34:	6a 08                	push   $0x8
  101d36:	50                   	push   %eax
  101d37:	6a 00                	push   $0x0
  101d39:	e8 17 ff ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101d3e:	83 c4 10             	add    $0x10,%esp
    set_gate( 1, reinterpret_cast<uint32_t>(isr1) , 0x08, 0x8E);
  101d41:	b8 11 2f 10 00       	mov    $0x102f11,%eax
  101d46:	68 8e 00 00 00       	push   $0x8e
  101d4b:	6a 08                	push   $0x8
  101d4d:	50                   	push   %eax
  101d4e:	6a 01                	push   $0x1
  101d50:	e8 00 ff ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101d55:	83 c4 10             	add    $0x10,%esp
    set_gate( 2, reinterpret_cast<uint32_t>(isr2) , 0x08, 0x8E);
  101d58:	b8 1a 2f 10 00       	mov    $0x102f1a,%eax
  101d5d:	68 8e 00 00 00       	push   $0x8e
  101d62:	6a 08                	push   $0x8
  101d64:	50                   	push   %eax
  101d65:	6a 02                	push   $0x2
  101d67:	e8 e9 fe ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101d6c:	83 c4 10             	add    $0x10,%esp
    set_gate( 3, reinterpret_cast<uint32_t>(isr3) , 0x08, 0x8E);
  101d6f:	b8 23 2f 10 00       	mov    $0x102f23,%eax
  101d74:	68 8e 00 00 00       	push   $0x8e
  101d79:	6a 08                	push   $0x8
  101d7b:	50                   	push   %eax
  101d7c:	6a 03                	push   $0x3
  101d7e:	e8 d2 fe ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101d83:	83 c4 10             	add    $0x10,%esp
    set_gate( 4, reinterpret_cast<uint32_t>(isr4) , 0x08, 0x8E);
  101d86:	b8 2c 2f 10 00       	mov    $0x102f2c,%eax
  101d8b:	68 8e 00 00 00       	push   $0x8e
  101d90:	6a 08                	push   $0x8
  101d92:	50                   	push   %eax
  101d93:	6a 04                	push   $0x4
  101d95:	e8 bb fe ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101d9a:	83 c4 10             	add    $0x10,%esp
    set_gate( 5, reinterpret_cast<uint32_t>(isr5) , 0x08, 0x8E);
  101d9d:	b8 35 2f 10 00       	mov    $0x102f35,%eax
  101da2:	68 8e 00 00 00       	push   $0x8e
  101da7:	6a 08                	push   $0x8
  101da9:	50                   	push   %eax
  101daa:	6a 05                	push   $0x5
  101dac:	e8 a4 fe ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101db1:	83 c4 10             	add    $0x10,%esp
    set_gate( 6, reinterpret_cast<uint32_t>(isr6) , 0x08, 0x8E);
  101db4:	b8 3e 2f 10 00       	mov    $0x102f3e,%eax
  101db9:	68 8e 00 00 00       	push   $0x8e
  101dbe:	6a 08                	push   $0x8
  101dc0:	50                   	push   %eax
  101dc1:	6a 06                	push   $0x6
  101dc3:	e8 8d fe ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101dc8:	83 c4 10             	add    $0x10,%esp
    set_gate( 7, reinterpret_cast<uint32_t>(isr7) , 0x08, 0x8E);
  101dcb:	b8 47 2f 10 00       	mov    $0x102f47,%eax
  101dd0:	68 8e 00 00 00       	push   $0x8e
  101dd5:	6a 08                	push   $0x8
  101dd7:	50                   	push   %eax
  101dd8:	6a 07                	push   $0x7
  101dda:	e8 76 fe ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101ddf:	83 c4 10             	add    $0x10,%esp
    set_gate( 8, reinterpret_cast<uint32_t>(isr8) , 0x08, 0x8E);
  101de2:	b8 50 2f 10 00       	mov    $0x102f50,%eax
  101de7:	68 8e 00 00 00       	push   $0x8e
  101dec:	6a 08                	push   $0x8
  101dee:	50                   	push   %eax
  101def:	6a 08                	push   $0x8
  101df1:	e8 5f fe ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101df6:	83 c4 10             	add    $0x10,%esp
    set_gate( 9, reinterpret_cast<uint32_t>(isr9) , 0x08, 0x8E);
  101df9:	b8 57 2f 10 00       	mov    $0x102f57,%eax
  101dfe:	68 8e 00 00 00       	push   $0x8e
  101e03:	6a 08                	push   $0x8
  101e05:	50                   	push   %eax
  101e06:	6a 09                	push   $0x9
  101e08:	e8 48 fe ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101e0d:	83 c4 10             	add    $0x10,%esp
    set_gate(10, reinterpret_cast<uint32_t>(isr10), 0x08, 0x8E);
  101e10:	b8 60 2f 10 00       	mov    $0x102f60,%eax
  101e15:	68 8e 00 00 00       	push   $0x8e
  101e1a:	6a 08                	push   $0x8
  101e1c:	50                   	push   %eax
  101e1d:	6a 0a                	push   $0xa
  101e1f:	e8 31 fe ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101e24:	83 c4 10             	add    $0x10,%esp
    set_gate(11, reinterpret_cast<uint32_t>(isr11), 0x08, 0x8E);
  101e27:	b8 67 2f 10 00       	mov    $0x102f67,%eax
  101e2c:	68 8e 00 00 00       	push   $0x8e
  101e31:	6a 08                	push   $0x8
  101e33:	50                   	push   %eax
  101e34:	6a 0b                	push   $0xb
  101e36:	e8 1a fe ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101e3b:	83 c4 10             	add    $0x10,%esp
    set_gate(12, reinterpret_cast<uint32_t>(isr12), 0x08, 0x8E);
  101e3e:	b8 6e 2f 10 00       	mov    $0x102f6e,%eax
  101e43:	68 8e 00 00 00       	push   $0x8e
  101e48:	6a 08                	push   $0x8
  101e4a:	50                   	push   %eax
  101e4b:	6a 0c                	push   $0xc
  101e4d:	e8 03 fe ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101e52:	83 c4 10             	add    $0x10,%esp
    set_gate(13, reinterpret_cast<uint32_t>(isr13), 0x08, 0x8E);
  101e55:	b8 75 2f 10 00       	mov    $0x102f75,%eax
  101e5a:	68 8e 00 00 00       	push   $0x8e
  101e5f:	6a 08                	push   $0x8
  101e61:	50                   	push   %eax
  101e62:	6a 0d                	push   $0xd
  101e64:	e8 ec fd ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101e69:	83 c4 10             	add    $0x10,%esp
    set_gate(14, reinterpret_cast<uint32_t>(isr14), 0x08, 0x8E);
  101e6c:	b8 7c 2f 10 00       	mov    $0x102f7c,%eax
  101e71:	68 8e 00 00 00       	push   $0x8e
  101e76:	6a 08                	push   $0x8
  101e78:	50                   	push   %eax
  101e79:	6a 0e                	push   $0xe
  101e7b:	e8 d5 fd ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101e80:	83 c4 10             	add    $0x10,%esp
    set_gate(15, reinterpret_cast<uint32_t>(isr15), 0x08, 0x8E);
  101e83:	b8 83 2f 10 00       	mov    $0x102f83,%eax
  101e88:	68 8e 00 00 00       	push   $0x8e
  101e8d:	6a 08                	push   $0x8
  101e8f:	50                   	push   %eax
  101e90:	6a 0f                	push   $0xf
  101e92:	e8 be fd ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101e97:	83 c4 10             	add    $0x10,%esp
    set_gate(16, reinterpret_cast<uint32_t>(isr16), 0x08, 0x8E);
  101e9a:	b8 8c 2f 10 00       	mov    $0x102f8c,%eax
  101e9f:	68 8e 00 00 00       	push   $0x8e
  101ea4:	6a 08                	push   $0x8
  101ea6:	50                   	push   %eax
  101ea7:	6a 10                	push   $0x10
  101ea9:	e8 a7 fd ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101eae:	83 c4 10             	add    $0x10,%esp
    set_gate(17, reinterpret_cast<uint32_t>(isr17), 0x08, 0x8E);
  101eb1:	b8 95 2f 10 00       	mov    $0x102f95,%eax
  101eb6:	68 8e 00 00 00       	push   $0x8e
  101ebb:	6a 08                	push   $0x8
  101ebd:	50                   	push   %eax
  101ebe:	6a 11                	push   $0x11
  101ec0:	e8 90 fd ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101ec5:	83 c4 10             	add    $0x10,%esp
    set_gate(18, reinterpret_cast<uint32_t>(isr18), 0x08, 0x8E);
  101ec8:	b8 9e 2f 10 00       	mov    $0x102f9e,%eax
  101ecd:	68 8e 00 00 00       	push   $0x8e
  101ed2:	6a 08                	push   $0x8
  101ed4:	50                   	push   %eax
  101ed5:	6a 12                	push   $0x12
  101ed7:	e8 79 fd ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101edc:	83 c4 10             	add    $0x10,%esp
    set_gate(19, reinterpret_cast<uint32_t>(isr19), 0x08, 0x8E);
  101edf:	b8 a7 2f 10 00       	mov    $0x102fa7,%eax
  101ee4:	68 8e 00 00 00       	push   $0x8e
  101ee9:	6a 08                	push   $0x8
  101eeb:	50                   	push   %eax
  101eec:	6a 13                	push   $0x13
  101eee:	e8 62 fd ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101ef3:	83 c4 10             	add    $0x10,%esp
    set_gate(20, reinterpret_cast<uint32_t>(isr20), 0x08, 0x8E);
  101ef6:	b8 b0 2f 10 00       	mov    $0x102fb0,%eax
  101efb:	68 8e 00 00 00       	push   $0x8e
  101f00:	6a 08                	push   $0x8
  101f02:	50                   	push   %eax
  101f03:	6a 14                	push   $0x14
  101f05:	e8 4b fd ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101f0a:	83 c4 10             	add    $0x10,%esp
    set_gate(21, reinterpret_cast<uint32_t>(isr21), 0x08, 0x8E);
  101f0d:	b8 b9 2f 10 00       	mov    $0x102fb9,%eax
  101f12:	68 8e 00 00 00       	push   $0x8e
  101f17:	6a 08                	push   $0x8
  101f19:	50                   	push   %eax
  101f1a:	6a 15                	push   $0x15
  101f1c:	e8 34 fd ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101f21:	83 c4 10             	add    $0x10,%esp
    set_gate(22, reinterpret_cast<uint32_t>(isr22), 0x08, 0x8E);
  101f24:	b8 c2 2f 10 00       	mov    $0x102fc2,%eax
  101f29:	68 8e 00 00 00       	push   $0x8e
  101f2e:	6a 08                	push   $0x8
  101f30:	50                   	push   %eax
  101f31:	6a 16                	push   $0x16
  101f33:	e8 1d fd ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101f38:	83 c4 10             	add    $0x10,%esp
    set_gate(23, reinterpret_cast<uint32_t>(isr23), 0x08, 0x8E);
  101f3b:	b8 cb 2f 10 00       	mov    $0x102fcb,%eax
  101f40:	68 8e 00 00 00       	push   $0x8e
  101f45:	6a 08                	push   $0x8
  101f47:	50                   	push   %eax
  101f48:	6a 17                	push   $0x17
  101f4a:	e8 06 fd ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101f4f:	83 c4 10             	add    $0x10,%esp
    set_gate(24, reinterpret_cast<uint32_t>(isr24), 0x08, 0x8E);
  101f52:	b8 d4 2f 10 00       	mov    $0x102fd4,%eax
  101f57:	68 8e 00 00 00       	push   $0x8e
  101f5c:	6a 08                	push   $0x8
  101f5e:	50                   	push   %eax
  101f5f:	6a 18                	push   $0x18
  101f61:	e8 ef fc ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101f66:	83 c4 10             	add    $0x10,%esp
    set_gate(25, reinterpret_cast<uint32_t>(isr25), 0x08, 0x8E);
  101f69:	b8 dd 2f 10 00       	mov    $0x102fdd,%eax
  101f6e:	68 8e 00 00 00       	push   $0x8e
  101f73:	6a 08                	push   $0x8
  101f75:	50                   	push   %eax
  101f76:	6a 19                	push   $0x19
  101f78:	e8 d8 fc ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101f7d:	83 c4 10             	add    $0x10,%esp
    set_gate(26, reinterpret_cast<uint32_t>(isr26), 0x08, 0x8E);
  101f80:	b8 e6 2f 10 00       	mov    $0x102fe6,%eax
  101f85:	68 8e 00 00 00       	push   $0x8e
  101f8a:	6a 08                	push   $0x8
  101f8c:	50                   	push   %eax
  101f8d:	6a 1a                	push   $0x1a
  101f8f:	e8 c1 fc ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101f94:	83 c4 10             	add    $0x10,%esp
    set_gate(27, reinterpret_cast<uint32_t>(isr27), 0x08, 0x8E);
  101f97:	b8 ef 2f 10 00       	mov    $0x102fef,%eax
  101f9c:	68 8e 00 00 00       	push   $0x8e
  101fa1:	6a 08                	push   $0x8
  101fa3:	50                   	push   %eax
  101fa4:	6a 1b                	push   $0x1b
  101fa6:	e8 aa fc ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101fab:	83 c4 10             	add    $0x10,%esp
    set_gate(28, reinterpret_cast<uint32_t>(isr28), 0x08, 0x8E);
  101fae:	b8 f8 2f 10 00       	mov    $0x102ff8,%eax
  101fb3:	68 8e 00 00 00       	push   $0x8e
  101fb8:	6a 08                	push   $0x8
  101fba:	50                   	push   %eax
  101fbb:	6a 1c                	push   $0x1c
  101fbd:	e8 93 fc ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101fc2:	83 c4 10             	add    $0x10,%esp
    set_gate(29, reinterpret_cast<uint32_t>(isr29), 0x08, 0x8E);
  101fc5:	b8 fe 2f 10 00       	mov    $0x102ffe,%eax
  101fca:	68 8e 00 00 00       	push   $0x8e
  101fcf:	6a 08                	push   $0x8
  101fd1:	50                   	push   %eax
  101fd2:	6a 1d                	push   $0x1d
  101fd4:	e8 7c fc ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101fd9:	83 c4 10             	add    $0x10,%esp
    set_gate(30, reinterpret_cast<uint32_t>(isr30), 0x08, 0x8E);
  101fdc:	b8 04 30 10 00       	mov    $0x103004,%eax
  101fe1:	68 8e 00 00 00       	push   $0x8e
  101fe6:	6a 08                	push   $0x8
  101fe8:	50                   	push   %eax
  101fe9:	6a 1e                	push   $0x1e
  101feb:	e8 65 fc ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  101ff0:	83 c4 10             	add    $0x10,%esp
    set_gate(31, reinterpret_cast<uint32_t>(isr31), 0x08, 0x8E);
  101ff3:	b8 0a 30 10 00       	mov    $0x10300a,%eax
  101ff8:	68 8e 00 00 00       	push   $0x8e
  101ffd:	6a 08                	push   $0x8
  101fff:	50                   	push   %eax
  102000:	6a 1f                	push   $0x1f
  102002:	e8 4e fc ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  102007:	83 c4 10             	add    $0x10,%esp
    set_gate(32, reinterpret_cast<uint32_t>(irq0), 0x08, 0x8E);
  10200a:	b8 10 30 10 00       	mov    $0x103010,%eax
  10200f:	68 8e 00 00 00       	push   $0x8e
  102014:	6a 08                	push   $0x8
  102016:	50                   	push   %eax
  102017:	6a 20                	push   $0x20
  102019:	e8 37 fc ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  10201e:	83 c4 10             	add    $0x10,%esp
    set_gate(33, reinterpret_cast<uint32_t>(irq1), 0x08, 0x8E);
  102021:	b8 19 30 10 00       	mov    $0x103019,%eax
  102026:	68 8e 00 00 00       	push   $0x8e
  10202b:	6a 08                	push   $0x8
  10202d:	50                   	push   %eax
  10202e:	6a 21                	push   $0x21
  102030:	e8 20 fc ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  102035:	83 c4 10             	add    $0x10,%esp
    set_gate(34, reinterpret_cast<uint32_t>(irq2), 0x08, 0x8E);
  102038:	b8 22 30 10 00       	mov    $0x103022,%eax
  10203d:	68 8e 00 00 00       	push   $0x8e
  102042:	6a 08                	push   $0x8
  102044:	50                   	push   %eax
  102045:	6a 22                	push   $0x22
  102047:	e8 09 fc ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  10204c:	83 c4 10             	add    $0x10,%esp
    set_gate(35, reinterpret_cast<uint32_t>(irq3), 0x08, 0x8E);
  10204f:	b8 2b 30 10 00       	mov    $0x10302b,%eax
  102054:	68 8e 00 00 00       	push   $0x8e
  102059:	6a 08                	push   $0x8
  10205b:	50                   	push   %eax
  10205c:	6a 23                	push   $0x23
  10205e:	e8 f2 fb ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  102063:	83 c4 10             	add    $0x10,%esp
    set_gate(36, reinterpret_cast<uint32_t>(irq4), 0x08, 0x8E);
  102066:	b8 31 30 10 00       	mov    $0x103031,%eax
  10206b:	68 8e 00 00 00       	push   $0x8e
  102070:	6a 08                	push   $0x8
  102072:	50                   	push   %eax
  102073:	6a 24                	push   $0x24
  102075:	e8 db fb ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  10207a:	83 c4 10             	add    $0x10,%esp
    set_gate(37, reinterpret_cast<uint32_t>(irq5), 0x08, 0x8E);
  10207d:	b8 37 30 10 00       	mov    $0x103037,%eax
  102082:	68 8e 00 00 00       	push   $0x8e
  102087:	6a 08                	push   $0x8
  102089:	50                   	push   %eax
  10208a:	6a 25                	push   $0x25
  10208c:	e8 c4 fb ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  102091:	83 c4 10             	add    $0x10,%esp
    set_gate(38, reinterpret_cast<uint32_t>(irq6), 0x08, 0x8E);
  102094:	b8 3d 30 10 00       	mov    $0x10303d,%eax
  102099:	68 8e 00 00 00       	push   $0x8e
  10209e:	6a 08                	push   $0x8
  1020a0:	50                   	push   %eax
  1020a1:	6a 26                	push   $0x26
  1020a3:	e8 ad fb ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  1020a8:	83 c4 10             	add    $0x10,%esp
    set_gate(39, reinterpret_cast<uint32_t>(irq7), 0x08, 0x8E);
  1020ab:	b8 43 30 10 00       	mov    $0x103043,%eax
  1020b0:	68 8e 00 00 00       	push   $0x8e
  1020b5:	6a 08                	push   $0x8
  1020b7:	50                   	push   %eax
  1020b8:	6a 27                	push   $0x27
  1020ba:	e8 96 fb ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  1020bf:	83 c4 10             	add    $0x10,%esp
    set_gate(40, reinterpret_cast<uint32_t>(irq8), 0x08, 0x8E);
  1020c2:	b8 49 30 10 00       	mov    $0x103049,%eax
  1020c7:	68 8e 00 00 00       	push   $0x8e
  1020cc:	6a 08                	push   $0x8
  1020ce:	50                   	push   %eax
  1020cf:	6a 28                	push   $0x28
  1020d1:	e8 7f fb ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  1020d6:	83 c4 10             	add    $0x10,%esp
    set_gate(41, reinterpret_cast<uint32_t>(irq9), 0x08, 0x8E);
  1020d9:	b8 4f 30 10 00       	mov    $0x10304f,%eax
  1020de:	68 8e 00 00 00       	push   $0x8e
  1020e3:	6a 08                	push   $0x8
  1020e5:	50                   	push   %eax
  1020e6:	6a 29                	push   $0x29
  1020e8:	e8 68 fb ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  1020ed:	83 c4 10             	add    $0x10,%esp
    set_gate(42, reinterpret_cast<uint32_t>(irq10), 0x08, 0x8E);
  1020f0:	b8 55 30 10 00       	mov    $0x103055,%eax
  1020f5:	68 8e 00 00 00       	push   $0x8e
  1020fa:	6a 08                	push   $0x8
  1020fc:	50                   	push   %eax
  1020fd:	6a 2a                	push   $0x2a
  1020ff:	e8 51 fb ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  102104:	83 c4 10             	add    $0x10,%esp
    set_gate(43, reinterpret_cast<uint32_t>(irq11), 0x08, 0x8E);
  102107:	b8 5b 30 10 00       	mov    $0x10305b,%eax
  10210c:	68 8e 00 00 00       	push   $0x8e
  102111:	6a 08                	push   $0x8
  102113:	50                   	push   %eax
  102114:	6a 2b                	push   $0x2b
  102116:	e8 3a fb ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  10211b:	83 c4 10             	add    $0x10,%esp
    set_gate(44, reinterpret_cast<uint32_t>(irq12), 0x08, 0x8E);
  10211e:	b8 61 30 10 00       	mov    $0x103061,%eax
  102123:	68 8e 00 00 00       	push   $0x8e
  102128:	6a 08                	push   $0x8
  10212a:	50                   	push   %eax
  10212b:	6a 2c                	push   $0x2c
  10212d:	e8 23 fb ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  102132:	83 c4 10             	add    $0x10,%esp
    set_gate(45, reinterpret_cast<uint32_t>(irq13), 0x08, 0x8E);
  102135:	b8 67 30 10 00       	mov    $0x103067,%eax
  10213a:	68 8e 00 00 00       	push   $0x8e
  10213f:	6a 08                	push   $0x8
  102141:	50                   	push   %eax
  102142:	6a 2d                	push   $0x2d
  102144:	e8 0c fb ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  102149:	83 c4 10             	add    $0x10,%esp
    set_gate(46, reinterpret_cast<uint32_t>(irq14), 0x08, 0x8E);
  10214c:	b8 6d 30 10 00       	mov    $0x10306d,%eax
  102151:	68 8e 00 00 00       	push   $0x8e
  102156:	6a 08                	push   $0x8
  102158:	50                   	push   %eax
  102159:	6a 2e                	push   $0x2e
  10215b:	e8 f5 fa ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  102160:	83 c4 10             	add    $0x10,%esp
    set_gate(47, reinterpret_cast<uint32_t>(irq15), 0x08, 0x8E);
  102163:	b8 73 30 10 00       	mov    $0x103073,%eax
  102168:	68 8e 00 00 00       	push   $0x8e
  10216d:	6a 08                	push   $0x8
  10216f:	50                   	push   %eax
  102170:	6a 2f                	push   $0x2f
  102172:	e8 de fa ff ff       	call   101c55 <_ZN3idt8set_gateEhmth>
  102177:	83 c4 10             	add    $0x10,%esp

    idt_flush(reinterpret_cast<uint32_t>(&idt_ptr));
  10217a:	b8 60 08 11 00       	mov    $0x110860,%eax
  10217f:	83 ec 0c             	sub    $0xc,%esp
  102182:	50                   	push   %eax
  102183:	e8 78 0d 00 00       	call   102f00 <idt_flush>
  102188:	83 c4 10             	add    $0x10,%esp

    sti();
  10218b:	e8 09 53 00 00       	call   107499 <_Z3stiv>

    puts("ISRs and IDT initialized");
  102190:	83 ec 0c             	sub    $0xc,%esp
  102193:	68 8a 87 10 00       	push   $0x10878a
  102198:	e8 d5 4e 00 00       	call   107072 <puts>
  10219d:	83 c4 10             	add    $0x10,%esp
}
  1021a0:	90                   	nop
  1021a1:	83 c4 0c             	add    $0xc,%esp
  1021a4:	c3                   	ret    

001021a5 <_Z41__static_initialization_and_destruction_0ii>:

}
  1021a5:	83 ec 0c             	sub    $0xc,%esp
  1021a8:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  1021ad:	75 2e                	jne    1021dd <_Z41__static_initialization_and_destruction_0ii+0x38>
  1021af:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  1021b6:	00 
  1021b7:	75 24                	jne    1021dd <_Z41__static_initialization_and_destruction_0ii+0x38>
  1021b9:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  1021be:	0f b6 00             	movzbl (%eax),%eax
  1021c1:	84 c0                	test   %al,%al
  1021c3:	75 18                	jne    1021dd <_Z41__static_initialization_and_destruction_0ii+0x38>
  1021c5:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  1021ca:	c6 00 01             	movb   $0x1,(%eax)
  1021cd:	83 ec 0c             	sub    $0xc,%esp
  1021d0:	68 60 53 11 00       	push   $0x115360
  1021d5:	e8 60 0f 00 00       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  1021da:	83 c4 10             	add    $0x10,%esp
  1021dd:	90                   	nop
  1021de:	83 c4 0c             	add    $0xc,%esp
  1021e1:	c3                   	ret    

001021e2 <_GLOBAL__sub_I__ZN3idt11idt_entriesE>:
  1021e2:	83 ec 0c             	sub    $0xc,%esp
  1021e5:	83 ec 08             	sub    $0x8,%esp
  1021e8:	68 ff ff 00 00       	push   $0xffff
  1021ed:	6a 01                	push   $0x1
  1021ef:	e8 b1 ff ff ff       	call   1021a5 <_Z41__static_initialization_and_destruction_0ii>
  1021f4:	83 c4 10             	add    $0x10,%esp
  1021f7:	83 c4 0c             	add    $0xc,%esp
  1021fa:	c3                   	ret    

001021fb <_Z4outbth>:
*/

#include "io.hpp"

void outb(uint16_t port, uint8_t val)
{
  1021fb:	83 ec 08             	sub    $0x8,%esp
  1021fe:	8b 54 24 0c          	mov    0xc(%esp),%edx
  102202:	8b 44 24 10          	mov    0x10(%esp),%eax
  102206:	66 89 54 24 04       	mov    %dx,0x4(%esp)
  10220b:	88 04 24             	mov    %al,(%esp)
    asm volatile ( "outb %0, %1" : : "a"(val), "Nd"(port) );
  10220e:	0f b6 04 24          	movzbl (%esp),%eax
  102212:	0f b7 54 24 04       	movzwl 0x4(%esp),%edx
  102217:	ee                   	out    %al,(%dx)
}
  102218:	90                   	nop
  102219:	83 c4 08             	add    $0x8,%esp
  10221c:	c3                   	ret    

0010221d <_Z4outwtt>:

void outw(uint16_t port, uint16_t val)
{
  10221d:	83 ec 08             	sub    $0x8,%esp
  102220:	8b 54 24 0c          	mov    0xc(%esp),%edx
  102224:	8b 44 24 10          	mov    0x10(%esp),%eax
  102228:	66 89 54 24 04       	mov    %dx,0x4(%esp)
  10222d:	66 89 04 24          	mov    %ax,(%esp)
    asm volatile ( "outw %0, %1" : : "a"(val), "Nd"(port) );
  102231:	0f b7 04 24          	movzwl (%esp),%eax
  102235:	0f b7 54 24 04       	movzwl 0x4(%esp),%edx
  10223a:	66 ef                	out    %ax,(%dx)
}
  10223c:	90                   	nop
  10223d:	83 c4 08             	add    $0x8,%esp
  102240:	c3                   	ret    

00102241 <_Z4outltm>:

void outl(uint16_t port, uint32_t val)
{
  102241:	83 ec 04             	sub    $0x4,%esp
  102244:	8b 44 24 08          	mov    0x8(%esp),%eax
  102248:	66 89 04 24          	mov    %ax,(%esp)
    asm volatile ( "outl %0, %1" : : "a"(val), "Nd"(port) );
  10224c:	8b 44 24 0c          	mov    0xc(%esp),%eax
  102250:	0f b7 14 24          	movzwl (%esp),%edx
  102254:	ef                   	out    %eax,(%dx)
}
  102255:	90                   	nop
  102256:	83 c4 04             	add    $0x4,%esp
  102259:	c3                   	ret    

0010225a <_Z3inbt>:

uint8_t inb(uint16_t port)
{
  10225a:	83 ec 14             	sub    $0x14,%esp
  10225d:	8b 44 24 18          	mov    0x18(%esp),%eax
  102261:	66 89 04 24          	mov    %ax,(%esp)
    uint8_t ret;
    asm volatile ( "inb %1, %0"
                   : "=a"(ret)
                   : "Nd"(port) );
  102265:	0f b7 04 24          	movzwl (%esp),%eax
  102269:	89 c2                	mov    %eax,%edx
  10226b:	ec                   	in     (%dx),%al
  10226c:	88 44 24 13          	mov    %al,0x13(%esp)
    return ret;
  102270:	0f b6 44 24 13       	movzbl 0x13(%esp),%eax
}
  102275:	83 c4 14             	add    $0x14,%esp
  102278:	c3                   	ret    

00102279 <_Z3inwt>:

uint16_t inw(uint16_t port)
{
  102279:	83 ec 14             	sub    $0x14,%esp
  10227c:	8b 44 24 18          	mov    0x18(%esp),%eax
  102280:	66 89 04 24          	mov    %ax,(%esp)
    uint16_t ret;
    asm volatile ( "inw %1, %0"
                   : "=a"(ret)
                   : "Nd"(port) );
  102284:	0f b7 04 24          	movzwl (%esp),%eax
  102288:	89 c2                	mov    %eax,%edx
  10228a:	66 ed                	in     (%dx),%ax
  10228c:	66 89 44 24 12       	mov    %ax,0x12(%esp)
    return ret;
  102291:	0f b7 44 24 12       	movzwl 0x12(%esp),%eax
}
  102296:	83 c4 14             	add    $0x14,%esp
  102299:	c3                   	ret    

0010229a <_Z3inlt>:

uint32_t inl(uint16_t port)
{
  10229a:	83 ec 14             	sub    $0x14,%esp
  10229d:	8b 44 24 18          	mov    0x18(%esp),%eax
  1022a1:	66 89 04 24          	mov    %ax,(%esp)
    uint32_t ret;
    asm volatile ( "inl %1, %0"
                   : "=a"(ret)
                   : "Nd"(port) );
  1022a5:	0f b7 04 24          	movzwl (%esp),%eax
  1022a9:	89 c2                	mov    %eax,%edx
  1022ab:	ed                   	in     (%dx),%eax
  1022ac:	89 44 24 10          	mov    %eax,0x10(%esp)
    return ret;
  1022b0:	8b 44 24 10          	mov    0x10(%esp),%eax
}
  1022b4:	83 c4 14             	add    $0x14,%esp
  1022b7:	c3                   	ret    

001022b8 <_Z7io_waitv>:

void io_wait()
{
    asm volatile ( "outb %%al, $0x80" : : "a"(0) );
  1022b8:	b8 00 00 00 00       	mov    $0x0,%eax
  1022bd:	e6 80                	out    %al,$0x80
}
  1022bf:	90                   	nop
  1022c0:	c3                   	ret    

001022c1 <isr_handler>:

isr::isr_t handlers[256] { nullptr };

extern "C"
const registers* isr_handler(const registers* const regs)
{
  1022c1:	56                   	push   %esi
  1022c2:	53                   	push   %ebx
  1022c3:	83 ec 04             	sub    $0x4,%esp
    dump(regs);
  1022c6:	83 ec 0c             	sub    $0xc,%esp
  1022c9:	ff 74 24 1c          	pushl  0x1c(%esp)
  1022cd:	e8 18 52 00 00       	call   1074ea <_Z4dumpPK9registers>
  1022d2:	83 c4 10             	add    $0x10,%esp
    panic("Unhandeld interrupt 0x%x with error code 0x%x at %p\n"
  1022d5:	e8 da 51 00 00       	call   1074b4 <_Z3cr2v>
  1022da:	89 c6                	mov    %eax,%esi
          "edx : 0x%x\ncr2 : 0x%x", regs->int_no, regs->err_code, regs->eip, regs->edx, cr2());
  1022dc:	8b 44 24 10          	mov    0x10(%esp),%eax
  1022e0:	8b 58 18             	mov    0x18(%eax),%ebx
  1022e3:	8b 44 24 10          	mov    0x10(%esp),%eax
  1022e7:	8b 48 34             	mov    0x34(%eax),%ecx
  1022ea:	8b 44 24 10          	mov    0x10(%esp),%eax
  1022ee:	8b 50 30             	mov    0x30(%eax),%edx
  1022f1:	8b 44 24 10          	mov    0x10(%esp),%eax
  1022f5:	8b 40 2c             	mov    0x2c(%eax),%eax
    panic("Unhandeld interrupt 0x%x with error code 0x%x at %p\n"
  1022f8:	83 ec 08             	sub    $0x8,%esp
  1022fb:	56                   	push   %esi
  1022fc:	53                   	push   %ebx
  1022fd:	51                   	push   %ecx
  1022fe:	52                   	push   %edx
  1022ff:	50                   	push   %eax
  102300:	68 94 88 10 00       	push   $0x108894
  102305:	e8 f8 26 00 00       	call   104a02 <_Z5panicPKcz>

0010230a <irq_handler>:
    return regs;
}

extern "C"
const registers* irq_handler(const registers* const regs)
{
  10230a:	83 ec 1c             	sub    $0x1c,%esp
    pic::send_eoi(regs->int_no-31);
  10230d:	8b 44 24 20          	mov    0x20(%esp),%eax
  102311:	8b 40 2c             	mov    0x2c(%eax),%eax
  102314:	83 e8 1f             	sub    $0x1f,%eax
  102317:	0f b6 c0             	movzbl %al,%eax
  10231a:	83 ec 0c             	sub    $0xc,%esp
  10231d:	50                   	push   %eax
  10231e:	e8 ff 21 00 00       	call   104522 <_ZN3pic8send_eoiEh>
  102323:	83 c4 10             	add    $0x10,%esp
    if (auto handl = handlers[regs->int_no]; handl)
  102326:	8b 44 24 20          	mov    0x20(%esp),%eax
  10232a:	8b 40 2c             	mov    0x2c(%eax),%eax
  10232d:	8b 04 85 80 08 11 00 	mov    0x110880(,%eax,4),%eax
  102334:	89 44 24 0c          	mov    %eax,0xc(%esp)
  102338:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
  10233d:	74 10                	je     10234f <irq_handler+0x45>
    {
        handl(regs);
  10233f:	83 ec 0c             	sub    $0xc,%esp
  102342:	ff 74 24 2c          	pushl  0x2c(%esp)
  102346:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10234a:	ff d0                	call   *%eax
  10234c:	83 c4 10             	add    $0x10,%esp
    }

    return regs;
  10234f:	8b 44 24 20          	mov    0x20(%esp),%eax
}
  102353:	83 c4 1c             	add    $0x1c,%esp
  102356:	c3                   	ret    

00102357 <_ZN3isr16register_handlerEhPFvPK9registersE>:

void isr::register_handler(uint8_t num, isr::isr_t handler)
{
  102357:	83 ec 04             	sub    $0x4,%esp
  10235a:	8b 44 24 08          	mov    0x8(%esp),%eax
  10235e:	88 04 24             	mov    %al,(%esp)
    handlers[num] = handler;
  102361:	0f b6 04 24          	movzbl (%esp),%eax
  102365:	8b 54 24 0c          	mov    0xc(%esp),%edx
  102369:	89 14 85 80 08 11 00 	mov    %edx,0x110880(,%eax,4)
}
  102370:	90                   	nop
  102371:	83 c4 04             	add    $0x4,%esp
  102374:	c3                   	ret    
  102375:	90                   	nop

00102376 <_ZN7Meminfo11free_framesEv>:

#include "multiboot/multiboot.h"
#include "utils/addr.hpp"

size_t Meminfo::free_frames()
{
  102376:	83 ec 1c             	sub    $0x1c,%esp
    size_t counter = 0;
  102379:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  102380:	00 

    for (multiboot_memory_map_t *mmap = Meminfo::mmap_addr;
  102381:	a1 c8 ef 11 00       	mov    0x11efc8,%eax
  102386:	89 44 24 08          	mov    %eax,0x8(%esp)
         (uintptr_t)mmap < phys(info->mmap_addr) + info->mmap_length;
  10238a:	a1 cc ef 11 00       	mov    0x11efcc,%eax
  10238f:	8b 40 30             	mov    0x30(%eax),%eax
  102392:	83 ec 0c             	sub    $0xc,%esp
  102395:	50                   	push   %eax
  102396:	e8 a4 52 00 00       	call   10763f <_Z4physm>
  10239b:	83 c4 10             	add    $0x10,%esp
  10239e:	89 c2                	mov    %eax,%edx
  1023a0:	a1 cc ef 11 00       	mov    0x11efcc,%eax
  1023a5:	8b 40 2c             	mov    0x2c(%eax),%eax
  1023a8:	01 c2                	add    %eax,%edx
  1023aa:	8b 44 24 08          	mov    0x8(%esp),%eax
  1023ae:	39 c2                	cmp    %eax,%edx
  1023b0:	0f 97 c0             	seta   %al
  1023b3:	84 c0                	test   %al,%al
  1023b5:	74 26                	je     1023dd <_ZN7Meminfo11free_framesEv+0x67>
         mmap = (multiboot_memory_map_t *) ((unsigned long) mmap
                                            + mmap->size + sizeof (mmap->size)))
    {
        if (mmap->type == 1)
  1023b7:	8b 44 24 08          	mov    0x8(%esp),%eax
  1023bb:	8b 40 14             	mov    0x14(%eax),%eax
  1023be:	83 f8 01             	cmp    $0x1,%eax
  1023c1:	75 05                	jne    1023c8 <_ZN7Meminfo11free_framesEv+0x52>
        {
            ++counter;
  1023c3:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
                                            + mmap->size + sizeof (mmap->size)))
  1023c8:	8b 44 24 08          	mov    0x8(%esp),%eax
  1023cc:	8b 10                	mov    (%eax),%edx
  1023ce:	8b 44 24 08          	mov    0x8(%esp),%eax
  1023d2:	01 d0                	add    %edx,%eax
  1023d4:	83 c0 04             	add    $0x4,%eax
         mmap = (multiboot_memory_map_t *) ((unsigned long) mmap
  1023d7:	89 44 24 08          	mov    %eax,0x8(%esp)
    for (multiboot_memory_map_t *mmap = Meminfo::mmap_addr;
  1023db:	eb ad                	jmp    10238a <_ZN7Meminfo11free_framesEv+0x14>
        }
    }

    return counter;
  1023dd:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  1023e1:	83 c4 1c             	add    $0x1c,%esp
  1023e4:	c3                   	ret    
  1023e5:	90                   	nop

001023e6 <_ZN7Meminfo13largest_frameEv>:

multiboot_memory_map_t *Meminfo::largest_frame()
{
  1023e6:	83 ec 1c             	sub    $0x1c,%esp
    multiboot_memory_map_t* msf = Meminfo::mmap_addr;
  1023e9:	a1 c8 ef 11 00       	mov    0x11efc8,%eax
  1023ee:	89 44 24 0c          	mov    %eax,0xc(%esp)

    for (multiboot_memory_map_t *mmap = Meminfo::mmap_addr;
  1023f2:	a1 c8 ef 11 00       	mov    0x11efc8,%eax
  1023f7:	89 44 24 08          	mov    %eax,0x8(%esp)
         (uintptr_t)mmap < phys(info->mmap_addr) + info->mmap_length;
  1023fb:	a1 cc ef 11 00       	mov    0x11efcc,%eax
  102400:	8b 40 30             	mov    0x30(%eax),%eax
  102403:	83 ec 0c             	sub    $0xc,%esp
  102406:	50                   	push   %eax
  102407:	e8 33 52 00 00       	call   10763f <_Z4physm>
  10240c:	83 c4 10             	add    $0x10,%esp
  10240f:	89 c2                	mov    %eax,%edx
  102411:	a1 cc ef 11 00       	mov    0x11efcc,%eax
  102416:	8b 40 2c             	mov    0x2c(%eax),%eax
  102419:	01 c2                	add    %eax,%edx
  10241b:	8b 44 24 08          	mov    0x8(%esp),%eax
  10241f:	39 c2                	cmp    %eax,%edx
  102421:	0f 97 c0             	seta   %al
  102424:	84 c0                	test   %al,%al
  102426:	74 2d                	je     102455 <_ZN7Meminfo13largest_frameEv+0x6f>
         mmap = (multiboot_memory_map_t *) ((unsigned long) mmap
                                            + mmap->size + sizeof (mmap->size)))
    {
        if (mmap->size > msf->size)
  102428:	8b 44 24 08          	mov    0x8(%esp),%eax
  10242c:	8b 10                	mov    (%eax),%edx
  10242e:	8b 44 24 0c          	mov    0xc(%esp),%eax
  102432:	8b 00                	mov    (%eax),%eax
  102434:	39 c2                	cmp    %eax,%edx
  102436:	76 08                	jbe    102440 <_ZN7Meminfo13largest_frameEv+0x5a>
        {
            msf = mmap;
  102438:	8b 44 24 08          	mov    0x8(%esp),%eax
  10243c:	89 44 24 0c          	mov    %eax,0xc(%esp)
                                            + mmap->size + sizeof (mmap->size)))
  102440:	8b 44 24 08          	mov    0x8(%esp),%eax
  102444:	8b 10                	mov    (%eax),%edx
  102446:	8b 44 24 08          	mov    0x8(%esp),%eax
  10244a:	01 d0                	add    %edx,%eax
  10244c:	83 c0 04             	add    $0x4,%eax
         mmap = (multiboot_memory_map_t *) ((unsigned long) mmap
  10244f:	89 44 24 08          	mov    %eax,0x8(%esp)
    for (multiboot_memory_map_t *mmap = Meminfo::mmap_addr;
  102453:	eb a6                	jmp    1023fb <_ZN7Meminfo13largest_frameEv+0x15>
        }
    }

    return msf;
  102455:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  102459:	83 c4 1c             	add    $0x1c,%esp
  10245c:	c3                   	ret    
  10245d:	90                   	nop

0010245e <_ZN7Meminfo5frameEm>:

multiboot_memory_map_t *Meminfo::frame(size_t idx)
{
  10245e:	83 ec 1c             	sub    $0x1c,%esp
    size_t counter = 0;
  102461:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  102468:	00 

    for (multiboot_memory_map_t *mmap = Meminfo::mmap_addr;
  102469:	a1 c8 ef 11 00       	mov    0x11efc8,%eax
  10246e:	89 44 24 08          	mov    %eax,0x8(%esp)
         (uintptr_t)mmap < phys(info->mmap_addr) + info->mmap_length;
  102472:	a1 cc ef 11 00       	mov    0x11efcc,%eax
  102477:	8b 40 30             	mov    0x30(%eax),%eax
  10247a:	83 ec 0c             	sub    $0xc,%esp
  10247d:	50                   	push   %eax
  10247e:	e8 bc 51 00 00       	call   10763f <_Z4physm>
  102483:	83 c4 10             	add    $0x10,%esp
  102486:	89 c2                	mov    %eax,%edx
  102488:	a1 cc ef 11 00       	mov    0x11efcc,%eax
  10248d:	8b 40 2c             	mov    0x2c(%eax),%eax
  102490:	01 c2                	add    %eax,%edx
  102492:	8b 44 24 08          	mov    0x8(%esp),%eax
  102496:	39 c2                	cmp    %eax,%edx
  102498:	0f 97 c0             	seta   %al
  10249b:	84 c0                	test   %al,%al
  10249d:	74 36                	je     1024d5 <_ZN7Meminfo5frameEm+0x77>
         mmap = (multiboot_memory_map_t *) ((unsigned long) mmap
                                            + mmap->size + sizeof (mmap->size)))
    {
        if (mmap->type == 1)
  10249f:	8b 44 24 08          	mov    0x8(%esp),%eax
  1024a3:	8b 40 14             	mov    0x14(%eax),%eax
  1024a6:	83 f8 01             	cmp    $0x1,%eax
  1024a9:	75 15                	jne    1024c0 <_ZN7Meminfo5frameEm+0x62>
        {
            if (counter == idx)
  1024ab:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1024af:	3b 44 24 20          	cmp    0x20(%esp),%eax
  1024b3:	75 06                	jne    1024bb <_ZN7Meminfo5frameEm+0x5d>
            {
            return mmap;
  1024b5:	8b 44 24 08          	mov    0x8(%esp),%eax
  1024b9:	eb 1f                	jmp    1024da <_ZN7Meminfo5frameEm+0x7c>
            }
            ++counter;
  1024bb:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
                                            + mmap->size + sizeof (mmap->size)))
  1024c0:	8b 44 24 08          	mov    0x8(%esp),%eax
  1024c4:	8b 10                	mov    (%eax),%edx
  1024c6:	8b 44 24 08          	mov    0x8(%esp),%eax
  1024ca:	01 d0                	add    %edx,%eax
  1024cc:	83 c0 04             	add    $0x4,%eax
         mmap = (multiboot_memory_map_t *) ((unsigned long) mmap
  1024cf:	89 44 24 08          	mov    %eax,0x8(%esp)
    for (multiboot_memory_map_t *mmap = Meminfo::mmap_addr;
  1024d3:	eb 9d                	jmp    102472 <_ZN7Meminfo5frameEm+0x14>
        }
    }

    return nullptr;
  1024d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  1024da:	83 c4 1c             	add    $0x1c,%esp
  1024dd:	c3                   	ret    

001024de <_ZN6Paging4initEv>:
extern "C" const uint32_t page_table_0;

extern "C" void init_paging(uint32_t page_directory);

void Paging::init()
{
  1024de:	83 ec 2c             	sub    $0x2c,%esp
    uint32_t* pd0 = (uint32_t*)&page_directory;
  1024e1:	c7 44 24 10 00 00 12 	movl   $0x120000,0x10(%esp)
  1024e8:	00 
    pd0[0] = (uint32_t)&page_table_0;
  1024e9:	ba 00 10 12 00       	mov    $0x121000,%edx
  1024ee:	8b 44 24 10          	mov    0x10(%esp),%eax
  1024f2:	89 10                	mov    %edx,(%eax)
    pd0[0] |= 3;
  1024f4:	8b 44 24 10          	mov    0x10(%esp),%eax
  1024f8:	8b 00                	mov    (%eax),%eax
  1024fa:	83 c8 03             	or     $0x3,%eax
  1024fd:	89 c2                	mov    %eax,%edx
  1024ff:	8b 44 24 10          	mov    0x10(%esp),%eax
  102503:	89 10                	mov    %edx,(%eax)
    for (size_t i = 1; i < 1024; i++)
  102505:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
  10250c:	00 
  10250d:	81 7c 24 1c ff 03 00 	cmpl   $0x3ff,0x1c(%esp)
  102514:	00 
  102515:	77 1e                	ja     102535 <_ZN6Paging4initEv+0x57>
    {
        pd0[i] = 0;
  102517:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10251b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  102522:	8b 44 24 10          	mov    0x10(%esp),%eax
  102526:	01 d0                	add    %edx,%eax
  102528:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    for (size_t i = 1; i < 1024; i++)
  10252e:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
  102533:	eb d8                	jmp    10250d <_ZN6Paging4initEv+0x2f>
    }


    /* Création de la Page Table[0] */
    uint32_t* pt0 = (uint32_t*)&page_table_0;
  102535:	c7 44 24 0c 00 10 12 	movl   $0x121000,0xc(%esp)
  10253c:	00 
    uint32_t page_addr = 0;
  10253d:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  102544:	00 
    for (size_t i = 0; i < 1024; i++)
  102545:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  10254c:	00 
  10254d:	81 7c 24 14 ff 03 00 	cmpl   $0x3ff,0x14(%esp)
  102554:	00 
  102555:	77 4f                	ja     1025a6 <_ZN6Paging4initEv+0xc8>
    {
        pt0[i] = page_addr;
  102557:	8b 44 24 14          	mov    0x14(%esp),%eax
  10255b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  102562:	8b 44 24 0c          	mov    0xc(%esp),%eax
  102566:	01 c2                	add    %eax,%edx
  102568:	8b 44 24 18          	mov    0x18(%esp),%eax
  10256c:	89 02                	mov    %eax,(%edx)
        pt0[i] |= 3;
  10256e:	8b 44 24 14          	mov    0x14(%esp),%eax
  102572:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  102579:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10257d:	01 d0                	add    %edx,%eax
  10257f:	8b 10                	mov    (%eax),%edx
  102581:	8b 44 24 14          	mov    0x14(%esp),%eax
  102585:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  10258c:	8b 44 24 0c          	mov    0xc(%esp),%eax
  102590:	01 c8                	add    %ecx,%eax
  102592:	83 ca 03             	or     $0x3,%edx
  102595:	89 10                	mov    %edx,(%eax)
        page_addr += 0x1000;
  102597:	81 44 24 18 00 10 00 	addl   $0x1000,0x18(%esp)
  10259e:	00 
    for (size_t i = 0; i < 1024; i++)
  10259f:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
  1025a4:	eb a7                	jmp    10254d <_ZN6Paging4initEv+0x6f>
    }

    init_paging((uint32_t)pd0);
  1025a6:	8b 44 24 10          	mov    0x10(%esp),%eax
  1025aa:	83 ec 0c             	sub    $0xc,%esp
  1025ad:	50                   	push   %eax
  1025ae:	e8 2d 0b 00 00       	call   1030e0 <init_paging>
  1025b3:	83 c4 10             	add    $0x10,%esp
    //    // Kernel
    //    for (uintptr_t pg = page(kernel_base+0x100000); pg < page((uintptr_t)&kernel_virtual_end); ++pg)
    //    {
    //        set_page_frame_used(pg);
    //    }
}
  1025b6:	90                   	nop
  1025b7:	83 c4 2c             	add    $0x2c,%esp
  1025ba:	c3                   	ret    

001025bb <_Z41__static_initialization_and_destruction_0ii>:
  1025bb:	83 ec 0c             	sub    $0xc,%esp
  1025be:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  1025c3:	75 2e                	jne    1025f3 <_Z41__static_initialization_and_destruction_0ii+0x38>
  1025c5:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  1025cc:	00 
  1025cd:	75 24                	jne    1025f3 <_Z41__static_initialization_and_destruction_0ii+0x38>
  1025cf:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  1025d4:	0f b6 00             	movzbl (%eax),%eax
  1025d7:	84 c0                	test   %al,%al
  1025d9:	75 18                	jne    1025f3 <_Z41__static_initialization_and_destruction_0ii+0x38>
  1025db:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  1025e0:	c6 00 01             	movb   $0x1,(%eax)
  1025e3:	83 ec 0c             	sub    $0xc,%esp
  1025e6:	68 60 53 11 00       	push   $0x115360
  1025eb:	e8 4a 0b 00 00       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  1025f0:	83 c4 10             	add    $0x10,%esp
  1025f3:	90                   	nop
  1025f4:	83 c4 0c             	add    $0xc,%esp
  1025f7:	c3                   	ret    

001025f8 <_GLOBAL__sub_I__ZN6Paging4initEv>:
  1025f8:	83 ec 0c             	sub    $0xc,%esp
  1025fb:	83 ec 08             	sub    $0x8,%esp
  1025fe:	68 ff ff 00 00       	push   $0xffff
  102603:	6a 01                	push   $0x1
  102605:	e8 b1 ff ff ff       	call   1025bb <_Z41__static_initialization_and_destruction_0ii>
  10260a:	83 c4 10             	add    $0x10,%esp
  10260d:	83 c4 0c             	add    $0xc,%esp
  102610:	c3                   	ret    
  102611:	90                   	nop

00102612 <_ZL20dmi_processor_familym>:

#include "utils/stdint.h"
#include "utils/array.hpp"

static inline const char *dmi_processor_family(uint32_t type)
{
  102612:	57                   	push   %edi
  102613:	56                   	push   %esi
  102614:	53                   	push   %ebx
  102615:	81 ec b0 06 00 00    	sub    $0x6b0,%esp
        struct {
                int value;
                const char *name;
        } family2[] = {
  10261b:	8d 44 24 14          	lea    0x14(%esp),%eax
  10261f:	bb c0 92 10 00       	mov    $0x1092c0,%ebx
  102624:	ba a4 01 00 00       	mov    $0x1a4,%edx
  102629:	89 c7                	mov    %eax,%edi
  10262b:	89 de                	mov    %ebx,%esi
  10262d:	89 d1                	mov    %edx,%ecx
  10262f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
                { 0x140, "WinChip" },
                { 0x15E, "DSP" },
                { 0x1F4, "Video Processor" },
        };

        for (auto [val, name] : family2)
  102631:	8d 44 24 14          	lea    0x14(%esp),%eax
  102635:	89 84 24 a8 06 00 00 	mov    %eax,0x6a8(%esp)
  10263c:	8b 84 24 a8 06 00 00 	mov    0x6a8(%esp),%eax
  102643:	89 84 24 ac 06 00 00 	mov    %eax,0x6ac(%esp)
  10264a:	8b 84 24 a8 06 00 00 	mov    0x6a8(%esp),%eax
  102651:	05 90 06 00 00       	add    $0x690,%eax
  102656:	89 84 24 a4 06 00 00 	mov    %eax,0x6a4(%esp)
  10265d:	8b 84 24 ac 06 00 00 	mov    0x6ac(%esp),%eax
  102664:	3b 84 24 a4 06 00 00 	cmp    0x6a4(%esp),%eax
  10266b:	74 31                	je     10269e <_ZL20dmi_processor_familym+0x8c>
  10266d:	8b 84 24 ac 06 00 00 	mov    0x6ac(%esp),%eax
  102674:	8b 50 04             	mov    0x4(%eax),%edx
  102677:	8b 00                	mov    (%eax),%eax
  102679:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10267d:	89 54 24 10          	mov    %edx,0x10(%esp)
  102681:	8b 44 24 0c          	mov    0xc(%esp),%eax
        {
            if (type == val)
  102685:	39 84 24 c0 06 00 00 	cmp    %eax,0x6c0(%esp)
  10268c:	75 06                	jne    102694 <_ZL20dmi_processor_familym+0x82>
            {
                return name;
  10268e:	8b 44 24 10          	mov    0x10(%esp),%eax
  102692:	eb 0f                	jmp    1026a3 <_ZL20dmi_processor_familym+0x91>
        for (auto [val, name] : family2)
  102694:	83 84 24 ac 06 00 00 	addl   $0x8,0x6ac(%esp)
  10269b:	08 
  10269c:	eb bf                	jmp    10265d <_ZL20dmi_processor_familym+0x4b>
            }
        }

        return "Unknown";
  10269e:	b8 0a 89 10 00       	mov    $0x10890a,%eax
}
  1026a3:	81 c4 b0 06 00 00    	add    $0x6b0,%esp
  1026a9:	5b                   	pop    %ebx
  1026aa:	5e                   	pop    %esi
  1026ab:	5f                   	pop    %edi
  1026ac:	c3                   	ret    
  1026ad:	90                   	nop

001026ae <_ZN6SMBIOS6locateEv>:
#include "utils/addr.hpp"
#include "utils/bitops.hpp"
#include "panic.hpp"

SMBIOSEntryPoint *SMBIOS::locate()
{
  1026ae:	83 ec 1c             	sub    $0x1c,%esp
    uint8_t *mem = (uint8_t*)phys(0xF0000);
  1026b1:	83 ec 0c             	sub    $0xc,%esp
  1026b4:	68 00 00 0f 00       	push   $0xf0000
  1026b9:	e8 81 4f 00 00       	call   10763f <_Z4physm>
  1026be:	83 c4 10             	add    $0x10,%esp
  1026c1:	89 44 24 0c          	mov    %eax,0xc(%esp)
    int length, i;
    uint8_t checksum;
    while ((unsigned int) mem < phys(0x100000))
  1026c5:	83 ec 0c             	sub    $0xc,%esp
  1026c8:	68 00 00 10 00       	push   $0x100000
  1026cd:	e8 6d 4f 00 00       	call   10763f <_Z4physm>
  1026d2:	83 c4 10             	add    $0x10,%esp
  1026d5:	89 c2                	mov    %eax,%edx
  1026d7:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1026db:	39 c2                	cmp    %eax,%edx
  1026dd:	0f 97 c0             	seta   %al
  1026e0:	84 c0                	test   %al,%al
  1026e2:	0f 84 85 00 00 00    	je     10276d <_ZN6SMBIOS6locateEv+0xbf>
    {
        if (mem[0] == '_' && mem[1] == 'S' && mem[2] == 'M' && mem[3] == '_') {
  1026e8:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1026ec:	0f b6 00             	movzbl (%eax),%eax
  1026ef:	3c 5f                	cmp    $0x5f,%al
  1026f1:	75 6f                	jne    102762 <_ZN6SMBIOS6locateEv+0xb4>
  1026f3:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1026f7:	83 c0 01             	add    $0x1,%eax
  1026fa:	0f b6 00             	movzbl (%eax),%eax
  1026fd:	3c 53                	cmp    $0x53,%al
  1026ff:	75 61                	jne    102762 <_ZN6SMBIOS6locateEv+0xb4>
  102701:	8b 44 24 0c          	mov    0xc(%esp),%eax
  102705:	83 c0 02             	add    $0x2,%eax
  102708:	0f b6 00             	movzbl (%eax),%eax
  10270b:	3c 4d                	cmp    $0x4d,%al
  10270d:	75 53                	jne    102762 <_ZN6SMBIOS6locateEv+0xb4>
  10270f:	8b 44 24 0c          	mov    0xc(%esp),%eax
  102713:	83 c0 03             	add    $0x3,%eax
  102716:	0f b6 00             	movzbl (%eax),%eax
  102719:	3c 5f                	cmp    $0x5f,%al
  10271b:	75 45                	jne    102762 <_ZN6SMBIOS6locateEv+0xb4>
            length = mem[5];
  10271d:	8b 44 24 0c          	mov    0xc(%esp),%eax
  102721:	83 c0 05             	add    $0x5,%eax
  102724:	0f b6 00             	movzbl (%eax),%eax
  102727:	0f b6 c0             	movzbl %al,%eax
  10272a:	89 04 24             	mov    %eax,(%esp)
            checksum = 0;
  10272d:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)
            for(i = 0; i < length; i++) {
  102732:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102739:	00 
  10273a:	8b 44 24 08          	mov    0x8(%esp),%eax
  10273e:	3b 04 24             	cmp    (%esp),%eax
  102741:	7d 18                	jge    10275b <_ZN6SMBIOS6locateEv+0xad>
                checksum += mem[i];
  102743:	8b 54 24 08          	mov    0x8(%esp),%edx
  102747:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10274b:	01 d0                	add    %edx,%eax
  10274d:	0f b6 00             	movzbl (%eax),%eax
  102750:	00 44 24 07          	add    %al,0x7(%esp)
            for(i = 0; i < length; i++) {
  102754:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
  102759:	eb df                	jmp    10273a <_ZN6SMBIOS6locateEv+0x8c>
            }
            if(checksum == 0) break;
  10275b:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
  102760:	74 0a                	je     10276c <_ZN6SMBIOS6locateEv+0xbe>
        }
        mem += 16;
  102762:	83 44 24 0c 10       	addl   $0x10,0xc(%esp)
    while ((unsigned int) mem < phys(0x100000))
  102767:	e9 59 ff ff ff       	jmp    1026c5 <_ZN6SMBIOS6locateEv+0x17>
            if(checksum == 0) break;
  10276c:	90                   	nop
    }
    if ((uintptr_t)mem == phys(0x100000))
  10276d:	83 ec 0c             	sub    $0xc,%esp
  102770:	68 00 00 10 00       	push   $0x100000
  102775:	e8 c5 4e 00 00       	call   10763f <_Z4physm>
  10277a:	83 c4 10             	add    $0x10,%esp
  10277d:	89 c2                	mov    %eax,%edx
  10277f:	8b 44 24 0c          	mov    0xc(%esp),%eax
  102783:	39 c2                	cmp    %eax,%edx
  102785:	0f 94 c0             	sete   %al
  102788:	84 c0                	test   %al,%al
  10278a:	74 17                	je     1027a3 <_ZN6SMBIOS6locateEv+0xf5>
    {
        warn("SMBIOS not found !\n");
  10278c:	83 ec 0c             	sub    $0xc,%esp
  10278f:	68 50 99 10 00       	push   $0x109950
  102794:	e8 3d 4f 00 00       	call   1076d6 <_Z4warnPKcz>
  102799:	83 c4 10             	add    $0x10,%esp
        return nullptr;
  10279c:	b8 00 00 00 00       	mov    $0x0,%eax
  1027a1:	eb 76                	jmp    102819 <_ZN6SMBIOS6locateEv+0x16b>
    }
    else
    {
        log("SMBIOS found at : %p\n", virt((uintptr_t)mem));
  1027a3:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1027a7:	83 ec 0c             	sub    $0xc,%esp
  1027aa:	50                   	push   %eax
  1027ab:	e8 94 4e 00 00       	call   107644 <_Z4virtm>
  1027b0:	83 c4 10             	add    $0x10,%esp
  1027b3:	83 ec 08             	sub    $0x8,%esp
  1027b6:	50                   	push   %eax
  1027b7:	68 64 99 10 00       	push   $0x109964
  1027bc:	e8 67 4c 00 00       	call   107428 <_Z3logPKcz>
  1027c1:	83 c4 10             	add    $0x10,%esp
        entry_point =  (SMBIOSEntryPoint*)mem;
  1027c4:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1027c8:	a3 d0 ef 11 00       	mov    %eax,0x11efd0
        log(" SMBIOS version : %d.%d\n", entry_point->MajorVersion, entry_point->MinorVersion);
  1027cd:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
  1027d2:	0f b6 40 07          	movzbl 0x7(%eax),%eax
  1027d6:	0f b6 d0             	movzbl %al,%edx
  1027d9:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
  1027de:	0f b6 40 06          	movzbl 0x6(%eax),%eax
  1027e2:	0f b6 c0             	movzbl %al,%eax
  1027e5:	83 ec 04             	sub    $0x4,%esp
  1027e8:	52                   	push   %edx
  1027e9:	50                   	push   %eax
  1027ea:	68 7a 99 10 00       	push   $0x10997a
  1027ef:	e8 34 4c 00 00       	call   107428 <_Z3logPKcz>
  1027f4:	83 c4 10             	add    $0x10,%esp
        log(" SMBIOS entries : %d\n", entry_point->NumberOfStructures);
  1027f7:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
  1027fc:	0f b7 40 1c          	movzwl 0x1c(%eax),%eax
  102800:	0f b7 c0             	movzwl %ax,%eax
  102803:	83 ec 08             	sub    $0x8,%esp
  102806:	50                   	push   %eax
  102807:	68 93 99 10 00       	push   $0x109993
  10280c:	e8 17 4c 00 00       	call   107428 <_Z3logPKcz>
  102811:	83 c4 10             	add    $0x10,%esp
        return entry_point;
  102814:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
    }
}
  102819:	83 c4 1c             	add    $0x1c,%esp
  10281c:	c3                   	ret    
  10281d:	90                   	nop

0010281e <_ZN6SMBIOS9bios_infoEv>:

SMBIOSBIOSInfo* SMBIOS::bios_info()
{
  10281e:	83 ec 1c             	sub    $0x1c,%esp
    if (entry_point)
  102821:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
  102826:	85 c0                	test   %eax,%eax
  102828:	0f 84 53 01 00 00    	je     102981 <_ZN6SMBIOS9bios_infoEv+0x163>
    {
        uintptr_t mem = phys(entry_point->TableAddress);
  10282e:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
  102833:	8b 40 18             	mov    0x18(%eax),%eax
  102836:	83 ec 0c             	sub    $0xc,%esp
  102839:	50                   	push   %eax
  10283a:	e8 00 4e 00 00       	call   10763f <_Z4physm>
  10283f:	83 c4 10             	add    $0x10,%esp
  102842:	89 44 24 0c          	mov    %eax,0xc(%esp)
        while (mem < phys(entry_point->TableAddress) + entry_point->TableLength)
  102846:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
  10284b:	8b 40 18             	mov    0x18(%eax),%eax
  10284e:	83 ec 0c             	sub    $0xc,%esp
  102851:	50                   	push   %eax
  102852:	e8 e8 4d 00 00       	call   10763f <_Z4physm>
  102857:	83 c4 10             	add    $0x10,%esp
  10285a:	89 c2                	mov    %eax,%edx
  10285c:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
  102861:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  102865:	0f b7 c0             	movzwl %ax,%eax
  102868:	01 d0                	add    %edx,%eax
  10286a:	39 44 24 0c          	cmp    %eax,0xc(%esp)
  10286e:	0f 92 c0             	setb   %al
  102871:	84 c0                	test   %al,%al
  102873:	0f 84 01 01 00 00    	je     10297a <_ZN6SMBIOS9bios_infoEv+0x15c>
        {
            auto* tag = (SMBIOSTag*)mem;
  102879:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10287d:	89 44 24 08          	mov    %eax,0x8(%esp)
            if (tag->type == 127)
  102881:	8b 44 24 08          	mov    0x8(%esp),%eax
  102885:	0f b6 00             	movzbl (%eax),%eax
  102888:	3c 7f                	cmp    $0x7f,%al
  10288a:	0f 84 e9 00 00 00    	je     102979 <_ZN6SMBIOS9bios_infoEv+0x15b>
            {
                break;
            }
            if (tag->type == 0)
  102890:	8b 44 24 08          	mov    0x8(%esp),%eax
  102894:	0f b6 00             	movzbl (%eax),%eax
  102897:	84 c0                	test   %al,%al
  102899:	0f 85 a9 00 00 00    	jne    102948 <_ZN6SMBIOS9bios_infoEv+0x12a>
            {
                SMBIOSBIOSInfo* info = (SMBIOSBIOSInfo*)mem;
  10289f:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1028a3:	89 44 24 04          	mov    %eax,0x4(%esp)

                uint8_t* tag_end = (uint8_t*)(mem + tag->length - 1);
  1028a7:	8b 44 24 08          	mov    0x8(%esp),%eax
  1028ab:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  1028af:	0f b6 d0             	movzbl %al,%edx
  1028b2:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1028b6:	01 d0                	add    %edx,%eax
  1028b8:	83 e8 01             	sub    $0x1,%eax
  1028bb:	89 04 24             	mov    %eax,(%esp)

                log(" BIOS Vendor : %s\n", get_string(tag_end, info->vendor));
  1028be:	8b 44 24 04          	mov    0x4(%esp),%eax
  1028c2:	0f b6 40 04          	movzbl 0x4(%eax),%eax
  1028c6:	0f b6 c0             	movzbl %al,%eax
  1028c9:	83 ec 08             	sub    $0x8,%esp
  1028cc:	50                   	push   %eax
  1028cd:	ff 74 24 0c          	pushl  0xc(%esp)
  1028d1:	e8 c4 03 00 00       	call   102c9a <_ZN6SMBIOS10get_stringEPhh>
  1028d6:	83 c4 10             	add    $0x10,%esp
  1028d9:	83 ec 08             	sub    $0x8,%esp
  1028dc:	50                   	push   %eax
  1028dd:	68 a9 99 10 00       	push   $0x1099a9
  1028e2:	e8 41 4b 00 00       	call   107428 <_Z3logPKcz>
  1028e7:	83 c4 10             	add    $0x10,%esp
                log(" BIOS Version : %s\n",get_string(tag_end, info->version));
  1028ea:	8b 44 24 04          	mov    0x4(%esp),%eax
  1028ee:	0f b6 40 05          	movzbl 0x5(%eax),%eax
  1028f2:	0f b6 c0             	movzbl %al,%eax
  1028f5:	83 ec 08             	sub    $0x8,%esp
  1028f8:	50                   	push   %eax
  1028f9:	ff 74 24 0c          	pushl  0xc(%esp)
  1028fd:	e8 98 03 00 00       	call   102c9a <_ZN6SMBIOS10get_stringEPhh>
  102902:	83 c4 10             	add    $0x10,%esp
  102905:	83 ec 08             	sub    $0x8,%esp
  102908:	50                   	push   %eax
  102909:	68 bc 99 10 00       	push   $0x1099bc
  10290e:	e8 15 4b 00 00       	call   107428 <_Z3logPKcz>
  102913:	83 c4 10             	add    $0x10,%esp
                log(" BIOS Release date : %s\n", get_string(tag_end, info->release_date));
  102916:	8b 44 24 04          	mov    0x4(%esp),%eax
  10291a:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  10291e:	0f b6 c0             	movzbl %al,%eax
  102921:	83 ec 08             	sub    $0x8,%esp
  102924:	50                   	push   %eax
  102925:	ff 74 24 0c          	pushl  0xc(%esp)
  102929:	e8 6c 03 00 00       	call   102c9a <_ZN6SMBIOS10get_stringEPhh>
  10292e:	83 c4 10             	add    $0x10,%esp
  102931:	83 ec 08             	sub    $0x8,%esp
  102934:	50                   	push   %eax
  102935:	68 d0 99 10 00       	push   $0x1099d0
  10293a:	e8 e9 4a 00 00       	call   107428 <_Z3logPKcz>
  10293f:	83 c4 10             	add    $0x10,%esp

                return info;
  102942:	8b 44 24 04          	mov    0x4(%esp),%eax
  102946:	eb 46                	jmp    10298e <_ZN6SMBIOS9bios_infoEv+0x170>
            }

            mem += tag->length - 1;
  102948:	8b 44 24 08          	mov    0x8(%esp),%eax
  10294c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  102950:	0f b6 d0             	movzbl %al,%edx
  102953:	8b 44 24 0c          	mov    0xc(%esp),%eax
  102957:	01 d0                	add    %edx,%eax
  102959:	83 e8 01             	sub    $0x1,%eax
  10295c:	89 44 24 0c          	mov    %eax,0xc(%esp)
            mem = find_strings_end((uint8_t*)mem);
  102960:	8b 44 24 0c          	mov    0xc(%esp),%eax
  102964:	83 ec 0c             	sub    $0xc,%esp
  102967:	50                   	push   %eax
  102968:	e8 85 03 00 00       	call   102cf2 <_ZN6SMBIOS16find_strings_endEPh>
  10296d:	83 c4 10             	add    $0x10,%esp
  102970:	89 44 24 0c          	mov    %eax,0xc(%esp)
        while (mem < phys(entry_point->TableAddress) + entry_point->TableLength)
  102974:	e9 cd fe ff ff       	jmp    102846 <_ZN6SMBIOS9bios_infoEv+0x28>
                break;
  102979:	90                   	nop
        }

        return nullptr;
  10297a:	b8 00 00 00 00       	mov    $0x0,%eax
  10297f:	eb 0d                	jmp    10298e <_ZN6SMBIOS9bios_infoEv+0x170>
    }
    else
    {
        panic("Tried to access inexistent SMBIOS !");
  102981:	83 ec 0c             	sub    $0xc,%esp
  102984:	68 ec 99 10 00       	push   $0x1099ec
  102989:	e8 74 20 00 00       	call   104a02 <_Z5panicPKcz>
    }
}
  10298e:	83 c4 1c             	add    $0x1c,%esp
  102991:	c3                   	ret    

00102992 <_ZN6SMBIOS8cpu_infoEv>:

SMBIOSCPUInfo *SMBIOS::cpu_info()
{
  102992:	83 ec 2c             	sub    $0x2c,%esp
    if (entry_point)
  102995:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
  10299a:	85 c0                	test   %eax,%eax
  10299c:	0f 84 e7 02 00 00    	je     102c89 <_ZN6SMBIOS8cpu_infoEv+0x2f7>
    {
        uintptr_t mem = phys(entry_point->TableAddress);
  1029a2:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
  1029a7:	8b 40 18             	mov    0x18(%eax),%eax
  1029aa:	83 ec 0c             	sub    $0xc,%esp
  1029ad:	50                   	push   %eax
  1029ae:	e8 8c 4c 00 00       	call   10763f <_Z4physm>
  1029b3:	83 c4 10             	add    $0x10,%esp
  1029b6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
        while (mem < phys(entry_point->TableAddress) + entry_point->TableLength)
  1029ba:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
  1029bf:	8b 40 18             	mov    0x18(%eax),%eax
  1029c2:	83 ec 0c             	sub    $0xc,%esp
  1029c5:	50                   	push   %eax
  1029c6:	e8 74 4c 00 00       	call   10763f <_Z4physm>
  1029cb:	83 c4 10             	add    $0x10,%esp
  1029ce:	89 c2                	mov    %eax,%edx
  1029d0:	a1 d0 ef 11 00       	mov    0x11efd0,%eax
  1029d5:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  1029d9:	0f b7 c0             	movzwl %ax,%eax
  1029dc:	01 d0                	add    %edx,%eax
  1029de:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
  1029e2:	0f 92 c0             	setb   %al
  1029e5:	84 c0                	test   %al,%al
  1029e7:	0f 84 95 02 00 00    	je     102c82 <_ZN6SMBIOS8cpu_infoEv+0x2f0>
        {
            auto* tag = (SMBIOSTag*)mem;
  1029ed:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1029f1:	89 44 24 18          	mov    %eax,0x18(%esp)
            if (tag->type == 127)
  1029f5:	8b 44 24 18          	mov    0x18(%esp),%eax
  1029f9:	0f b6 00             	movzbl (%eax),%eax
  1029fc:	3c 7f                	cmp    $0x7f,%al
  1029fe:	0f 84 7d 02 00 00    	je     102c81 <_ZN6SMBIOS8cpu_infoEv+0x2ef>
            {
                break;
            }
            if (tag->type == 4)
  102a04:	8b 44 24 18          	mov    0x18(%esp),%eax
  102a08:	0f b6 00             	movzbl (%eax),%eax
  102a0b:	3c 04                	cmp    $0x4,%al
  102a0d:	0f 85 3d 02 00 00    	jne    102c50 <_ZN6SMBIOS8cpu_infoEv+0x2be>
            {
                SMBIOSCPUInfo* info = (SMBIOSCPUInfo*)mem;
  102a13:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  102a17:	89 44 24 14          	mov    %eax,0x14(%esp)

                uint8_t* tag_end = (uint8_t*)(mem + tag->length - 1);
  102a1b:	8b 44 24 18          	mov    0x18(%esp),%eax
  102a1f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  102a23:	0f b6 d0             	movzbl %al,%edx
  102a26:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  102a2a:	01 d0                	add    %edx,%eax
  102a2c:	83 e8 01             	sub    $0x1,%eax
  102a2f:	89 44 24 10          	mov    %eax,0x10(%esp)

                log(" Processor Type : ");
  102a33:	83 ec 0c             	sub    $0xc,%esp
  102a36:	68 10 9a 10 00       	push   $0x109a10
  102a3b:	e8 e8 49 00 00       	call   107428 <_Z3logPKcz>
  102a40:	83 c4 10             	add    $0x10,%esp
                switch (info->cpu_type)
  102a43:	8b 44 24 14          	mov    0x14(%esp),%eax
  102a47:	0f b6 40 05          	movzbl 0x5(%eax),%eax
  102a4b:	0f b6 c0             	movzbl %al,%eax
  102a4e:	83 f8 04             	cmp    $0x4,%eax
  102a51:	74 3a                	je     102a8d <_ZN6SMBIOS8cpu_infoEv+0xfb>
  102a53:	83 f8 04             	cmp    $0x4,%eax
  102a56:	7f 07                	jg     102a5f <_ZN6SMBIOS8cpu_infoEv+0xcd>
  102a58:	83 f8 03             	cmp    $0x3,%eax
  102a5b:	74 1e                	je     102a7b <_ZN6SMBIOS8cpu_infoEv+0xe9>
  102a5d:	eb 0a                	jmp    102a69 <_ZN6SMBIOS8cpu_infoEv+0xd7>
  102a5f:	83 f8 05             	cmp    $0x5,%eax
  102a62:	74 3b                	je     102a9f <_ZN6SMBIOS8cpu_infoEv+0x10d>
  102a64:	83 f8 06             	cmp    $0x6,%eax
  102a67:	74 48                	je     102ab1 <_ZN6SMBIOS8cpu_infoEv+0x11f>
                {
                case 0:
                case 1:
                case 2:
                default:
                    printf("Unknown\n");
  102a69:	83 ec 0c             	sub    $0xc,%esp
  102a6c:	68 23 9a 10 00       	push   $0x109a23
  102a71:	e8 5c 3e 00 00       	call   1068d2 <tfp_printf>
  102a76:	83 c4 10             	add    $0x10,%esp
                    break;
  102a79:	eb 47                	jmp    102ac2 <_ZN6SMBIOS8cpu_infoEv+0x130>
                case 3:
                    printf("CPU\n");
  102a7b:	83 ec 0c             	sub    $0xc,%esp
  102a7e:	68 2c 9a 10 00       	push   $0x109a2c
  102a83:	e8 4a 3e 00 00       	call   1068d2 <tfp_printf>
  102a88:	83 c4 10             	add    $0x10,%esp
                    break;
  102a8b:	eb 35                	jmp    102ac2 <_ZN6SMBIOS8cpu_infoEv+0x130>
                case 4:
                    printf("Math processor\n");
  102a8d:	83 ec 0c             	sub    $0xc,%esp
  102a90:	68 31 9a 10 00       	push   $0x109a31
  102a95:	e8 38 3e 00 00       	call   1068d2 <tfp_printf>
  102a9a:	83 c4 10             	add    $0x10,%esp
                    break;
  102a9d:	eb 23                	jmp    102ac2 <_ZN6SMBIOS8cpu_infoEv+0x130>
                case 5:
                    printf("DSP processor\n");
  102a9f:	83 ec 0c             	sub    $0xc,%esp
  102aa2:	68 41 9a 10 00       	push   $0x109a41
  102aa7:	e8 26 3e 00 00       	call   1068d2 <tfp_printf>
  102aac:	83 c4 10             	add    $0x10,%esp
                    break;
  102aaf:	eb 11                	jmp    102ac2 <_ZN6SMBIOS8cpu_infoEv+0x130>
                case 6:
                    printf("Video processor\n");
  102ab1:	83 ec 0c             	sub    $0xc,%esp
  102ab4:	68 50 9a 10 00       	push   $0x109a50
  102ab9:	e8 14 3e 00 00       	call   1068d2 <tfp_printf>
  102abe:	83 c4 10             	add    $0x10,%esp
                    break;
  102ac1:	90                   	nop
                }

                log(" Processor family : %s\n", dmi_processor_family(info->family));
  102ac2:	8b 44 24 14          	mov    0x14(%esp),%eax
  102ac6:	0f b6 40 06          	movzbl 0x6(%eax),%eax
  102aca:	0f b6 c0             	movzbl %al,%eax
  102acd:	83 ec 0c             	sub    $0xc,%esp
  102ad0:	50                   	push   %eax
  102ad1:	e8 3c fb ff ff       	call   102612 <_ZL20dmi_processor_familym>
  102ad6:	83 c4 10             	add    $0x10,%esp
  102ad9:	83 ec 08             	sub    $0x8,%esp
  102adc:	50                   	push   %eax
  102add:	68 61 9a 10 00       	push   $0x109a61
  102ae2:	e8 41 49 00 00       	call   107428 <_Z3logPKcz>
  102ae7:	83 c4 10             	add    $0x10,%esp
                log(" Processor socket : %s\n", get_string(tag_end, info->socket+1));
  102aea:	8b 44 24 14          	mov    0x14(%esp),%eax
  102aee:	0f b6 40 04          	movzbl 0x4(%eax),%eax
  102af2:	83 c0 01             	add    $0x1,%eax
  102af5:	0f b6 c0             	movzbl %al,%eax
  102af8:	83 ec 08             	sub    $0x8,%esp
  102afb:	50                   	push   %eax
  102afc:	ff 74 24 1c          	pushl  0x1c(%esp)
  102b00:	e8 95 01 00 00       	call   102c9a <_ZN6SMBIOS10get_stringEPhh>
  102b05:	83 c4 10             	add    $0x10,%esp
  102b08:	83 ec 08             	sub    $0x8,%esp
  102b0b:	50                   	push   %eax
  102b0c:	68 79 9a 10 00       	push   $0x109a79
  102b11:	e8 12 49 00 00       	call   107428 <_Z3logPKcz>
  102b16:	83 c4 10             	add    $0x10,%esp
                log(" Processor manufacturer : %s\n", get_string(tag_end, info->manufacturer+1));
  102b19:	8b 44 24 14          	mov    0x14(%esp),%eax
  102b1d:	0f b6 40 07          	movzbl 0x7(%eax),%eax
  102b21:	83 c0 01             	add    $0x1,%eax
  102b24:	0f b6 c0             	movzbl %al,%eax
  102b27:	83 ec 08             	sub    $0x8,%esp
  102b2a:	50                   	push   %eax
  102b2b:	ff 74 24 1c          	pushl  0x1c(%esp)
  102b2f:	e8 66 01 00 00       	call   102c9a <_ZN6SMBIOS10get_stringEPhh>
  102b34:	83 c4 10             	add    $0x10,%esp
  102b37:	83 ec 08             	sub    $0x8,%esp
  102b3a:	50                   	push   %eax
  102b3b:	68 91 9a 10 00       	push   $0x109a91
  102b40:	e8 e3 48 00 00       	call   107428 <_Z3logPKcz>
  102b45:	83 c4 10             	add    $0x10,%esp
                log(" Processor version : %s\n", get_string(tag_end, info->version+1));
  102b48:	8b 44 24 14          	mov    0x14(%esp),%eax
  102b4c:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  102b50:	83 c0 01             	add    $0x1,%eax
  102b53:	0f b6 c0             	movzbl %al,%eax
  102b56:	83 ec 08             	sub    $0x8,%esp
  102b59:	50                   	push   %eax
  102b5a:	ff 74 24 1c          	pushl  0x1c(%esp)
  102b5e:	e8 37 01 00 00       	call   102c9a <_ZN6SMBIOS10get_stringEPhh>
  102b63:	83 c4 10             	add    $0x10,%esp
  102b66:	83 ec 08             	sub    $0x8,%esp
  102b69:	50                   	push   %eax
  102b6a:	68 af 9a 10 00       	push   $0x109aaf
  102b6f:	e8 b4 48 00 00       	call   107428 <_Z3logPKcz>
  102b74:	83 c4 10             	add    $0x10,%esp
                log(" Processor voltage : ");
  102b77:	83 ec 0c             	sub    $0xc,%esp
  102b7a:	68 c8 9a 10 00       	push   $0x109ac8
  102b7f:	e8 a4 48 00 00       	call   107428 <_Z3logPKcz>
  102b84:	83 c4 10             	add    $0x10,%esp
                if (bit_check(info->voltage, 7))
  102b87:	8b 44 24 14          	mov    0x14(%esp),%eax
  102b8b:	83 c0 11             	add    $0x11,%eax
  102b8e:	83 ec 08             	sub    $0x8,%esp
  102b91:	6a 07                	push   $0x7
  102b93:	50                   	push   %eax
  102b94:	e8 a1 4b 00 00       	call   10773a <_Z9bit_checkIhEbRT_m>
  102b99:	83 c4 10             	add    $0x10,%esp
  102b9c:	84 c0                	test   %al,%al
  102b9e:	74 37                	je     102bd7 <_ZN6SMBIOS8cpu_infoEv+0x245>
                {
                    printf("%.1fv\n", (info->voltage & 0b1111111)/10.0);
  102ba0:	8b 44 24 14          	mov    0x14(%esp),%eax
  102ba4:	0f b6 40 11          	movzbl 0x11(%eax),%eax
  102ba8:	0f b6 c0             	movzbl %al,%eax
  102bab:	83 e0 7f             	and    $0x7f,%eax
  102bae:	89 44 24 0c          	mov    %eax,0xc(%esp)
  102bb2:	db 44 24 0c          	fildl  0xc(%esp)
  102bb6:	dd 05 00 9b 10 00    	fldl   0x109b00
  102bbc:	de f9                	fdivrp %st,%st(1)
  102bbe:	83 ec 04             	sub    $0x4,%esp
  102bc1:	8d 64 24 f8          	lea    -0x8(%esp),%esp
  102bc5:	dd 1c 24             	fstpl  (%esp)
  102bc8:	68 de 9a 10 00       	push   $0x109ade
  102bcd:	e8 00 3d 00 00       	call   1068d2 <tfp_printf>
  102bd2:	83 c4 10             	add    $0x10,%esp
  102bd5:	eb 57                	jmp    102c2e <_ZN6SMBIOS8cpu_infoEv+0x29c>
                }
                else
                {
                    printf("%.1fv\n", info->voltage == 0 ? 5 : info->voltage == 1 ? 3.3 : info->voltage == 2 ? 2.9 : -1);
  102bd7:	8b 44 24 14          	mov    0x14(%esp),%eax
  102bdb:	0f b6 40 11          	movzbl 0x11(%eax),%eax
  102bdf:	84 c0                	test   %al,%al
  102be1:	74 2e                	je     102c11 <_ZN6SMBIOS8cpu_infoEv+0x27f>
  102be3:	8b 44 24 14          	mov    0x14(%esp),%eax
  102be7:	0f b6 40 11          	movzbl 0x11(%eax),%eax
  102beb:	3c 01                	cmp    $0x1,%al
  102bed:	74 1a                	je     102c09 <_ZN6SMBIOS8cpu_infoEv+0x277>
  102bef:	8b 44 24 14          	mov    0x14(%esp),%eax
  102bf3:	0f b6 40 11          	movzbl 0x11(%eax),%eax
  102bf7:	3c 02                	cmp    $0x2,%al
  102bf9:	75 08                	jne    102c03 <_ZN6SMBIOS8cpu_infoEv+0x271>
  102bfb:	dd 05 08 9b 10 00    	fldl   0x109b08
  102c01:	eb 14                	jmp    102c17 <_ZN6SMBIOS8cpu_infoEv+0x285>
  102c03:	d9 e8                	fld1   
  102c05:	d9 e0                	fchs   
  102c07:	eb 0e                	jmp    102c17 <_ZN6SMBIOS8cpu_infoEv+0x285>
  102c09:	dd 05 10 9b 10 00    	fldl   0x109b10
  102c0f:	eb 06                	jmp    102c17 <_ZN6SMBIOS8cpu_infoEv+0x285>
  102c11:	dd 05 18 9b 10 00    	fldl   0x109b18
  102c17:	83 ec 04             	sub    $0x4,%esp
  102c1a:	8d 64 24 f8          	lea    -0x8(%esp),%esp
  102c1e:	dd 1c 24             	fstpl  (%esp)
  102c21:	68 de 9a 10 00       	push   $0x109ade
  102c26:	e8 a7 3c 00 00       	call   1068d2 <tfp_printf>
  102c2b:	83 c4 10             	add    $0x10,%esp
                }

                log(" Processor speed : %dMHz\n", info->curr_speed);
  102c2e:	8b 44 24 14          	mov    0x14(%esp),%eax
  102c32:	0f b7 40 16          	movzwl 0x16(%eax),%eax
  102c36:	0f b7 c0             	movzwl %ax,%eax
  102c39:	83 ec 08             	sub    $0x8,%esp
  102c3c:	50                   	push   %eax
  102c3d:	68 e5 9a 10 00       	push   $0x109ae5
  102c42:	e8 e1 47 00 00       	call   107428 <_Z3logPKcz>
  102c47:	83 c4 10             	add    $0x10,%esp

                return info;
  102c4a:	8b 44 24 14          	mov    0x14(%esp),%eax
  102c4e:	eb 46                	jmp    102c96 <_ZN6SMBIOS8cpu_infoEv+0x304>
            }

            mem += tag->length - 1;
  102c50:	8b 44 24 18          	mov    0x18(%esp),%eax
  102c54:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  102c58:	0f b6 d0             	movzbl %al,%edx
  102c5b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  102c5f:	01 d0                	add    %edx,%eax
  102c61:	83 e8 01             	sub    $0x1,%eax
  102c64:	89 44 24 1c          	mov    %eax,0x1c(%esp)
            mem = find_strings_end((uint8_t*)mem);
  102c68:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  102c6c:	83 ec 0c             	sub    $0xc,%esp
  102c6f:	50                   	push   %eax
  102c70:	e8 7d 00 00 00       	call   102cf2 <_ZN6SMBIOS16find_strings_endEPh>
  102c75:	83 c4 10             	add    $0x10,%esp
  102c78:	89 44 24 1c          	mov    %eax,0x1c(%esp)
        while (mem < phys(entry_point->TableAddress) + entry_point->TableLength)
  102c7c:	e9 39 fd ff ff       	jmp    1029ba <_ZN6SMBIOS8cpu_infoEv+0x28>
                break;
  102c81:	90                   	nop
        }

        return nullptr;
  102c82:	b8 00 00 00 00       	mov    $0x0,%eax
  102c87:	eb 0d                	jmp    102c96 <_ZN6SMBIOS8cpu_infoEv+0x304>
    }
    else
    {
        panic("Tried to access inexistent SMBIOS !");
  102c89:	83 ec 0c             	sub    $0xc,%esp
  102c8c:	68 ec 99 10 00       	push   $0x1099ec
  102c91:	e8 6c 1d 00 00       	call   104a02 <_Z5panicPKcz>
    }
}
  102c96:	83 c4 2c             	add    $0x2c,%esp
  102c99:	c3                   	ret    

00102c9a <_ZN6SMBIOS10get_stringEPhh>:

const char *SMBIOS::get_string(uint8_t *offset, uint8_t number)
{
  102c9a:	83 ec 14             	sub    $0x14,%esp
  102c9d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  102ca1:	88 04 24             	mov    %al,(%esp)
    uint8_t idx = 1;
  102ca4:	c6 44 24 13 01       	movb   $0x1,0x13(%esp)
    while (offset[0] != '\0' || offset[1] != '\0')
  102ca9:	8b 44 24 18          	mov    0x18(%esp),%eax
  102cad:	0f b6 00             	movzbl (%eax),%eax
  102cb0:	84 c0                	test   %al,%al
  102cb2:	75 0e                	jne    102cc2 <_ZN6SMBIOS10get_stringEPhh+0x28>
  102cb4:	8b 44 24 18          	mov    0x18(%esp),%eax
  102cb8:	83 c0 01             	add    $0x1,%eax
  102cbb:	0f b6 00             	movzbl (%eax),%eax
  102cbe:	84 c0                	test   %al,%al
  102cc0:	74 27                	je     102ce9 <_ZN6SMBIOS10get_stringEPhh+0x4f>
    {
        if (idx == number) { return (const char*)offset; }
  102cc2:	0f b6 44 24 13       	movzbl 0x13(%esp),%eax
  102cc7:	3a 04 24             	cmp    (%esp),%al
  102cca:	75 06                	jne    102cd2 <_ZN6SMBIOS10get_stringEPhh+0x38>
  102ccc:	8b 44 24 18          	mov    0x18(%esp),%eax
  102cd0:	eb 1c                	jmp    102cee <_ZN6SMBIOS10get_stringEPhh+0x54>

        if (offset[0] == '\0') ++idx;
  102cd2:	8b 44 24 18          	mov    0x18(%esp),%eax
  102cd6:	0f b6 00             	movzbl (%eax),%eax
  102cd9:	84 c0                	test   %al,%al
  102cdb:	75 05                	jne    102ce2 <_ZN6SMBIOS10get_stringEPhh+0x48>
  102cdd:	80 44 24 13 01       	addb   $0x1,0x13(%esp)
        ++offset;
  102ce2:	83 44 24 18 01       	addl   $0x1,0x18(%esp)
    while (offset[0] != '\0' || offset[1] != '\0')
  102ce7:	eb c0                	jmp    102ca9 <_ZN6SMBIOS10get_stringEPhh+0xf>
    }

    return nullptr;
  102ce9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  102cee:	83 c4 14             	add    $0x14,%esp
  102cf1:	c3                   	ret    

00102cf2 <_ZN6SMBIOS16find_strings_endEPh>:

uintptr_t SMBIOS::find_strings_end(uint8_t* offset)
{
    while (offset[0] != '\0' || offset[1] != '\0')
  102cf2:	8b 44 24 04          	mov    0x4(%esp),%eax
  102cf6:	0f b6 00             	movzbl (%eax),%eax
  102cf9:	84 c0                	test   %al,%al
  102cfb:	75 0e                	jne    102d0b <_ZN6SMBIOS16find_strings_endEPh+0x19>
  102cfd:	8b 44 24 04          	mov    0x4(%esp),%eax
  102d01:	83 c0 01             	add    $0x1,%eax
  102d04:	0f b6 00             	movzbl (%eax),%eax
  102d07:	84 c0                	test   %al,%al
  102d09:	74 07                	je     102d12 <_ZN6SMBIOS16find_strings_endEPh+0x20>
    {
        ++offset;
  102d0b:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
    while (offset[0] != '\0' || offset[1] != '\0')
  102d10:	eb e0                	jmp    102cf2 <_ZN6SMBIOS16find_strings_endEPh>
    }
    return ((uintptr_t)offset) + 2;
  102d12:	8b 44 24 04          	mov    0x4(%esp),%eax
  102d16:	83 c0 02             	add    $0x2,%eax
}
  102d19:	c3                   	ret    

00102d1a <_Z41__static_initialization_and_destruction_0ii>:
  102d1a:	83 ec 0c             	sub    $0xc,%esp
  102d1d:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  102d22:	75 2e                	jne    102d52 <_Z41__static_initialization_and_destruction_0ii+0x38>
  102d24:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  102d2b:	00 
  102d2c:	75 24                	jne    102d52 <_Z41__static_initialization_and_destruction_0ii+0x38>
  102d2e:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  102d33:	0f b6 00             	movzbl (%eax),%eax
  102d36:	84 c0                	test   %al,%al
  102d38:	75 18                	jne    102d52 <_Z41__static_initialization_and_destruction_0ii+0x38>
  102d3a:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  102d3f:	c6 00 01             	movb   $0x1,(%eax)
  102d42:	83 ec 0c             	sub    $0xc,%esp
  102d45:	68 60 53 11 00       	push   $0x115360
  102d4a:	e8 eb 03 00 00       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  102d4f:	83 c4 10             	add    $0x10,%esp
  102d52:	90                   	nop
  102d53:	83 c4 0c             	add    $0xc,%esp
  102d56:	c3                   	ret    

00102d57 <_GLOBAL__sub_I__ZN6SMBIOS6locateEv>:
  102d57:	83 ec 0c             	sub    $0xc,%esp
  102d5a:	83 ec 08             	sub    $0x8,%esp
  102d5d:	68 ff ff 00 00       	push   $0xffff
  102d62:	6a 01                	push   $0x1
  102d64:	e8 b1 ff ff ff       	call   102d1a <_Z41__static_initialization_and_destruction_0ii>
  102d69:	83 c4 10             	add    $0x10,%esp
  102d6c:	83 c4 0c             	add    $0xc,%esp
  102d6f:	c3                   	ret    

00102d70 <_Z6uptimev>:
#include "timestamp.hpp"

#include "cpuinfo.hpp"

double uptime()
{
  102d70:	83 ec 2c             	sub    $0x2c,%esp
    static double initial_ticks = rdtsc();
  102d73:	0f b6 05 88 0c 11 00 	movzbl 0x110c88,%eax
  102d7a:	84 c0                	test   %al,%al
  102d7c:	0f 94 c0             	sete   %al
  102d7f:	84 c0                	test   %al,%al
  102d81:	74 55                	je     102dd8 <_Z6uptimev+0x68>
  102d83:	83 ec 0c             	sub    $0xc,%esp
  102d86:	68 88 0c 11 00       	push   $0x110c88
  102d8b:	e8 1e 0b 00 00       	call   1038ae <__cxa_guard_acquire>
  102d90:	83 c4 10             	add    $0x10,%esp
  102d93:	85 c0                	test   %eax,%eax
  102d95:	0f 95 c0             	setne  %al
  102d98:	84 c0                	test   %al,%al
  102d9a:	74 3c                	je     102dd8 <_Z6uptimev+0x68>
  102d9c:	e8 b6 49 00 00       	call   107757 <_Z5rdtscv>
  102da1:	89 04 24             	mov    %eax,(%esp)
  102da4:	89 54 24 04          	mov    %edx,0x4(%esp)
  102da8:	df 2c 24             	fildll (%esp)
  102dab:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  102db0:	79 08                	jns    102dba <_Z6uptimev+0x4a>
  102db2:	db 2d 20 9b 10 00    	fldt   0x109b20
  102db8:	de c1                	faddp  %st,%st(1)
  102dba:	dd 5c 24 08          	fstpl  0x8(%esp)
  102dbe:	dd 44 24 08          	fldl   0x8(%esp)
  102dc2:	dd 1d 80 0c 11 00    	fstpl  0x110c80
  102dc8:	83 ec 0c             	sub    $0xc,%esp
  102dcb:	68 88 0c 11 00       	push   $0x110c88
  102dd0:	e8 e9 0a 00 00       	call   1038be <__cxa_guard_release>
  102dd5:	83 c4 10             	add    $0x10,%esp
    double ticks = rdtsc() - initial_ticks;
  102dd8:	e8 7a 49 00 00       	call   107757 <_Z5rdtscv>
  102ddd:	89 04 24             	mov    %eax,(%esp)
  102de0:	89 54 24 04          	mov    %edx,0x4(%esp)
  102de4:	df 2c 24             	fildll (%esp)
  102de7:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  102dec:	79 08                	jns    102df6 <_Z6uptimev+0x86>
  102dee:	db 2d 20 9b 10 00    	fldt   0x109b20
  102df4:	de c1                	faddp  %st,%st(1)
  102df6:	dd 5c 24 08          	fstpl  0x8(%esp)
  102dfa:	dd 44 24 08          	fldl   0x8(%esp)
  102dfe:	dd 05 80 0c 11 00    	fldl   0x110c80
  102e04:	de e9                	fsubrp %st,%st(1)
  102e06:	dd 5c 24 18          	fstpl  0x18(%esp)

    return ticks / (double(clock_speed()) * 1'000'000.0); // MHz -> Hz
  102e0a:	83 ec 0c             	sub    $0xc,%esp
  102e0d:	6a 00                	push   $0x0
  102e0f:	e8 68 49 00 00       	call   10777c <_Z11clock_speedb>
  102e14:	83 c4 10             	add    $0x10,%esp
  102e17:	89 04 24             	mov    %eax,(%esp)
  102e1a:	89 54 24 04          	mov    %edx,0x4(%esp)
  102e1e:	df 2c 24             	fildll (%esp)
  102e21:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  102e26:	79 08                	jns    102e30 <_Z6uptimev+0xc0>
  102e28:	db 2d 20 9b 10 00    	fldt   0x109b20
  102e2e:	de c1                	faddp  %st,%st(1)
  102e30:	dd 5c 24 08          	fstpl  0x8(%esp)
  102e34:	dd 44 24 08          	fldl   0x8(%esp)
  102e38:	dd 05 30 9b 10 00    	fldl   0x109b30
  102e3e:	de c9                	fmulp  %st,%st(1)
  102e40:	dd 44 24 18          	fldl   0x18(%esp)
  102e44:	de f1                	fdivp  %st,%st(1)
}
  102e46:	83 c4 2c             	add    $0x2c,%esp
  102e49:	c3                   	ret    
  102e4a:	66 90                	xchg   %ax,%ax
  102e4c:	66 90                	xchg   %ax,%ax
  102e4e:	66 90                	xchg   %ax,%ax

00102e50 <_start>:
  102e50:	bc 10 4d 11 00       	mov    $0x114d10,%esp
  102e55:	a3 08 0d 11 00       	mov    %eax,0x110d08
  102e5a:	89 1d 0c 0d 11 00    	mov    %ebx,0x110d0c
  102e60:	bb 00 80 10 00       	mov    $0x108000,%ebx
  102e65:	eb 05                	jmp    102e6c <higher_half_start.ctors_until_end>

00102e67 <higher_half_start.call_constructor>:
  102e67:	ff 13                	call   *(%ebx)
  102e69:	83 c3 04             	add    $0x4,%ebx

00102e6c <higher_half_start.ctors_until_end>:
  102e6c:	81 fb 34 80 10 00    	cmp    $0x108034,%ebx
  102e72:	72 f3                	jb     102e67 <higher_half_start.call_constructor>
  102e74:	ff 35 0c 0d 11 00    	pushl  0x110d0c
  102e7a:	ff 35 08 0d 11 00    	pushl  0x110d08
  102e80:	e8 e9 19 00 00       	call   10486e <kmain>
  102e85:	bb 34 80 10 00       	mov    $0x108034,%ebx
  102e8a:	eb 05                	jmp    102e91 <higher_half_start.dtors_until_end>

00102e8c <higher_half_start.call_destructor>:
  102e8c:	83 eb 04             	sub    $0x4,%ebx
  102e8f:	ff 13                	call   *(%ebx)

00102e91 <higher_half_start.dtors_until_end>:
  102e91:	81 fb 34 80 10 00    	cmp    $0x108034,%ebx
  102e97:	77 f3                	ja     102e8c <higher_half_start.call_destructor>
  102e99:	fa                   	cli    

00102e9a <hang>:
  102e9a:	f4                   	hlt    
  102e9b:	eb fd                	jmp    102e9a <hang>
  102e9d:	66 90                	xchg   %ax,%ax
  102e9f:	90                   	nop

00102ea0 <check_fpu_presence>:
  102ea0:	0f 20 c2             	mov    %cr0,%edx
  102ea3:	0f 22 c2             	mov    %edx,%cr0
  102ea6:	db e3                	fninit 
  102ea8:	dd 3d c6 2e 10 00    	fnstsw 0x102ec6
  102eae:	66 83 3d c6 2e 10 00 	cmpw   $0x0,0x102ec6
  102eb5:	00 
  102eb6:	75 02                	jne    102eba <check_fpu_presence.nofpu>
  102eb8:	eb 06                	jmp    102ec0 <check_fpu_presence.hasfpu>

00102eba <check_fpu_presence.nofpu>:
  102eba:	b8 00 00 00 00       	mov    $0x0,%eax
  102ebf:	c3                   	ret    

00102ec0 <check_fpu_presence.hasfpu>:
  102ec0:	b8 01 00 00 00       	mov    $0x1,%eax
  102ec5:	c3                   	ret    

00102ec6 <check_fpu_presence.testword>:
  102ec6:	aa                   	stos   %al,%es:(%edi)
  102ec7:	55                   	push   %ebp

00102ec8 <setup_fpu>:
  102ec8:	0f 20 c2             	mov    %cr0,%edx
  102ecb:	83 ca 11             	or     $0x11,%edx
  102ece:	83 e2 fb             	and    $0xfffffffb,%edx
  102ed1:	0f 22 c2             	mov    %edx,%cr0
  102ed4:	0f 20 e2             	mov    %cr4,%edx
  102ed7:	0f 22 e2             	mov    %edx,%cr4
  102eda:	db e3                	fninit 
  102edc:	c3                   	ret    
  102edd:	66 90                	xchg   %ax,%ax
  102edf:	90                   	nop

00102ee0 <gdt_flush>:
  102ee0:	8b 44 24 04          	mov    0x4(%esp),%eax
  102ee4:	0f 01 10             	lgdtl  (%eax)
  102ee7:	ea ee 2e 10 00 08 00 	ljmp   $0x8,$0x102eee

00102eee <gdt_flush.flush>:
  102eee:	66 b8 10 00          	mov    $0x10,%ax
  102ef2:	8e d8                	mov    %eax,%ds
  102ef4:	8e c0                	mov    %eax,%es
  102ef6:	8e e0                	mov    %eax,%fs
  102ef8:	8e e8                	mov    %eax,%gs
  102efa:	8e d0                	mov    %eax,%ss
  102efc:	c3                   	ret    
  102efd:	66 90                	xchg   %ax,%ax
  102eff:	90                   	nop

00102f00 <idt_flush>:
  102f00:	8b 44 24 04          	mov    0x4(%esp),%eax
  102f04:	0f 01 18             	lidtl  (%eax)
  102f07:	c3                   	ret    

00102f08 <isr0>:
  102f08:	6a 00                	push   $0x0
  102f0a:	6a 00                	push   $0x0
  102f0c:	e9 68 01 00 00       	jmp    103079 <isr_common_stub>

00102f11 <isr1>:
  102f11:	6a 00                	push   $0x0
  102f13:	6a 01                	push   $0x1
  102f15:	e9 5f 01 00 00       	jmp    103079 <isr_common_stub>

00102f1a <isr2>:
  102f1a:	6a 00                	push   $0x0
  102f1c:	6a 02                	push   $0x2
  102f1e:	e9 56 01 00 00       	jmp    103079 <isr_common_stub>

00102f23 <isr3>:
  102f23:	6a 00                	push   $0x0
  102f25:	6a 03                	push   $0x3
  102f27:	e9 4d 01 00 00       	jmp    103079 <isr_common_stub>

00102f2c <isr4>:
  102f2c:	6a 00                	push   $0x0
  102f2e:	6a 04                	push   $0x4
  102f30:	e9 44 01 00 00       	jmp    103079 <isr_common_stub>

00102f35 <isr5>:
  102f35:	6a 00                	push   $0x0
  102f37:	6a 05                	push   $0x5
  102f39:	e9 3b 01 00 00       	jmp    103079 <isr_common_stub>

00102f3e <isr6>:
  102f3e:	6a 00                	push   $0x0
  102f40:	6a 06                	push   $0x6
  102f42:	e9 32 01 00 00       	jmp    103079 <isr_common_stub>

00102f47 <isr7>:
  102f47:	6a 00                	push   $0x0
  102f49:	6a 07                	push   $0x7
  102f4b:	e9 29 01 00 00       	jmp    103079 <isr_common_stub>

00102f50 <isr8>:
  102f50:	6a 08                	push   $0x8
  102f52:	e9 22 01 00 00       	jmp    103079 <isr_common_stub>

00102f57 <isr9>:
  102f57:	6a 00                	push   $0x0
  102f59:	6a 09                	push   $0x9
  102f5b:	e9 19 01 00 00       	jmp    103079 <isr_common_stub>

00102f60 <isr10>:
  102f60:	6a 0a                	push   $0xa
  102f62:	e9 12 01 00 00       	jmp    103079 <isr_common_stub>

00102f67 <isr11>:
  102f67:	6a 0b                	push   $0xb
  102f69:	e9 0b 01 00 00       	jmp    103079 <isr_common_stub>

00102f6e <isr12>:
  102f6e:	6a 0c                	push   $0xc
  102f70:	e9 04 01 00 00       	jmp    103079 <isr_common_stub>

00102f75 <isr13>:
  102f75:	6a 0d                	push   $0xd
  102f77:	e9 fd 00 00 00       	jmp    103079 <isr_common_stub>

00102f7c <isr14>:
  102f7c:	6a 0e                	push   $0xe
  102f7e:	e9 f6 00 00 00       	jmp    103079 <isr_common_stub>

00102f83 <isr15>:
  102f83:	6a 00                	push   $0x0
  102f85:	6a 0f                	push   $0xf
  102f87:	e9 ed 00 00 00       	jmp    103079 <isr_common_stub>

00102f8c <isr16>:
  102f8c:	6a 00                	push   $0x0
  102f8e:	6a 10                	push   $0x10
  102f90:	e9 e4 00 00 00       	jmp    103079 <isr_common_stub>

00102f95 <isr17>:
  102f95:	6a 00                	push   $0x0
  102f97:	6a 11                	push   $0x11
  102f99:	e9 db 00 00 00       	jmp    103079 <isr_common_stub>

00102f9e <isr18>:
  102f9e:	6a 00                	push   $0x0
  102fa0:	6a 12                	push   $0x12
  102fa2:	e9 d2 00 00 00       	jmp    103079 <isr_common_stub>

00102fa7 <isr19>:
  102fa7:	6a 00                	push   $0x0
  102fa9:	6a 13                	push   $0x13
  102fab:	e9 c9 00 00 00       	jmp    103079 <isr_common_stub>

00102fb0 <isr20>:
  102fb0:	6a 00                	push   $0x0
  102fb2:	6a 14                	push   $0x14
  102fb4:	e9 c0 00 00 00       	jmp    103079 <isr_common_stub>

00102fb9 <isr21>:
  102fb9:	6a 00                	push   $0x0
  102fbb:	6a 15                	push   $0x15
  102fbd:	e9 b7 00 00 00       	jmp    103079 <isr_common_stub>

00102fc2 <isr22>:
  102fc2:	6a 00                	push   $0x0
  102fc4:	6a 16                	push   $0x16
  102fc6:	e9 ae 00 00 00       	jmp    103079 <isr_common_stub>

00102fcb <isr23>:
  102fcb:	6a 00                	push   $0x0
  102fcd:	6a 17                	push   $0x17
  102fcf:	e9 a5 00 00 00       	jmp    103079 <isr_common_stub>

00102fd4 <isr24>:
  102fd4:	6a 00                	push   $0x0
  102fd6:	6a 18                	push   $0x18
  102fd8:	e9 9c 00 00 00       	jmp    103079 <isr_common_stub>

00102fdd <isr25>:
  102fdd:	6a 00                	push   $0x0
  102fdf:	6a 19                	push   $0x19
  102fe1:	e9 93 00 00 00       	jmp    103079 <isr_common_stub>

00102fe6 <isr26>:
  102fe6:	6a 00                	push   $0x0
  102fe8:	6a 1a                	push   $0x1a
  102fea:	e9 8a 00 00 00       	jmp    103079 <isr_common_stub>

00102fef <isr27>:
  102fef:	6a 00                	push   $0x0
  102ff1:	6a 1b                	push   $0x1b
  102ff3:	e9 81 00 00 00       	jmp    103079 <isr_common_stub>

00102ff8 <isr28>:
  102ff8:	6a 00                	push   $0x0
  102ffa:	6a 1c                	push   $0x1c
  102ffc:	eb 7b                	jmp    103079 <isr_common_stub>

00102ffe <isr29>:
  102ffe:	6a 00                	push   $0x0
  103000:	6a 1d                	push   $0x1d
  103002:	eb 75                	jmp    103079 <isr_common_stub>

00103004 <isr30>:
  103004:	6a 00                	push   $0x0
  103006:	6a 1e                	push   $0x1e
  103008:	eb 6f                	jmp    103079 <isr_common_stub>

0010300a <isr31>:
  10300a:	6a 00                	push   $0x0
  10300c:	6a 1f                	push   $0x1f
  10300e:	eb 69                	jmp    103079 <isr_common_stub>

00103010 <irq0>:
  103010:	6a 00                	push   $0x0
  103012:	6a 20                	push   $0x20
  103014:	e9 92 00 00 00       	jmp    1030ab <irq_common_stub>

00103019 <irq1>:
  103019:	6a 00                	push   $0x0
  10301b:	6a 21                	push   $0x21
  10301d:	e9 89 00 00 00       	jmp    1030ab <irq_common_stub>

00103022 <irq2>:
  103022:	6a 00                	push   $0x0
  103024:	6a 22                	push   $0x22
  103026:	e9 80 00 00 00       	jmp    1030ab <irq_common_stub>

0010302b <irq3>:
  10302b:	6a 00                	push   $0x0
  10302d:	6a 23                	push   $0x23
  10302f:	eb 7a                	jmp    1030ab <irq_common_stub>

00103031 <irq4>:
  103031:	6a 00                	push   $0x0
  103033:	6a 24                	push   $0x24
  103035:	eb 74                	jmp    1030ab <irq_common_stub>

00103037 <irq5>:
  103037:	6a 00                	push   $0x0
  103039:	6a 25                	push   $0x25
  10303b:	eb 6e                	jmp    1030ab <irq_common_stub>

0010303d <irq6>:
  10303d:	6a 00                	push   $0x0
  10303f:	6a 26                	push   $0x26
  103041:	eb 68                	jmp    1030ab <irq_common_stub>

00103043 <irq7>:
  103043:	6a 00                	push   $0x0
  103045:	6a 27                	push   $0x27
  103047:	eb 62                	jmp    1030ab <irq_common_stub>

00103049 <irq8>:
  103049:	6a 00                	push   $0x0
  10304b:	6a 28                	push   $0x28
  10304d:	eb 5c                	jmp    1030ab <irq_common_stub>

0010304f <irq9>:
  10304f:	6a 00                	push   $0x0
  103051:	6a 29                	push   $0x29
  103053:	eb 56                	jmp    1030ab <irq_common_stub>

00103055 <irq10>:
  103055:	6a 00                	push   $0x0
  103057:	6a 2a                	push   $0x2a
  103059:	eb 50                	jmp    1030ab <irq_common_stub>

0010305b <irq11>:
  10305b:	6a 00                	push   $0x0
  10305d:	6a 2b                	push   $0x2b
  10305f:	eb 4a                	jmp    1030ab <irq_common_stub>

00103061 <irq12>:
  103061:	6a 00                	push   $0x0
  103063:	6a 2c                	push   $0x2c
  103065:	eb 44                	jmp    1030ab <irq_common_stub>

00103067 <irq13>:
  103067:	6a 00                	push   $0x0
  103069:	6a 2d                	push   $0x2d
  10306b:	eb 3e                	jmp    1030ab <irq_common_stub>

0010306d <irq14>:
  10306d:	6a 00                	push   $0x0
  10306f:	6a 2e                	push   $0x2e
  103071:	eb 38                	jmp    1030ab <irq_common_stub>

00103073 <irq15>:
  103073:	6a 00                	push   $0x0
  103075:	6a 2f                	push   $0x2f
  103077:	eb 32                	jmp    1030ab <irq_common_stub>

00103079 <isr_common_stub>:
  103079:	57                   	push   %edi
  10307a:	56                   	push   %esi
  10307b:	55                   	push   %ebp
  10307c:	53                   	push   %ebx
  10307d:	52                   	push   %edx
  10307e:	51                   	push   %ecx
  10307f:	50                   	push   %eax
  103080:	1e                   	push   %ds
  103081:	06                   	push   %es
  103082:	0f a0                	push   %fs
  103084:	0f a8                	push   %gs
  103086:	66 b8 10 00          	mov    $0x10,%ax
  10308a:	8e d8                	mov    %eax,%ds
  10308c:	8e c0                	mov    %eax,%es
  10308e:	8e e0                	mov    %eax,%fs
  103090:	8e e8                	mov    %eax,%gs
  103092:	54                   	push   %esp
  103093:	e8 29 f2 ff ff       	call   1022c1 <isr_handler>
  103098:	89 c4                	mov    %eax,%esp
  10309a:	0f a9                	pop    %gs
  10309c:	0f a1                	pop    %fs
  10309e:	07                   	pop    %es
  10309f:	1f                   	pop    %ds
  1030a0:	58                   	pop    %eax
  1030a1:	59                   	pop    %ecx
  1030a2:	5a                   	pop    %edx
  1030a3:	5b                   	pop    %ebx
  1030a4:	5d                   	pop    %ebp
  1030a5:	5e                   	pop    %esi
  1030a6:	5f                   	pop    %edi
  1030a7:	83 c4 08             	add    $0x8,%esp
  1030aa:	cf                   	iret   

001030ab <irq_common_stub>:
  1030ab:	57                   	push   %edi
  1030ac:	56                   	push   %esi
  1030ad:	55                   	push   %ebp
  1030ae:	53                   	push   %ebx
  1030af:	52                   	push   %edx
  1030b0:	51                   	push   %ecx
  1030b1:	50                   	push   %eax
  1030b2:	1e                   	push   %ds
  1030b3:	06                   	push   %es
  1030b4:	0f a0                	push   %fs
  1030b6:	0f a8                	push   %gs
  1030b8:	66 b8 10 00          	mov    $0x10,%ax
  1030bc:	8e d8                	mov    %eax,%ds
  1030be:	8e c0                	mov    %eax,%es
  1030c0:	8e e0                	mov    %eax,%fs
  1030c2:	8e e8                	mov    %eax,%gs
  1030c4:	54                   	push   %esp
  1030c5:	e8 40 f2 ff ff       	call   10230a <irq_handler>
  1030ca:	89 c4                	mov    %eax,%esp
  1030cc:	0f a9                	pop    %gs
  1030ce:	0f a1                	pop    %fs
  1030d0:	07                   	pop    %es
  1030d1:	1f                   	pop    %ds
  1030d2:	58                   	pop    %eax
  1030d3:	59                   	pop    %ecx
  1030d4:	5a                   	pop    %edx
  1030d5:	5b                   	pop    %ebx
  1030d6:	5d                   	pop    %ebp
  1030d7:	5e                   	pop    %esi
  1030d8:	5f                   	pop    %edi
  1030d9:	83 c4 08             	add    $0x8,%esp
  1030dc:	cf                   	iret   
  1030dd:	66 90                	xchg   %ax,%ax
  1030df:	90                   	nop

001030e0 <init_paging>:
  1030e0:	58                   	pop    %eax
  1030e1:	0f 22 d8             	mov    %eax,%cr3
  1030e4:	0f 20 c0             	mov    %cr0,%eax
  1030e7:	0d 00 00 00 80       	or     $0x80000000,%eax
  1030ec:	0f 22 c0             	mov    %eax,%cr0
  1030ef:	c3                   	ret    

001030f0 <_ZL15vga_entry_color9vga_colorS_>:
    VGA_COLOR_LIGHT_BROWN = 14,
    VGA_COLOR_WHITE = 15,
};

static inline uint8_t vga_entry_color(enum vga_color fg, enum vga_color bg)
{
  1030f0:	83 ec 08             	sub    $0x8,%esp
  1030f3:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1030f7:	8b 44 24 10          	mov    0x10(%esp),%eax
  1030fb:	88 54 24 04          	mov    %dl,0x4(%esp)
  1030ff:	88 04 24             	mov    %al,(%esp)
    return fg | bg << 4;
  103102:	0f b6 04 24          	movzbl (%esp),%eax
  103106:	c1 e0 04             	shl    $0x4,%eax
  103109:	89 c2                	mov    %eax,%edx
  10310b:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
  103110:	09 d0                	or     %edx,%eax
}
  103112:	83 c4 08             	add    $0x8,%esp
  103115:	c3                   	ret    

00103116 <_ZL9vga_entryhh>:

static inline uint16_t vga_entry(uint8_t uc, uint8_t color)
{
  103116:	83 ec 08             	sub    $0x8,%esp
  103119:	8b 54 24 0c          	mov    0xc(%esp),%edx
  10311d:	8b 44 24 10          	mov    0x10(%esp),%eax
  103121:	88 54 24 04          	mov    %dl,0x4(%esp)
  103125:	88 04 24             	mov    %al,(%esp)
    return (uint16_t) uc | (uint16_t) color << 8;
  103128:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
  10312d:	0f b6 14 24          	movzbl (%esp),%edx
  103131:	c1 e2 08             	shl    $0x8,%edx
  103134:	09 d0                	or     %edx,%eax
}
  103136:	83 c4 08             	add    $0x8,%esp
  103139:	c3                   	ret    

0010313a <_ZN6detail12TerminalImplC1Ev>:
#include "bios/bda.hpp"
#include "halt.hpp"

#include "utils/minmax.hpp"

detail::TerminalImpl::TerminalImpl()
  10313a:	83 ec 0c             	sub    $0xc,%esp
  10313d:	8b 44 24 10          	mov    0x10(%esp),%eax
  103141:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  103147:	8b 44 24 10          	mov    0x10(%esp),%eax
  10314b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    uint8_t terminal_color { vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK) };
  103152:	6a 00                	push   $0x0
  103154:	6a 07                	push   $0x7
  103156:	e8 95 ff ff ff       	call   1030f0 <_ZL15vga_entry_color9vga_colorS_>
  10315b:	83 c4 08             	add    $0x8,%esp
  10315e:	89 c2                	mov    %eax,%edx
  103160:	8b 44 24 10          	mov    0x10(%esp),%eax
  103164:	88 50 08             	mov    %dl,0x8(%eax)
    uint8_t old_terminal_color { vga_entry_color(VGA_COLOR_LIGHT_GREY, VGA_COLOR_BLACK) };
  103167:	6a 00                	push   $0x0
  103169:	6a 07                	push   $0x7
  10316b:	e8 80 ff ff ff       	call   1030f0 <_ZL15vga_entry_color9vga_colorS_>
  103170:	83 c4 08             	add    $0x8,%esp
  103173:	89 c2                	mov    %eax,%edx
  103175:	8b 44 24 10          	mov    0x10(%esp),%eax
  103179:	88 50 09             	mov    %dl,0x9(%eax)
    uint16_t* terminal_buffer { reinterpret_cast<uint16_t*>(phys(0xB8000)) };
  10317c:	83 ec 0c             	sub    $0xc,%esp
  10317f:	68 00 80 0b 00       	push   $0xb8000
  103184:	e8 b6 44 00 00       	call   10763f <_Z4physm>
  103189:	83 c4 10             	add    $0x10,%esp
  10318c:	89 c2                	mov    %eax,%edx
  10318e:	8b 44 24 10          	mov    0x10(%esp),%eax
  103192:	89 50 0c             	mov    %edx,0xc(%eax)
  103195:	8b 44 24 10          	mov    0x10(%esp),%eax
  103199:	83 c0 10             	add    $0x10,%eax
  10319c:	83 ec 0c             	sub    $0xc,%esp
  10319f:	50                   	push   %eax
  1031a0:	e8 d1 46 00 00       	call   107876 <_ZN14CircularBufferIA80_tLm250EEC1Ev>
  1031a5:	83 c4 10             	add    $0x10,%esp
  1031a8:	8b 44 24 10          	mov    0x10(%esp),%eax
  1031ac:	c6 80 58 9c 00 00 00 	movb   $0x0,0x9c58(%eax)
{
    clear();
  1031b3:	83 ec 0c             	sub    $0xc,%esp
  1031b6:	ff 74 24 1c          	pushl  0x1c(%esp)
  1031ba:	e8 41 02 00 00       	call   103400 <_ZN6detail12TerminalImpl5clearEv>
  1031bf:	83 c4 10             	add    $0x10,%esp
}
  1031c2:	90                   	nop
  1031c3:	83 c4 0c             	add    $0xc,%esp
  1031c6:	c3                   	ret    
  1031c7:	90                   	nop

001031c8 <_ZN6detail12TerminalImpl9set_colorEh>:

void detail::TerminalImpl::set_color(uint8_t color)
{
  1031c8:	83 ec 04             	sub    $0x4,%esp
  1031cb:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1031cf:	88 04 24             	mov    %al,(%esp)
    terminal_color = color;
  1031d2:	8b 44 24 08          	mov    0x8(%esp),%eax
  1031d6:	0f b6 14 24          	movzbl (%esp),%edx
  1031da:	88 50 08             	mov    %dl,0x8(%eax)
}
  1031dd:	90                   	nop
  1031de:	83 c4 04             	add    $0x4,%esp
  1031e1:	c3                   	ret    

001031e2 <_ZN6detail12TerminalImpl12put_entry_atEhhmm>:

void detail::TerminalImpl::put_entry_at(uint8_t c, uint8_t color, size_t x, size_t y)
{
  1031e2:	53                   	push   %ebx
  1031e3:	83 ec 28             	sub    $0x28,%esp
  1031e6:	8b 54 24 34          	mov    0x34(%esp),%edx
  1031ea:	8b 44 24 38          	mov    0x38(%esp),%eax
  1031ee:	88 54 24 0c          	mov    %dl,0xc(%esp)
  1031f2:	88 44 24 08          	mov    %al,0x8(%esp)
    check_pos();
  1031f6:	83 ec 0c             	sub    $0xc,%esp
  1031f9:	ff 74 24 3c          	pushl  0x3c(%esp)
  1031fd:	e8 0e 05 00 00       	call   103710 <_ZN6detail12TerminalImpl9check_posEv>
  103202:	83 c4 10             	add    $0x10,%esp
    const size_t index = y * vga_width + x;
  103205:	8b 54 24 40          	mov    0x40(%esp),%edx
  103209:	89 d0                	mov    %edx,%eax
  10320b:	c1 e0 02             	shl    $0x2,%eax
  10320e:	01 d0                	add    %edx,%eax
  103210:	c1 e0 04             	shl    $0x4,%eax
  103213:	89 c2                	mov    %eax,%edx
  103215:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  103219:	01 d0                	add    %edx,%eax
  10321b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    terminal_buffer[index] = vga_entry(c, color);
  10321f:	0f b6 54 24 08       	movzbl 0x8(%esp),%edx
  103224:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  103229:	8b 4c 24 30          	mov    0x30(%esp),%ecx
  10322d:	8b 49 0c             	mov    0xc(%ecx),%ecx
  103230:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  103234:	01 db                	add    %ebx,%ebx
  103236:	01 cb                	add    %ecx,%ebx
  103238:	83 ec 08             	sub    $0x8,%esp
  10323b:	52                   	push   %edx
  10323c:	50                   	push   %eax
  10323d:	e8 d4 fe ff ff       	call   103116 <_ZL9vga_entryhh>
  103242:	83 c4 10             	add    $0x10,%esp
  103245:	66 89 03             	mov    %ax,(%ebx)
}
  103248:	90                   	nop
  103249:	83 c4 28             	add    $0x28,%esp
  10324c:	5b                   	pop    %ebx
  10324d:	c3                   	ret    

0010324e <_ZN6detail12TerminalImpl8put_charEh>:

void detail::TerminalImpl::put_char(uint8_t c)
{
  10324e:	53                   	push   %ebx
  10324f:	83 ec 18             	sub    $0x18,%esp
  103252:	8b 44 24 24          	mov    0x24(%esp),%eax
  103256:	88 44 24 0c          	mov    %al,0xc(%esp)
    if (c == '\n')
  10325a:	80 7c 24 0c 0a       	cmpb   $0xa,0xc(%esp)
  10325f:	75 14                	jne    103275 <_ZN6detail12TerminalImpl8put_charEh+0x27>
    {
        new_line();
  103261:	83 ec 0c             	sub    $0xc,%esp
  103264:	ff 74 24 2c          	pushl  0x2c(%esp)
  103268:	e8 ed 03 00 00       	call   10365a <_ZN6detail12TerminalImpl8new_lineEv>
  10326d:	83 c4 10             	add    $0x10,%esp
  103270:	e9 08 01 00 00       	jmp    10337d <_ZN6detail12TerminalImpl8put_charEh+0x12f>
    }
    else if (c == '\r')
  103275:	80 7c 24 0c 0d       	cmpb   $0xd,0xc(%esp)
  10327a:	75 10                	jne    10328c <_ZN6detail12TerminalImpl8put_charEh+0x3e>
    {
        terminal_column = 0;
  10327c:	8b 44 24 20          	mov    0x20(%esp),%eax
  103280:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  103287:	e9 f1 00 00 00       	jmp    10337d <_ZN6detail12TerminalImpl8put_charEh+0x12f>
    }
    else if (c == '\b')
  10328c:	80 7c 24 0c 08       	cmpb   $0x8,0xc(%esp)
  103291:	75 5c                	jne    1032ef <_ZN6detail12TerminalImpl8put_charEh+0xa1>
    {
        if (terminal_column == 0)
  103293:	8b 44 24 20          	mov    0x20(%esp),%eax
  103297:	8b 40 04             	mov    0x4(%eax),%eax
  10329a:	85 c0                	test   %eax,%eax
  10329c:	74 11                	je     1032af <_ZN6detail12TerminalImpl8put_charEh+0x61>
                //--terminal_row;
            }
        }
        else
        {
            --terminal_column;
  10329e:	8b 44 24 20          	mov    0x20(%esp),%eax
  1032a2:	8b 40 04             	mov    0x4(%eax),%eax
  1032a5:	8d 50 ff             	lea    -0x1(%eax),%edx
  1032a8:	8b 44 24 20          	mov    0x20(%esp),%eax
  1032ac:	89 50 04             	mov    %edx,0x4(%eax)
        }

        put_entry_at(' ', terminal_color, terminal_column, terminal_row);
  1032af:	8b 44 24 20          	mov    0x20(%esp),%eax
  1032b3:	8b 08                	mov    (%eax),%ecx
  1032b5:	8b 44 24 20          	mov    0x20(%esp),%eax
  1032b9:	8b 50 04             	mov    0x4(%eax),%edx
  1032bc:	8b 44 24 20          	mov    0x20(%esp),%eax
  1032c0:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  1032c4:	0f b6 c0             	movzbl %al,%eax
  1032c7:	83 ec 0c             	sub    $0xc,%esp
  1032ca:	51                   	push   %ecx
  1032cb:	52                   	push   %edx
  1032cc:	50                   	push   %eax
  1032cd:	6a 20                	push   $0x20
  1032cf:	ff 74 24 3c          	pushl  0x3c(%esp)
  1032d3:	e8 0a ff ff ff       	call   1031e2 <_ZN6detail12TerminalImpl12put_entry_atEhhmm>
  1032d8:	83 c4 20             	add    $0x20,%esp

        check_pos();
  1032db:	83 ec 0c             	sub    $0xc,%esp
  1032de:	ff 74 24 2c          	pushl  0x2c(%esp)
  1032e2:	e8 29 04 00 00       	call   103710 <_ZN6detail12TerminalImpl9check_posEv>
  1032e7:	83 c4 10             	add    $0x10,%esp
  1032ea:	e9 8e 00 00 00       	jmp    10337d <_ZN6detail12TerminalImpl8put_charEh+0x12f>
    }
    else if (c == '\t')
  1032ef:	80 7c 24 0c 09       	cmpb   $0x9,0xc(%esp)
  1032f4:	75 13                	jne    103309 <_ZN6detail12TerminalImpl8put_charEh+0xbb>
    {
        terminal_column += 4;
  1032f6:	8b 44 24 20          	mov    0x20(%esp),%eax
  1032fa:	8b 40 04             	mov    0x4(%eax),%eax
  1032fd:	8d 50 04             	lea    0x4(%eax),%edx
  103300:	8b 44 24 20          	mov    0x20(%esp),%eax
  103304:	89 50 04             	mov    %edx,0x4(%eax)
  103307:	eb 74                	jmp    10337d <_ZN6detail12TerminalImpl8put_charEh+0x12f>
    }
    else if (c == '\a')
  103309:	80 7c 24 0c 07       	cmpb   $0x7,0xc(%esp)
  10330e:	75 17                	jne    103327 <_ZN6detail12TerminalImpl8put_charEh+0xd9>
    {
#ifdef ARCH_i686
        Speaker::beep(200);
  103310:	83 ec 08             	sub    $0x8,%esp
  103313:	68 e8 03 00 00       	push   $0x3e8
  103318:	68 c8 00 00 00       	push   $0xc8
  10331d:	e8 3e 14 00 00       	call   104760 <_ZN7Speaker4beepEmt>
  103322:	83 c4 10             	add    $0x10,%esp
  103325:	eb 56                	jmp    10337d <_ZN6detail12TerminalImpl8put_charEh+0x12f>
#endif
    }
    else if (isprint(c))
  103327:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  10332c:	83 ec 0c             	sub    $0xc,%esp
  10332f:	50                   	push   %eax
  103330:	e8 1c 45 00 00       	call   107851 <_Z7isprintDi>
  103335:	83 c4 10             	add    $0x10,%esp
  103338:	84 c0                	test   %al,%al
  10333a:	74 41                	je     10337d <_ZN6detail12TerminalImpl8put_charEh+0x12f>
    {
        put_entry_at(c, terminal_color, terminal_column, terminal_row);
  10333c:	8b 44 24 20          	mov    0x20(%esp),%eax
  103340:	8b 18                	mov    (%eax),%ebx
  103342:	8b 44 24 20          	mov    0x20(%esp),%eax
  103346:	8b 48 04             	mov    0x4(%eax),%ecx
  103349:	8b 44 24 20          	mov    0x20(%esp),%eax
  10334d:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  103351:	0f b6 d0             	movzbl %al,%edx
  103354:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  103359:	83 ec 0c             	sub    $0xc,%esp
  10335c:	53                   	push   %ebx
  10335d:	51                   	push   %ecx
  10335e:	52                   	push   %edx
  10335f:	50                   	push   %eax
  103360:	ff 74 24 3c          	pushl  0x3c(%esp)
  103364:	e8 79 fe ff ff       	call   1031e2 <_ZN6detail12TerminalImpl12put_entry_atEhhmm>
  103369:	83 c4 20             	add    $0x20,%esp
        ++terminal_column;
  10336c:	8b 44 24 20          	mov    0x20(%esp),%eax
  103370:	8b 40 04             	mov    0x4(%eax),%eax
  103373:	8d 50 01             	lea    0x1(%eax),%edx
  103376:	8b 44 24 20          	mov    0x20(%esp),%eax
  10337a:	89 50 04             	mov    %edx,0x4(%eax)
    }

    check_pos();
  10337d:	83 ec 0c             	sub    $0xc,%esp
  103380:	ff 74 24 2c          	pushl  0x2c(%esp)
  103384:	e8 87 03 00 00       	call   103710 <_ZN6detail12TerminalImpl9check_posEv>
  103389:	83 c4 10             	add    $0x10,%esp
}
  10338c:	90                   	nop
  10338d:	83 c4 18             	add    $0x18,%esp
  103390:	5b                   	pop    %ebx
  103391:	c3                   	ret    

00103392 <_ZN6detail12TerminalImpl5writeEPKcm>:

void detail::TerminalImpl::write(const char *data, size_t size)
{
  103392:	83 ec 1c             	sub    $0x1c,%esp
    for (size_t i = 0; i < size; i++)
  103395:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10339c:	00 
  10339d:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1033a1:	3b 44 24 28          	cmp    0x28(%esp),%eax
  1033a5:	73 27                	jae    1033ce <_ZN6detail12TerminalImpl5writeEPKcm+0x3c>
    {
        put_char(data[i]);
  1033a7:	8b 54 24 24          	mov    0x24(%esp),%edx
  1033ab:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1033af:	01 d0                	add    %edx,%eax
  1033b1:	0f b6 00             	movzbl (%eax),%eax
  1033b4:	0f b6 c0             	movzbl %al,%eax
  1033b7:	83 ec 08             	sub    $0x8,%esp
  1033ba:	50                   	push   %eax
  1033bb:	ff 74 24 2c          	pushl  0x2c(%esp)
  1033bf:	e8 8a fe ff ff       	call   10324e <_ZN6detail12TerminalImpl8put_charEh>
  1033c4:	83 c4 10             	add    $0x10,%esp
    for (size_t i = 0; i < size; i++)
  1033c7:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
  1033cc:	eb cf                	jmp    10339d <_ZN6detail12TerminalImpl5writeEPKcm+0xb>
    }
}
  1033ce:	90                   	nop
  1033cf:	83 c4 1c             	add    $0x1c,%esp
  1033d2:	c3                   	ret    
  1033d3:	90                   	nop

001033d4 <_ZN6detail12TerminalImpl12write_stringEPKc>:

void detail::TerminalImpl::write_string(const char *data)
{
  1033d4:	83 ec 0c             	sub    $0xc,%esp
    write(data, strlen(data));
  1033d7:	83 ec 0c             	sub    $0xc,%esp
  1033da:	ff 74 24 20          	pushl  0x20(%esp)
  1033de:	e8 7e 3d 00 00       	call   107161 <strlen>
  1033e3:	83 c4 10             	add    $0x10,%esp
  1033e6:	83 ec 04             	sub    $0x4,%esp
  1033e9:	50                   	push   %eax
  1033ea:	ff 74 24 1c          	pushl  0x1c(%esp)
  1033ee:	ff 74 24 1c          	pushl  0x1c(%esp)
  1033f2:	e8 9b ff ff ff       	call   103392 <_ZN6detail12TerminalImpl5writeEPKcm>
  1033f7:	83 c4 10             	add    $0x10,%esp
}
  1033fa:	90                   	nop
  1033fb:	83 c4 0c             	add    $0xc,%esp
  1033fe:	c3                   	ret    
  1033ff:	90                   	nop

00103400 <_ZN6detail12TerminalImpl5clearEv>:

void detail::TerminalImpl::clear()
{
  103400:	83 ec 0c             	sub    $0xc,%esp
    memsetw(terminal_buffer, vga_entry(' ', terminal_color), vga_height*vga_width*4);
  103403:	8b 44 24 10          	mov    0x10(%esp),%eax
  103407:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  10340b:	0f b6 c0             	movzbl %al,%eax
  10340e:	50                   	push   %eax
  10340f:	6a 20                	push   $0x20
  103411:	e8 00 fd ff ff       	call   103116 <_ZL9vga_entryhh>
  103416:	83 c4 08             	add    $0x8,%esp
  103419:	0f b7 d0             	movzwl %ax,%edx
  10341c:	8b 44 24 10          	mov    0x10(%esp),%eax
  103420:	8b 40 0c             	mov    0xc(%eax),%eax
  103423:	83 ec 04             	sub    $0x4,%esp
  103426:	68 40 1f 00 00       	push   $0x1f40
  10342b:	52                   	push   %edx
  10342c:	50                   	push   %eax
  10342d:	e8 e5 3c 00 00       	call   107117 <memsetw>
  103432:	83 c4 10             	add    $0x10,%esp
}
  103435:	90                   	nop
  103436:	83 c4 0c             	add    $0xc,%esp
  103439:	c3                   	ret    

0010343a <_ZN6detail12TerminalImpl9scroll_upEv>:

void detail::TerminalImpl::scroll_up()
{
  10343a:	53                   	push   %ebx
  10343b:	83 ec 18             	sub    $0x18,%esp
    for (size_t y { 1 }; y < vga_height; ++y)
  10343e:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  103445:	00 
  103446:	83 7c 24 0c 18       	cmpl   $0x18,0xc(%esp)
  10344b:	77 4c                	ja     103499 <_ZN6detail12TerminalImpl9scroll_upEv+0x5f>
    {
        memcpy(terminal_buffer + (y-1)*vga_width, terminal_buffer + y*vga_width, vga_width*4); // copy line below
  10344d:	8b 44 24 20          	mov    0x20(%esp),%eax
  103451:	8b 48 0c             	mov    0xc(%eax),%ecx
  103454:	8b 54 24 0c          	mov    0xc(%esp),%edx
  103458:	89 d0                	mov    %edx,%eax
  10345a:	c1 e0 02             	shl    $0x2,%eax
  10345d:	01 d0                	add    %edx,%eax
  10345f:	c1 e0 05             	shl    $0x5,%eax
  103462:	01 c1                	add    %eax,%ecx
  103464:	8b 44 24 20          	mov    0x20(%esp),%eax
  103468:	8b 58 0c             	mov    0xc(%eax),%ebx
  10346b:	8b 54 24 0c          	mov    0xc(%esp),%edx
  10346f:	89 d0                	mov    %edx,%eax
  103471:	c1 e0 02             	shl    $0x2,%eax
  103474:	01 d0                	add    %edx,%eax
  103476:	c1 e0 05             	shl    $0x5,%eax
  103479:	2d a0 00 00 00       	sub    $0xa0,%eax
  10347e:	01 d8                	add    %ebx,%eax
  103480:	83 ec 04             	sub    $0x4,%esp
  103483:	68 40 01 00 00       	push   $0x140
  103488:	51                   	push   %ecx
  103489:	50                   	push   %eax
  10348a:	e8 ff 3b 00 00       	call   10708e <memcpy>
  10348f:	83 c4 10             	add    $0x10,%esp
    for (size_t y { 1 }; y < vga_height; ++y)
  103492:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
  103497:	eb ad                	jmp    103446 <_ZN6detail12TerminalImpl9scroll_upEv+0xc>
    }
    memsetw(terminal_buffer + (vga_height-1)*vga_width, vga_entry(' ', terminal_color), vga_width*4); // clear scrolled line
  103499:	8b 44 24 20          	mov    0x20(%esp),%eax
  10349d:	0f b6 40 08          	movzbl 0x8(%eax),%eax
  1034a1:	0f b6 c0             	movzbl %al,%eax
  1034a4:	83 ec 08             	sub    $0x8,%esp
  1034a7:	50                   	push   %eax
  1034a8:	6a 20                	push   $0x20
  1034aa:	e8 67 fc ff ff       	call   103116 <_ZL9vga_entryhh>
  1034af:	83 c4 10             	add    $0x10,%esp
  1034b2:	0f b7 c0             	movzwl %ax,%eax
  1034b5:	8b 54 24 20          	mov    0x20(%esp),%edx
  1034b9:	8b 52 0c             	mov    0xc(%edx),%edx
  1034bc:	81 c2 00 0f 00 00    	add    $0xf00,%edx
  1034c2:	83 ec 04             	sub    $0x4,%esp
  1034c5:	68 40 01 00 00       	push   $0x140
  1034ca:	50                   	push   %eax
  1034cb:	52                   	push   %edx
  1034cc:	e8 46 3c 00 00       	call   107117 <memsetw>
  1034d1:	83 c4 10             	add    $0x10,%esp
    --terminal_row;
  1034d4:	8b 44 24 20          	mov    0x20(%esp),%eax
  1034d8:	8b 00                	mov    (%eax),%eax
  1034da:	8d 50 ff             	lea    -0x1(%eax),%edx
  1034dd:	8b 44 24 20          	mov    0x20(%esp),%eax
  1034e1:	89 10                	mov    %edx,(%eax)
    update_cursor();
  1034e3:	83 ec 0c             	sub    $0xc,%esp
  1034e6:	ff 74 24 2c          	pushl  0x2c(%esp)
  1034ea:	e8 43 03 00 00       	call   103832 <_ZN6detail12TerminalImpl13update_cursorEv>
  1034ef:	83 c4 10             	add    $0x10,%esp
}
  1034f2:	90                   	nop
  1034f3:	83 c4 18             	add    $0x18,%esp
  1034f6:	5b                   	pop    %ebx
  1034f7:	c3                   	ret    

001034f8 <_ZN6detail12TerminalImpl10push_colorEh>:

void detail::TerminalImpl::push_color(uint8_t color)
{
  1034f8:	83 ec 04             	sub    $0x4,%esp
  1034fb:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1034ff:	88 04 24             	mov    %al,(%esp)
    old_terminal_color = terminal_color;
  103502:	8b 44 24 08          	mov    0x8(%esp),%eax
  103506:	0f b6 50 08          	movzbl 0x8(%eax),%edx
  10350a:	8b 44 24 08          	mov    0x8(%esp),%eax
  10350e:	88 50 09             	mov    %dl,0x9(%eax)
    set_color(color);
  103511:	0f b6 04 24          	movzbl (%esp),%eax
  103515:	50                   	push   %eax
  103516:	ff 74 24 0c          	pushl  0xc(%esp)
  10351a:	e8 a9 fc ff ff       	call   1031c8 <_ZN6detail12TerminalImpl9set_colorEh>
  10351f:	83 c4 08             	add    $0x8,%esp
}
  103522:	90                   	nop
  103523:	83 c4 04             	add    $0x4,%esp
  103526:	c3                   	ret    
  103527:	90                   	nop

00103528 <_ZN6detail12TerminalImpl9pop_colorEv>:

void detail::TerminalImpl::pop_color()
{
    set_color(old_terminal_color);
  103528:	8b 44 24 04          	mov    0x4(%esp),%eax
  10352c:	0f b6 40 09          	movzbl 0x9(%eax),%eax
  103530:	0f b6 c0             	movzbl %al,%eax
  103533:	50                   	push   %eax
  103534:	ff 74 24 08          	pushl  0x8(%esp)
  103538:	e8 8b fc ff ff       	call   1031c8 <_ZN6detail12TerminalImpl9set_colorEh>
  10353d:	83 c4 08             	add    $0x8,%esp
}
  103540:	90                   	nop
  103541:	c3                   	ret    

00103542 <_ZN6detail12TerminalImpl12show_historyEi>:

void detail::TerminalImpl::show_history(int page)
{
  103542:	53                   	push   %ebx
  103543:	83 ec 18             	sub    $0x18,%esp
    if (page < 0) page = 0;
  103546:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  10354b:	79 08                	jns    103555 <_ZN6detail12TerminalImpl12show_historyEi+0x13>
  10354d:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  103554:	00 

    if (page > history.size() - vga_height)
  103555:	8b 44 24 20          	mov    0x20(%esp),%eax
  103559:	83 c0 10             	add    $0x10,%eax
  10355c:	83 ec 0c             	sub    $0xc,%esp
  10355f:	50                   	push   %eax
  103560:	e8 2d 43 00 00       	call   107892 <_ZNK14CircularBufferIA80_tLm250EE4sizeEv>
  103565:	83 c4 10             	add    $0x10,%esp
  103568:	8d 50 e7             	lea    -0x19(%eax),%edx
  10356b:	8b 44 24 24          	mov    0x24(%esp),%eax
  10356f:	39 c2                	cmp    %eax,%edx
  103571:	0f 92 c0             	setb   %al
  103574:	84 c0                	test   %al,%al
  103576:	74 1a                	je     103592 <_ZN6detail12TerminalImpl12show_historyEi+0x50>
    {
        page = history.size() - vga_height; // avoir un plafond, une limite
  103578:	8b 44 24 20          	mov    0x20(%esp),%eax
  10357c:	83 c0 10             	add    $0x10,%eax
  10357f:	83 ec 0c             	sub    $0xc,%esp
  103582:	50                   	push   %eax
  103583:	e8 0a 43 00 00       	call   107892 <_ZNK14CircularBufferIA80_tLm250EE4sizeEv>
  103588:	83 c4 10             	add    $0x10,%esp
  10358b:	83 e8 19             	sub    $0x19,%eax
  10358e:	89 44 24 24          	mov    %eax,0x24(%esp)
    }

    current_history_page = page;
  103592:	8b 44 24 24          	mov    0x24(%esp),%eax
  103596:	89 c2                	mov    %eax,%edx
  103598:	8b 44 24 20          	mov    0x20(%esp),%eax
  10359c:	88 90 58 9c 00 00    	mov    %dl,0x9c58(%eax)

    for (size_t i { 0 }; i < vga_height-1; ++i) // ignore first line where everything is typed
  1035a2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1035a9:	00 
  1035aa:	83 7c 24 0c 17       	cmpl   $0x17,0xc(%esp)
  1035af:	0f 87 9f 00 00 00    	ja     103654 <_ZN6detail12TerminalImpl12show_historyEi+0x112>
    {
        for (size_t j { 0 }; j < vga_width; ++j)
  1035b5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1035bc:	00 
  1035bd:	83 7c 24 08 4f       	cmpl   $0x4f,0x8(%esp)
  1035c2:	0f 87 82 00 00 00    	ja     10364a <_ZN6detail12TerminalImpl12show_historyEi+0x108>
        {
            int index = history.size() - (vga_height-i) -page;
  1035c8:	8b 44 24 20          	mov    0x20(%esp),%eax
  1035cc:	83 c0 10             	add    $0x10,%eax
  1035cf:	83 ec 0c             	sub    $0xc,%esp
  1035d2:	50                   	push   %eax
  1035d3:	e8 ba 42 00 00       	call   107892 <_ZNK14CircularBufferIA80_tLm250EE4sizeEv>
  1035d8:	83 c4 10             	add    $0x10,%esp
  1035db:	89 c2                	mov    %eax,%edx
  1035dd:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1035e1:	01 c2                	add    %eax,%edx
  1035e3:	8b 44 24 24          	mov    0x24(%esp),%eax
  1035e7:	29 c2                	sub    %eax,%edx
  1035e9:	89 d0                	mov    %edx,%eax
  1035eb:	83 e8 19             	sub    $0x19,%eax
  1035ee:	89 44 24 04          	mov    %eax,0x4(%esp)
            if (index >= 0)
  1035f2:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  1035f7:	78 47                	js     103640 <_ZN6detail12TerminalImpl12show_historyEi+0xfe>
            {
                terminal_buffer[i*vga_width+j] = history[index][j];
  1035f9:	8b 44 24 20          	mov    0x20(%esp),%eax
  1035fd:	8d 50 10             	lea    0x10(%eax),%edx
  103600:	8b 44 24 04          	mov    0x4(%esp),%eax
  103604:	83 ec 08             	sub    $0x8,%esp
  103607:	50                   	push   %eax
  103608:	52                   	push   %edx
  103609:	e8 a4 42 00 00       	call   1078b2 <_ZN14CircularBufferIA80_tLm250EEixEm>
  10360e:	83 c4 10             	add    $0x10,%esp
  103611:	89 c3                	mov    %eax,%ebx
  103613:	8b 44 24 20          	mov    0x20(%esp),%eax
  103617:	8b 48 0c             	mov    0xc(%eax),%ecx
  10361a:	8b 54 24 0c          	mov    0xc(%esp),%edx
  10361e:	89 d0                	mov    %edx,%eax
  103620:	c1 e0 02             	shl    $0x2,%eax
  103623:	01 d0                	add    %edx,%eax
  103625:	c1 e0 04             	shl    $0x4,%eax
  103628:	89 c2                	mov    %eax,%edx
  10362a:	8b 44 24 08          	mov    0x8(%esp),%eax
  10362e:	01 d0                	add    %edx,%eax
  103630:	01 c0                	add    %eax,%eax
  103632:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  103635:	8b 44 24 08          	mov    0x8(%esp),%eax
  103639:	0f b7 04 43          	movzwl (%ebx,%eax,2),%eax
  10363d:	66 89 02             	mov    %ax,(%edx)
        for (size_t j { 0 }; j < vga_width; ++j)
  103640:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
  103645:	e9 73 ff ff ff       	jmp    1035bd <_ZN6detail12TerminalImpl12show_historyEi+0x7b>
    for (size_t i { 0 }; i < vga_height-1; ++i) // ignore first line where everything is typed
  10364a:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
  10364f:	e9 56 ff ff ff       	jmp    1035aa <_ZN6detail12TerminalImpl12show_historyEi+0x68>
            }
        }
    }
}
  103654:	90                   	nop
  103655:	83 c4 18             	add    $0x18,%esp
  103658:	5b                   	pop    %ebx
  103659:	c3                   	ret    

0010365a <_ZN6detail12TerminalImpl8new_lineEv>:

void detail::TerminalImpl::new_line()
{
  10365a:	83 ec 0c             	sub    $0xc,%esp
    add_line_to_history();
  10365d:	83 ec 0c             	sub    $0xc,%esp
  103660:	ff 74 24 1c          	pushl  0x1c(%esp)
  103664:	e8 23 00 00 00       	call   10368c <_ZN6detail12TerminalImpl19add_line_to_historyEv>
  103669:	83 c4 10             	add    $0x10,%esp
    terminal_column = 0;
  10366c:	8b 44 24 10          	mov    0x10(%esp),%eax
  103670:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    ++terminal_row;
  103677:	8b 44 24 10          	mov    0x10(%esp),%eax
  10367b:	8b 00                	mov    (%eax),%eax
  10367d:	8d 50 01             	lea    0x1(%eax),%edx
  103680:	8b 44 24 10          	mov    0x10(%esp),%eax
  103684:	89 10                	mov    %edx,(%eax)
}
  103686:	90                   	nop
  103687:	83 c4 0c             	add    $0xc,%esp
  10368a:	c3                   	ret    
  10368b:	90                   	nop

0010368c <_ZN6detail12TerminalImpl19add_line_to_historyEv>:

void detail::TerminalImpl::add_line_to_history()
{
  10368c:	81 ec bc 00 00 00    	sub    $0xbc,%esp
    uint16_t line[vga_width];
    for (size_t i { 0 }; i < vga_width; ++i)
  103692:	c7 84 24 ac 00 00 00 	movl   $0x0,0xac(%esp)
  103699:	00 00 00 00 
  10369d:	83 bc 24 ac 00 00 00 	cmpl   $0x4f,0xac(%esp)
  1036a4:	4f 
  1036a5:	77 45                	ja     1036ec <_ZN6detail12TerminalImpl19add_line_to_historyEv+0x60>
    {
        line[i] = terminal_buffer[terminal_row*vga_width + i];
  1036a7:	8b 84 24 c0 00 00 00 	mov    0xc0(%esp),%eax
  1036ae:	8b 48 0c             	mov    0xc(%eax),%ecx
  1036b1:	8b 84 24 c0 00 00 00 	mov    0xc0(%esp),%eax
  1036b8:	8b 10                	mov    (%eax),%edx
  1036ba:	89 d0                	mov    %edx,%eax
  1036bc:	c1 e0 02             	shl    $0x2,%eax
  1036bf:	01 d0                	add    %edx,%eax
  1036c1:	c1 e0 04             	shl    $0x4,%eax
  1036c4:	89 c2                	mov    %eax,%edx
  1036c6:	8b 84 24 ac 00 00 00 	mov    0xac(%esp),%eax
  1036cd:	01 d0                	add    %edx,%eax
  1036cf:	01 c0                	add    %eax,%eax
  1036d1:	01 c8                	add    %ecx,%eax
  1036d3:	0f b7 10             	movzwl (%eax),%edx
  1036d6:	8b 84 24 ac 00 00 00 	mov    0xac(%esp),%eax
  1036dd:	66 89 54 44 0c       	mov    %dx,0xc(%esp,%eax,2)
    for (size_t i { 0 }; i < vga_width; ++i)
  1036e2:	83 84 24 ac 00 00 00 	addl   $0x1,0xac(%esp)
  1036e9:	01 
  1036ea:	eb b1                	jmp    10369d <_ZN6detail12TerminalImpl19add_line_to_historyEv+0x11>
    }
    history.add(line);
  1036ec:	8b 84 24 c0 00 00 00 	mov    0xc0(%esp),%eax
  1036f3:	8d 50 10             	lea    0x10(%eax),%edx
  1036f6:	83 ec 08             	sub    $0x8,%esp
  1036f9:	8d 44 24 14          	lea    0x14(%esp),%eax
  1036fd:	50                   	push   %eax
  1036fe:	52                   	push   %edx
  1036ff:	e8 ce 41 00 00       	call   1078d2 <_ZN14CircularBufferIA80_tLm250EE3addERA80_Kt>
  103704:	83 c4 10             	add    $0x10,%esp
}
  103707:	90                   	nop
  103708:	81 c4 bc 00 00 00    	add    $0xbc,%esp
  10370e:	c3                   	ret    
  10370f:	90                   	nop

00103710 <_ZN6detail12TerminalImpl9check_posEv>:

void detail::TerminalImpl::check_pos()
{
  103710:	83 ec 0c             	sub    $0xc,%esp
    if (terminal_column >= vga_width)
  103713:	8b 44 24 10          	mov    0x10(%esp),%eax
  103717:	8b 40 04             	mov    0x4(%eax),%eax
  10371a:	83 f8 4f             	cmp    $0x4f,%eax
  10371d:	76 46                	jbe    103765 <_ZN6detail12TerminalImpl9check_posEv+0x55>
    {
        terminal_column = terminal_column%vga_width;
  10371f:	8b 44 24 10          	mov    0x10(%esp),%eax
  103723:	8b 48 04             	mov    0x4(%eax),%ecx
  103726:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
  10372b:	89 c8                	mov    %ecx,%eax
  10372d:	f7 e2                	mul    %edx
  10372f:	c1 ea 06             	shr    $0x6,%edx
  103732:	89 d0                	mov    %edx,%eax
  103734:	c1 e0 02             	shl    $0x2,%eax
  103737:	01 d0                	add    %edx,%eax
  103739:	c1 e0 04             	shl    $0x4,%eax
  10373c:	29 c1                	sub    %eax,%ecx
  10373e:	89 ca                	mov    %ecx,%edx
  103740:	8b 44 24 10          	mov    0x10(%esp),%eax
  103744:	89 50 04             	mov    %edx,0x4(%eax)
        add_line_to_history();
  103747:	83 ec 0c             	sub    $0xc,%esp
  10374a:	ff 74 24 1c          	pushl  0x1c(%esp)
  10374e:	e8 39 ff ff ff       	call   10368c <_ZN6detail12TerminalImpl19add_line_to_historyEv>
  103753:	83 c4 10             	add    $0x10,%esp
        ++terminal_row;
  103756:	8b 44 24 10          	mov    0x10(%esp),%eax
  10375a:	8b 00                	mov    (%eax),%eax
  10375c:	8d 50 01             	lea    0x1(%eax),%edx
  10375f:	8b 44 24 10          	mov    0x10(%esp),%eax
  103763:	89 10                	mov    %edx,(%eax)
    }
    if (terminal_row >= vga_height)
  103765:	8b 44 24 10          	mov    0x10(%esp),%eax
  103769:	8b 00                	mov    (%eax),%eax
  10376b:	83 f8 18             	cmp    $0x18,%eax
  10376e:	76 19                	jbe    103789 <_ZN6detail12TerminalImpl9check_posEv+0x79>
    {
        scroll_up();
  103770:	83 ec 0c             	sub    $0xc,%esp
  103773:	ff 74 24 1c          	pushl  0x1c(%esp)
  103777:	e8 be fc ff ff       	call   10343a <_ZN6detail12TerminalImpl9scroll_upEv>
  10377c:	83 c4 10             	add    $0x10,%esp
        terminal_row = vga_height-1;
  10377f:	8b 44 24 10          	mov    0x10(%esp),%eax
  103783:	c7 00 18 00 00 00    	movl   $0x18,(%eax)
    }

    update_cursor();
  103789:	83 ec 0c             	sub    $0xc,%esp
  10378c:	ff 74 24 1c          	pushl  0x1c(%esp)
  103790:	e8 9d 00 00 00       	call   103832 <_ZN6detail12TerminalImpl13update_cursorEv>
  103795:	83 c4 10             	add    $0x10,%esp
}
  103798:	90                   	nop
  103799:	83 c4 0c             	add    $0xc,%esp
  10379c:	c3                   	ret    
  10379d:	90                   	nop

0010379e <_ZN6detail12TerminalImpl11move_cursorEmm>:

void detail::TerminalImpl::move_cursor(size_t x, size_t y)
{
  10379e:	83 ec 1c             	sub    $0x1c,%esp
    const size_t index = y * vga_width + x;
  1037a1:	8b 54 24 28          	mov    0x28(%esp),%edx
  1037a5:	89 d0                	mov    %edx,%eax
  1037a7:	c1 e0 02             	shl    $0x2,%eax
  1037aa:	01 d0                	add    %edx,%eax
  1037ac:	c1 e0 04             	shl    $0x4,%eax
  1037af:	89 c2                	mov    %eax,%edx
  1037b1:	8b 44 24 24          	mov    0x24(%esp),%eax
  1037b5:	01 d0                	add    %edx,%eax
  1037b7:	89 44 24 0c          	mov    %eax,0xc(%esp)

    const uint16_t port_low = BDA::video_io_port();
  1037bb:	e8 b6 03 00 00       	call   103b76 <_ZN3BDA13video_io_portEv>
  1037c0:	66 89 44 24 0a       	mov    %ax,0xa(%esp)
    const uint16_t port_high = port_low + 1;
  1037c5:	0f b7 44 24 0a       	movzwl 0xa(%esp),%eax
  1037ca:	83 c0 01             	add    $0x1,%eax
  1037cd:	66 89 44 24 08       	mov    %ax,0x8(%esp)

    // cursor LOW port to vga INDEX register
    outb(port_low, 0x0F);
  1037d2:	0f b7 44 24 0a       	movzwl 0xa(%esp),%eax
  1037d7:	83 ec 08             	sub    $0x8,%esp
  1037da:	6a 0f                	push   $0xf
  1037dc:	50                   	push   %eax
  1037dd:	e8 19 ea ff ff       	call   1021fb <_Z4outbth>
  1037e2:	83 c4 10             	add    $0x10,%esp
    outb(port_high, (uint8_t)(index&0xFF));
  1037e5:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1037e9:	0f b6 d0             	movzbl %al,%edx
  1037ec:	0f b7 44 24 08       	movzwl 0x8(%esp),%eax
  1037f1:	83 ec 08             	sub    $0x8,%esp
  1037f4:	52                   	push   %edx
  1037f5:	50                   	push   %eax
  1037f6:	e8 00 ea ff ff       	call   1021fb <_Z4outbth>
  1037fb:	83 c4 10             	add    $0x10,%esp

    // cursor HIGH port to vga INDEX register
    outb(port_low, 0x0E);
  1037fe:	0f b7 44 24 0a       	movzwl 0xa(%esp),%eax
  103803:	83 ec 08             	sub    $0x8,%esp
  103806:	6a 0e                	push   $0xe
  103808:	50                   	push   %eax
  103809:	e8 ed e9 ff ff       	call   1021fb <_Z4outbth>
  10380e:	83 c4 10             	add    $0x10,%esp
    outb(port_high, (uint8_t)((index>>8)&0xFF));
  103811:	8b 44 24 0c          	mov    0xc(%esp),%eax
  103815:	c1 e8 08             	shr    $0x8,%eax
  103818:	0f b6 d0             	movzbl %al,%edx
  10381b:	0f b7 44 24 08       	movzwl 0x8(%esp),%eax
  103820:	83 ec 08             	sub    $0x8,%esp
  103823:	52                   	push   %edx
  103824:	50                   	push   %eax
  103825:	e8 d1 e9 ff ff       	call   1021fb <_Z4outbth>
  10382a:	83 c4 10             	add    $0x10,%esp
}
  10382d:	90                   	nop
  10382e:	83 c4 1c             	add    $0x1c,%esp
  103831:	c3                   	ret    

00103832 <_ZN6detail12TerminalImpl13update_cursorEv>:

void detail::TerminalImpl::update_cursor()
{
  103832:	83 ec 0c             	sub    $0xc,%esp
    move_cursor(terminal_column, terminal_row);
  103835:	8b 44 24 10          	mov    0x10(%esp),%eax
  103839:	8b 10                	mov    (%eax),%edx
  10383b:	8b 44 24 10          	mov    0x10(%esp),%eax
  10383f:	8b 40 04             	mov    0x4(%eax),%eax
  103842:	83 ec 04             	sub    $0x4,%esp
  103845:	52                   	push   %edx
  103846:	50                   	push   %eax
  103847:	ff 74 24 1c          	pushl  0x1c(%esp)
  10384b:	e8 4e ff ff ff       	call   10379e <_ZN6detail12TerminalImpl11move_cursorEmm>
  103850:	83 c4 10             	add    $0x10,%esp
}
  103853:	90                   	nop
  103854:	83 c4 0c             	add    $0xc,%esp
  103857:	c3                   	ret    

00103858 <_Z41__static_initialization_and_destruction_0ii>:
  103858:	83 ec 0c             	sub    $0xc,%esp
  10385b:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  103860:	75 2e                	jne    103890 <_Z41__static_initialization_and_destruction_0ii+0x38>
  103862:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  103869:	00 
  10386a:	75 24                	jne    103890 <_Z41__static_initialization_and_destruction_0ii+0x38>
    static inline detail::TerminalImpl impl;
  10386c:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  103871:	0f b6 00             	movzbl (%eax),%eax
  103874:	84 c0                	test   %al,%al
  103876:	75 18                	jne    103890 <_Z41__static_initialization_and_destruction_0ii+0x38>
  103878:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  10387d:	c6 00 01             	movb   $0x1,(%eax)
  103880:	83 ec 0c             	sub    $0xc,%esp
  103883:	68 60 53 11 00       	push   $0x115360
  103888:	e8 ad f8 ff ff       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  10388d:	83 c4 10             	add    $0x10,%esp
  103890:	90                   	nop
  103891:	83 c4 0c             	add    $0xc,%esp
  103894:	c3                   	ret    

00103895 <_GLOBAL__sub_I__ZN6detail12TerminalImplC2Ev>:
  103895:	83 ec 0c             	sub    $0xc,%esp
  103898:	83 ec 08             	sub    $0x8,%esp
  10389b:	68 ff ff 00 00       	push   $0xffff
  1038a0:	6a 01                	push   $0x1
  1038a2:	e8 b1 ff ff ff       	call   103858 <_Z41__static_initialization_and_destruction_0ii>
  1038a7:	83 c4 10             	add    $0x10,%esp
  1038aa:	83 c4 0c             	add    $0xc,%esp
  1038ad:	c3                   	ret    

001038ae <__cxa_guard_acquire>:
        extern "C" void __cxa_guard_release (__guard *);
        extern "C" void __cxa_guard_abort (__guard *);

        extern "C" int __cxa_guard_acquire (__guard *g)
        {
                return !*(char *)(g);
  1038ae:	8b 44 24 04          	mov    0x4(%esp),%eax
  1038b2:	0f b6 00             	movzbl (%eax),%eax
  1038b5:	84 c0                	test   %al,%al
  1038b7:	0f 94 c0             	sete   %al
  1038ba:	0f b6 c0             	movzbl %al,%eax
        }
  1038bd:	c3                   	ret    

001038be <__cxa_guard_release>:

        extern "C" void __cxa_guard_release (__guard *g)
        {
                *(char *)g = 1;
  1038be:	8b 44 24 04          	mov    0x4(%esp),%eax
  1038c2:	c6 00 01             	movb   $0x1,(%eax)
        }
  1038c5:	90                   	nop
  1038c6:	c3                   	ret    

001038c7 <__cxa_guard_abort>:

        extern "C" void __cxa_guard_abort (__guard *)
        {

        }
  1038c7:	90                   	nop
  1038c8:	c3                   	ret    

001038c9 <__cxa_atexit>:
atexit_func_entry_t __atexit_funcs[ATEXIT_MAX_FUNCS];
uarch_t __atexit_func_count = 0;

int __cxa_atexit(void (*f)(void *), void *objptr, void *dso)
{
    if (__atexit_func_count >= ATEXIT_MAX_FUNCS) {return -1;};
  1038c9:	a1 20 53 11 00       	mov    0x115320,%eax
  1038ce:	83 f8 7f             	cmp    $0x7f,%eax
  1038d1:	76 06                	jbe    1038d9 <__cxa_atexit+0x10>
  1038d3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  1038d8:	c3                   	ret    
    __atexit_funcs[__atexit_func_count].destructor_func = f;
  1038d9:	8b 15 20 53 11 00    	mov    0x115320,%edx
  1038df:	89 d0                	mov    %edx,%eax
  1038e1:	01 c0                	add    %eax,%eax
  1038e3:	01 d0                	add    %edx,%eax
  1038e5:	c1 e0 02             	shl    $0x2,%eax
  1038e8:	8d 90 20 4d 11 00    	lea    0x114d20(%eax),%edx
  1038ee:	8b 44 24 04          	mov    0x4(%esp),%eax
  1038f2:	89 02                	mov    %eax,(%edx)
    __atexit_funcs[__atexit_func_count].obj_ptr = objptr;
  1038f4:	8b 15 20 53 11 00    	mov    0x115320,%edx
  1038fa:	89 d0                	mov    %edx,%eax
  1038fc:	01 c0                	add    %eax,%eax
  1038fe:	01 d0                	add    %edx,%eax
  103900:	c1 e0 02             	shl    $0x2,%eax
  103903:	8d 90 24 4d 11 00    	lea    0x114d24(%eax),%edx
  103909:	8b 44 24 08          	mov    0x8(%esp),%eax
  10390d:	89 02                	mov    %eax,(%edx)
    __atexit_funcs[__atexit_func_count].dso_handle = dso;
  10390f:	8b 15 20 53 11 00    	mov    0x115320,%edx
  103915:	89 d0                	mov    %edx,%eax
  103917:	01 c0                	add    %eax,%eax
  103919:	01 d0                	add    %edx,%eax
  10391b:	c1 e0 02             	shl    $0x2,%eax
  10391e:	8d 90 28 4d 11 00    	lea    0x114d28(%eax),%edx
  103924:	8b 44 24 0c          	mov    0xc(%esp),%eax
  103928:	89 02                	mov    %eax,(%edx)
    __atexit_func_count++;
  10392a:	a1 20 53 11 00       	mov    0x115320,%eax
  10392f:	83 c0 01             	add    $0x1,%eax
  103932:	a3 20 53 11 00       	mov    %eax,0x115320
    return 0;
  103937:	b8 00 00 00 00       	mov    $0x0,%eax
};
  10393c:	c3                   	ret    

0010393d <__cxa_finalize>:

void __cxa_finalize(void *f)
{
  10393d:	83 ec 1c             	sub    $0x1c,%esp
    uarch_t i = __atexit_func_count;
  103940:	a1 20 53 11 00       	mov    0x115320,%eax
  103945:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (!f)
  103949:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  10394e:	75 63                	jne    1039b3 <__cxa_finalize+0x76>
                * an object file exist at runtime in a particular application. This can be used to tell
                * when a shared object is no longer in use. It is one of many methods, however.
                **/
        //You may insert a printf() here to tell you whether or not the function gets called. Testing
        //is CRITICAL!
        while (i--)
  103950:	8b 44 24 0c          	mov    0xc(%esp),%eax
  103954:	8d 50 ff             	lea    -0x1(%eax),%edx
  103957:	89 54 24 0c          	mov    %edx,0xc(%esp)
  10395b:	85 c0                	test   %eax,%eax
  10395d:	0f 95 c0             	setne  %al
  103960:	84 c0                	test   %al,%al
  103962:	0f 84 c4 00 00 00    	je     103a2c <__cxa_finalize+0xef>
        {
            if (__atexit_funcs[i].destructor_func)
  103968:	8b 54 24 0c          	mov    0xc(%esp),%edx
  10396c:	89 d0                	mov    %edx,%eax
  10396e:	01 c0                	add    %eax,%eax
  103970:	01 d0                	add    %edx,%eax
  103972:	c1 e0 02             	shl    $0x2,%eax
  103975:	05 20 4d 11 00       	add    $0x114d20,%eax
  10397a:	8b 00                	mov    (%eax),%eax
  10397c:	85 c0                	test   %eax,%eax
  10397e:	74 d0                	je     103950 <__cxa_finalize+0x13>
                                *
                                * In a virtual environment, the kernel will receive a page fault, and then probably
                                * map in some trash, or a blank page, or something stupid like that.
                                * This will result in the processor executing trash, and...we don't want that.
                                **/
                (*__atexit_funcs[i].destructor_func)(__atexit_funcs[i].obj_ptr);
  103980:	8b 54 24 0c          	mov    0xc(%esp),%edx
  103984:	89 d0                	mov    %edx,%eax
  103986:	01 c0                	add    %eax,%eax
  103988:	01 d0                	add    %edx,%eax
  10398a:	c1 e0 02             	shl    $0x2,%eax
  10398d:	05 20 4d 11 00       	add    $0x114d20,%eax
  103992:	8b 08                	mov    (%eax),%ecx
  103994:	8b 54 24 0c          	mov    0xc(%esp),%edx
  103998:	89 d0                	mov    %edx,%eax
  10399a:	01 c0                	add    %eax,%eax
  10399c:	01 d0                	add    %edx,%eax
  10399e:	c1 e0 02             	shl    $0x2,%eax
  1039a1:	05 24 4d 11 00       	add    $0x114d24,%eax
  1039a6:	8b 00                	mov    (%eax),%eax
  1039a8:	83 ec 0c             	sub    $0xc,%esp
  1039ab:	50                   	push   %eax
  1039ac:	ff d1                	call   *%ecx
  1039ae:	83 c4 10             	add    $0x10,%esp
        while (i--)
  1039b1:	eb 9d                	jmp    103950 <__cxa_finalize+0x13>
            };
        };
        return;
    };

    while (i--)
  1039b3:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1039b7:	8d 50 ff             	lea    -0x1(%eax),%edx
  1039ba:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1039be:	85 c0                	test   %eax,%eax
  1039c0:	0f 95 c0             	setne  %al
  1039c3:	84 c0                	test   %al,%al
  1039c5:	74 66                	je     103a2d <__cxa_finalize+0xf0>
                * at the end of the table. So, we have holes with our current algorithm
                * This function should be modified to move all the destructors above the one currently
                * being called and removed one place down in the list, so as to cover up the hole.
                * Otherwise, whenever a destructor is called and removed, an entire space in the table is wasted.
                **/
        if (__atexit_funcs[i].destructor_func == f)
  1039c7:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1039cb:	89 d0                	mov    %edx,%eax
  1039cd:	01 c0                	add    %eax,%eax
  1039cf:	01 d0                	add    %edx,%eax
  1039d1:	c1 e0 02             	shl    $0x2,%eax
  1039d4:	05 20 4d 11 00       	add    $0x114d20,%eax
  1039d9:	8b 00                	mov    (%eax),%eax
  1039db:	39 44 24 20          	cmp    %eax,0x20(%esp)
  1039df:	75 d2                	jne    1039b3 <__cxa_finalize+0x76>
                        * a C function in the table with the address of some structure containing data about
                        * what to clean up on exit.
                        * In the case of a function that takes no arguments, it will simply be ignore within the
                        * function itself. No worries.
                        **/
            (*__atexit_funcs[i].destructor_func)(__atexit_funcs[i].obj_ptr);
  1039e1:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1039e5:	89 d0                	mov    %edx,%eax
  1039e7:	01 c0                	add    %eax,%eax
  1039e9:	01 d0                	add    %edx,%eax
  1039eb:	c1 e0 02             	shl    $0x2,%eax
  1039ee:	05 20 4d 11 00       	add    $0x114d20,%eax
  1039f3:	8b 08                	mov    (%eax),%ecx
  1039f5:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1039f9:	89 d0                	mov    %edx,%eax
  1039fb:	01 c0                	add    %eax,%eax
  1039fd:	01 d0                	add    %edx,%eax
  1039ff:	c1 e0 02             	shl    $0x2,%eax
  103a02:	05 24 4d 11 00       	add    $0x114d24,%eax
  103a07:	8b 00                	mov    (%eax),%eax
  103a09:	83 ec 0c             	sub    $0xc,%esp
  103a0c:	50                   	push   %eax
  103a0d:	ff d1                	call   *%ecx
  103a0f:	83 c4 10             	add    $0x10,%esp
            __atexit_funcs[i].destructor_func = 0;
  103a12:	8b 54 24 0c          	mov    0xc(%esp),%edx
  103a16:	89 d0                	mov    %edx,%eax
  103a18:	01 c0                	add    %eax,%eax
  103a1a:	01 d0                	add    %edx,%eax
  103a1c:	c1 e0 02             	shl    $0x2,%eax
  103a1f:	05 20 4d 11 00       	add    $0x114d20,%eax
  103a24:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    while (i--)
  103a2a:	eb 87                	jmp    1039b3 <__cxa_finalize+0x76>
        return;
  103a2c:	90                   	nop
                        * Notice that we didn't decrement __atexit_func_count: this is because this algorithm
                        * requires patching to deal with the \FIXME outlined above.
                        **/
        };
    };
};
  103a2d:	83 c4 1c             	add    $0x1c,%esp
  103a30:	c3                   	ret    

00103a31 <__cxa_pure_virtual>:
*/

#include "panic.hpp"

extern "C" void __cxa_pure_virtual()
{
  103a31:	83 ec 0c             	sub    $0xc,%esp
    panic("Pure virtual function called !");
  103a34:	83 ec 0c             	sub    $0xc,%esp
  103a37:	68 b4 9b 10 00       	push   $0x109bb4
  103a3c:	e8 c1 0f 00 00       	call   104a02 <_Z5panicPKcz>

00103a41 <_ZN3BDA9com1_portEv>:

#include "bda.hpp"
#include "utils/addr.hpp"

uint16_t BDA::com1_port()
{
  103a41:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint16_t*>(phys(0x0400));
  103a44:	83 ec 0c             	sub    $0xc,%esp
  103a47:	68 00 04 00 00       	push   $0x400
  103a4c:	e8 ee 3b 00 00       	call   10763f <_Z4physm>
  103a51:	83 c4 10             	add    $0x10,%esp
  103a54:	0f b7 00             	movzwl (%eax),%eax
}
  103a57:	83 c4 0c             	add    $0xc,%esp
  103a5a:	c3                   	ret    

00103a5b <_ZN3BDA9com2_portEv>:

uint16_t BDA::com2_port()
{
  103a5b:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint16_t*>(phys(0x0402));
  103a5e:	83 ec 0c             	sub    $0xc,%esp
  103a61:	68 02 04 00 00       	push   $0x402
  103a66:	e8 d4 3b 00 00       	call   10763f <_Z4physm>
  103a6b:	83 c4 10             	add    $0x10,%esp
  103a6e:	0f b7 00             	movzwl (%eax),%eax
}
  103a71:	83 c4 0c             	add    $0xc,%esp
  103a74:	c3                   	ret    

00103a75 <_ZN3BDA9com3_portEv>:

uint16_t BDA::com3_port()
{
  103a75:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint16_t*>(phys(0x0404));
  103a78:	83 ec 0c             	sub    $0xc,%esp
  103a7b:	68 04 04 00 00       	push   $0x404
  103a80:	e8 ba 3b 00 00       	call   10763f <_Z4physm>
  103a85:	83 c4 10             	add    $0x10,%esp
  103a88:	0f b7 00             	movzwl (%eax),%eax
}
  103a8b:	83 c4 0c             	add    $0xc,%esp
  103a8e:	c3                   	ret    

00103a8f <_ZN3BDA9com4_portEv>:

uint16_t BDA::com4_port()
{
  103a8f:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint16_t*>(phys(0x0406));
  103a92:	83 ec 0c             	sub    $0xc,%esp
  103a95:	68 06 04 00 00       	push   $0x406
  103a9a:	e8 a0 3b 00 00       	call   10763f <_Z4physm>
  103a9f:	83 c4 10             	add    $0x10,%esp
  103aa2:	0f b7 00             	movzwl (%eax),%eax
}
  103aa5:	83 c4 0c             	add    $0xc,%esp
  103aa8:	c3                   	ret    

00103aa9 <_ZN3BDA9lpt1_portEv>:


uint16_t BDA::lpt1_port()
{
  103aa9:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint16_t*>(phys(0x0408));
  103aac:	83 ec 0c             	sub    $0xc,%esp
  103aaf:	68 08 04 00 00       	push   $0x408
  103ab4:	e8 86 3b 00 00       	call   10763f <_Z4physm>
  103ab9:	83 c4 10             	add    $0x10,%esp
  103abc:	0f b7 00             	movzwl (%eax),%eax
}
  103abf:	83 c4 0c             	add    $0xc,%esp
  103ac2:	c3                   	ret    

00103ac3 <_ZN3BDA9lpt2_portEv>:

uint16_t BDA::lpt2_port()
{
  103ac3:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint16_t*>(phys(0x040A));
  103ac6:	83 ec 0c             	sub    $0xc,%esp
  103ac9:	68 0a 04 00 00       	push   $0x40a
  103ace:	e8 6c 3b 00 00       	call   10763f <_Z4physm>
  103ad3:	83 c4 10             	add    $0x10,%esp
  103ad6:	0f b7 00             	movzwl (%eax),%eax
}
  103ad9:	83 c4 0c             	add    $0xc,%esp
  103adc:	c3                   	ret    

00103add <_ZN3BDA9lpt3_portEv>:

uint16_t BDA::lpt3_port()
{
  103add:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint16_t*>(phys(0x040C));
  103ae0:	83 ec 0c             	sub    $0xc,%esp
  103ae3:	68 0c 04 00 00       	push   $0x40c
  103ae8:	e8 52 3b 00 00       	call   10763f <_Z4physm>
  103aed:	83 c4 10             	add    $0x10,%esp
  103af0:	0f b7 00             	movzwl (%eax),%eax
}
  103af3:	83 c4 0c             	add    $0xc,%esp
  103af6:	c3                   	ret    

00103af7 <_ZN3BDA10equipementEv>:

uint16_t BDA::equipement()
{
  103af7:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint16_t*>(phys(0x0410));
  103afa:	83 ec 0c             	sub    $0xc,%esp
  103afd:	68 10 04 00 00       	push   $0x410
  103b02:	e8 38 3b 00 00       	call   10763f <_Z4physm>
  103b07:	83 c4 10             	add    $0x10,%esp
  103b0a:	0f b7 00             	movzwl (%eax),%eax
}
  103b0d:	83 c4 0c             	add    $0xc,%esp
  103b10:	c3                   	ret    

00103b11 <_ZN3BDA9kbd_stateEv>:

uint16_t BDA::kbd_state()
{
  103b11:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint16_t*>(phys(0x0417));
  103b14:	83 ec 0c             	sub    $0xc,%esp
  103b17:	68 17 04 00 00       	push   $0x417
  103b1c:	e8 1e 3b 00 00       	call   10763f <_Z4physm>
  103b21:	83 c4 10             	add    $0x10,%esp
  103b24:	0f b7 00             	movzwl (%eax),%eax
}
  103b27:	83 c4 0c             	add    $0xc,%esp
  103b2a:	c3                   	ret    

00103b2b <_ZN3BDA10kbd_bufferEv>:

uint8_t *BDA::kbd_buffer()
{
  103b2b:	83 ec 0c             	sub    $0xc,%esp
    return  reinterpret_cast<uint8_t*>(phys(0x041E));
  103b2e:	83 ec 0c             	sub    $0xc,%esp
  103b31:	68 1e 04 00 00       	push   $0x41e
  103b36:	e8 04 3b 00 00       	call   10763f <_Z4physm>
  103b3b:	83 c4 10             	add    $0x10,%esp
}
  103b3e:	83 c4 0c             	add    $0xc,%esp
  103b41:	c3                   	ret    

00103b42 <_ZN3BDA9disp_modeEv>:

uint8_t BDA::disp_mode()
{
  103b42:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint8_t*>(phys(0x0449));
  103b45:	83 ec 0c             	sub    $0xc,%esp
  103b48:	68 49 04 00 00       	push   $0x449
  103b4d:	e8 ed 3a 00 00       	call   10763f <_Z4physm>
  103b52:	83 c4 10             	add    $0x10,%esp
  103b55:	0f b6 00             	movzbl (%eax),%eax
}
  103b58:	83 c4 0c             	add    $0xc,%esp
  103b5b:	c3                   	ret    

00103b5c <_ZN3BDA16txt_mode_columnsEv>:

uint16_t BDA::txt_mode_columns()
{
  103b5c:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint16_t*>(phys(0x044A));
  103b5f:	83 ec 0c             	sub    $0xc,%esp
  103b62:	68 4a 04 00 00       	push   $0x44a
  103b67:	e8 d3 3a 00 00       	call   10763f <_Z4physm>
  103b6c:	83 c4 10             	add    $0x10,%esp
  103b6f:	0f b7 00             	movzwl (%eax),%eax
}
  103b72:	83 c4 0c             	add    $0xc,%esp
  103b75:	c3                   	ret    

00103b76 <_ZN3BDA13video_io_portEv>:

uint16_t BDA::video_io_port()
{
  103b76:	83 ec 0c             	sub    $0xc,%esp
    return *reinterpret_cast<uint16_t*>(phys(0x0463));
  103b79:	83 ec 0c             	sub    $0xc,%esp
  103b7c:	68 63 04 00 00       	push   $0x463
  103b81:	e8 b9 3a 00 00       	call   10763f <_Z4physm>
  103b86:	83 c4 10             	add    $0x10,%esp
  103b89:	0f b7 00             	movzwl (%eax),%eax
}
  103b8c:	83 c4 0c             	add    $0xc,%esp
  103b8f:	c3                   	ret    

00103b90 <_ZN9multiboot5checkEmRK16multiboot_headerPK14multiboot_info>:

namespace multiboot
{

void check(uint32_t magic, const multiboot_header &mbd, const multiboot_info* mbd_info)
{
  103b90:	83 ec 0c             	sub    $0xc,%esp
    if (mbd.magic != MULTIBOOT_HEADER_MAGIC || magic != MULTIBOOT_BOOTLOADER_MAGIC)
  103b93:	8b 44 24 14          	mov    0x14(%esp),%eax
  103b97:	8b 00                	mov    (%eax),%eax
  103b99:	3d 02 b0 ad 1b       	cmp    $0x1badb002,%eax
  103b9e:	75 0a                	jne    103baa <_ZN9multiboot5checkEmRK16multiboot_headerPK14multiboot_info+0x1a>
  103ba0:	81 7c 24 10 02 b0 ad 	cmpl   $0x2badb002,0x10(%esp)
  103ba7:	2b 
  103ba8:	74 21                	je     103bcb <_ZN9multiboot5checkEmRK16multiboot_headerPK14multiboot_info+0x3b>
    {
        log("0x%x\n", magic);
  103baa:	83 ec 08             	sub    $0x8,%esp
  103bad:	ff 74 24 18          	pushl  0x18(%esp)
  103bb1:	68 e2 9b 10 00       	push   $0x109be2
  103bb6:	e8 6d 38 00 00       	call   107428 <_Z3logPKcz>
  103bbb:	83 c4 10             	add    $0x10,%esp
        panic("Multiboot2 Magic number is invalid ! Aborting");
  103bbe:	83 ec 0c             	sub    $0xc,%esp
  103bc1:	68 e8 9b 10 00       	push   $0x109be8
  103bc6:	e8 37 0e 00 00       	call   104a02 <_Z5panicPKcz>
        return;
    }
    if (reinterpret_cast<uintptr_t>(mbd_info) & 7)
  103bcb:	8b 44 24 18          	mov    0x18(%esp),%eax
  103bcf:	83 e0 07             	and    $0x7,%eax
  103bd2:	85 c0                	test   %eax,%eax
  103bd4:	74 16                	je     103bec <_ZN9multiboot5checkEmRK16multiboot_headerPK14multiboot_info+0x5c>
    {
        log("Unaligned mbi: 0x%x\n", reinterpret_cast<uintptr_t>(mbd_info));
  103bd6:	8b 44 24 18          	mov    0x18(%esp),%eax
  103bda:	83 ec 08             	sub    $0x8,%esp
  103bdd:	50                   	push   %eax
  103bde:	68 16 9c 10 00       	push   $0x109c16
  103be3:	e8 40 38 00 00       	call   107428 <_Z3logPKcz>
  103be8:	83 c4 10             	add    $0x10,%esp
        return;
  103beb:	90                   	nop
    }
}
  103bec:	83 c4 0c             	add    $0xc,%esp
  103bef:	c3                   	ret    

00103bf0 <_ZN9multiboot10parse_infoEPK14multiboot_info>:

void parse_info(const multiboot_info_t* info)
{
  103bf0:	83 ec 1c             	sub    $0x1c,%esp
    Meminfo::info = info;
  103bf3:	8b 44 24 20          	mov    0x20(%esp),%eax
  103bf7:	a3 cc ef 11 00       	mov    %eax,0x11efcc
    //printf("Multiboot flags : 0x%x\n", info->flags);
    if (CHECK_FLAG(info->flags, 1))
    {
    //    printf("Boot device : 0x%x\n", info->boot_device);
    }
    if (CHECK_FLAG(info->flags, 2))
  103bfc:	8b 44 24 20          	mov    0x20(%esp),%eax
  103c00:	8b 00                	mov    (%eax),%eax
  103c02:	83 e0 04             	and    $0x4,%eax
  103c05:	85 c0                	test   %eax,%eax
  103c07:	74 24                	je     103c2d <_ZN9multiboot10parse_infoEPK14multiboot_info+0x3d>
    {
        log("Command line : '%s'\n", reinterpret_cast<char*>(phys(info->cmdline)));
  103c09:	8b 44 24 20          	mov    0x20(%esp),%eax
  103c0d:	8b 40 10             	mov    0x10(%eax),%eax
  103c10:	83 ec 0c             	sub    $0xc,%esp
  103c13:	50                   	push   %eax
  103c14:	e8 26 3a 00 00       	call   10763f <_Z4physm>
  103c19:	83 c4 10             	add    $0x10,%esp
  103c1c:	83 ec 08             	sub    $0x8,%esp
  103c1f:	50                   	push   %eax
  103c20:	68 2b 9c 10 00       	push   $0x109c2b
  103c25:	e8 fe 37 00 00       	call   107428 <_Z3logPKcz>
  103c2a:	83 c4 10             	add    $0x10,%esp
            printf(" Module start : 0x%x\n", mod->mod_start);
            printf(" Module end : 0x%x\n", mod->mod_end);
            printf(" Module cmdline : '%s'\n", reinterpret_cast<char*>(phys(mod->cmdline)));
        }
    }*/
    if (CHECK_FLAG (info->flags, 6))
  103c2d:	8b 44 24 20          	mov    0x20(%esp),%eax
  103c31:	8b 00                	mov    (%eax),%eax
  103c33:	83 e0 40             	and    $0x40,%eax
  103c36:	85 c0                	test   %eax,%eax
  103c38:	0f 84 b4 00 00 00    	je     103cf2 <_ZN9multiboot10parse_infoEPK14multiboot_info+0x102>
    {
        Meminfo::mmap_addr = reinterpret_cast<multiboot_memory_map_t *>(phys(info->mmap_addr));
  103c3e:	8b 44 24 20          	mov    0x20(%esp),%eax
  103c42:	8b 40 30             	mov    0x30(%eax),%eax
  103c45:	83 ec 0c             	sub    $0xc,%esp
  103c48:	50                   	push   %eax
  103c49:	e8 f1 39 00 00       	call   10763f <_Z4physm>
  103c4e:	83 c4 10             	add    $0x10,%esp
  103c51:	a3 c8 ef 11 00       	mov    %eax,0x11efc8
        for (multiboot_memory_map_t *mmap = Meminfo::mmap_addr;
  103c56:	a1 c8 ef 11 00       	mov    0x11efc8,%eax
  103c5b:	89 44 24 0c          	mov    %eax,0xc(%esp)
             (uintptr_t)mmap < phys(info->mmap_addr) + info->mmap_length;
  103c5f:	8b 44 24 20          	mov    0x20(%esp),%eax
  103c63:	8b 40 30             	mov    0x30(%eax),%eax
  103c66:	83 ec 0c             	sub    $0xc,%esp
  103c69:	50                   	push   %eax
  103c6a:	e8 d0 39 00 00       	call   10763f <_Z4physm>
  103c6f:	83 c4 10             	add    $0x10,%esp
  103c72:	89 c2                	mov    %eax,%edx
  103c74:	8b 44 24 20          	mov    0x20(%esp),%eax
  103c78:	8b 40 2c             	mov    0x2c(%eax),%eax
  103c7b:	01 c2                	add    %eax,%edx
  103c7d:	8b 44 24 0c          	mov    0xc(%esp),%eax
  103c81:	39 c2                	cmp    %eax,%edx
  103c83:	0f 97 c0             	seta   %al
  103c86:	84 c0                	test   %al,%al
  103c88:	74 68                	je     103cf2 <_ZN9multiboot10parse_infoEPK14multiboot_info+0x102>
             mmap = (multiboot_memory_map_t *) ((unsigned long) mmap
                                                + mmap->size + sizeof (mmap->size)))
        {
            printf(" Base address : 0x%x, ", mmap->addr);
  103c8a:	8b 44 24 0c          	mov    0xc(%esp),%eax
  103c8e:	8b 50 08             	mov    0x8(%eax),%edx
  103c91:	8b 40 04             	mov    0x4(%eax),%eax
  103c94:	83 ec 04             	sub    $0x4,%esp
  103c97:	52                   	push   %edx
  103c98:	50                   	push   %eax
  103c99:	68 40 9c 10 00       	push   $0x109c40
  103c9e:	e8 2f 2c 00 00       	call   1068d2 <tfp_printf>
  103ca3:	83 c4 10             	add    $0x10,%esp
            printf("size : 0x%x, ", mmap->len);
  103ca6:	8b 44 24 0c          	mov    0xc(%esp),%eax
  103caa:	8b 50 10             	mov    0x10(%eax),%edx
  103cad:	8b 40 0c             	mov    0xc(%eax),%eax
  103cb0:	83 ec 04             	sub    $0x4,%esp
  103cb3:	52                   	push   %edx
  103cb4:	50                   	push   %eax
  103cb5:	68 57 9c 10 00       	push   $0x109c57
  103cba:	e8 13 2c 00 00       	call   1068d2 <tfp_printf>
  103cbf:	83 c4 10             	add    $0x10,%esp
            printf("type : %d\n", mmap->type);
  103cc2:	8b 44 24 0c          	mov    0xc(%esp),%eax
  103cc6:	8b 40 14             	mov    0x14(%eax),%eax
  103cc9:	83 ec 08             	sub    $0x8,%esp
  103ccc:	50                   	push   %eax
  103ccd:	68 65 9c 10 00       	push   $0x109c65
  103cd2:	e8 fb 2b 00 00       	call   1068d2 <tfp_printf>
  103cd7:	83 c4 10             	add    $0x10,%esp
                                                + mmap->size + sizeof (mmap->size)))
  103cda:	8b 44 24 0c          	mov    0xc(%esp),%eax
  103cde:	8b 10                	mov    (%eax),%edx
  103ce0:	8b 44 24 0c          	mov    0xc(%esp),%eax
  103ce4:	01 d0                	add    %edx,%eax
  103ce6:	83 c0 04             	add    $0x4,%eax
             mmap = (multiboot_memory_map_t *) ((unsigned long) mmap
  103ce9:	89 44 24 0c          	mov    %eax,0xc(%esp)
        for (multiboot_memory_map_t *mmap = Meminfo::mmap_addr;
  103ced:	e9 6d ff ff ff       	jmp    103c5f <_ZN9multiboot10parse_infoEPK14multiboot_info+0x6f>

        }
    }
    if (CHECK_FLAG(info->flags, 9))
  103cf2:	8b 44 24 20          	mov    0x20(%esp),%eax
  103cf6:	8b 00                	mov    (%eax),%eax
  103cf8:	25 00 02 00 00       	and    $0x200,%eax
  103cfd:	85 c0                	test   %eax,%eax
  103cff:	74 24                	je     103d25 <_ZN9multiboot10parse_infoEPK14multiboot_info+0x135>
    {
        log("Bootloader name : '%s'\n", reinterpret_cast<char*>(phys(info->boot_loader_name)));
  103d01:	8b 44 24 20          	mov    0x20(%esp),%eax
  103d05:	8b 40 40             	mov    0x40(%eax),%eax
  103d08:	83 ec 0c             	sub    $0xc,%esp
  103d0b:	50                   	push   %eax
  103d0c:	e8 2e 39 00 00       	call   10763f <_Z4physm>
  103d11:	83 c4 10             	add    $0x10,%esp
  103d14:	83 ec 08             	sub    $0x8,%esp
  103d17:	50                   	push   %eax
  103d18:	68 70 9c 10 00       	push   $0x109c70
  103d1d:	e8 06 37 00 00       	call   107428 <_Z3logPKcz>
  103d22:	83 c4 10             	add    $0x10,%esp
    }
}
  103d25:	90                   	nop
  103d26:	83 c4 1c             	add    $0x1c,%esp
  103d29:	c3                   	ret    

00103d2a <_Z41__static_initialization_and_destruction_0ii>:

}
  103d2a:	83 ec 0c             	sub    $0xc,%esp
  103d2d:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  103d32:	75 2e                	jne    103d62 <_Z41__static_initialization_and_destruction_0ii+0x38>
  103d34:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  103d3b:	00 
  103d3c:	75 24                	jne    103d62 <_Z41__static_initialization_and_destruction_0ii+0x38>
  103d3e:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  103d43:	0f b6 00             	movzbl (%eax),%eax
  103d46:	84 c0                	test   %al,%al
  103d48:	75 18                	jne    103d62 <_Z41__static_initialization_and_destruction_0ii+0x38>
  103d4a:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  103d4f:	c6 00 01             	movb   $0x1,(%eax)
  103d52:	83 ec 0c             	sub    $0xc,%esp
  103d55:	68 60 53 11 00       	push   $0x115360
  103d5a:	e8 db f3 ff ff       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  103d5f:	83 c4 10             	add    $0x10,%esp
  103d62:	90                   	nop
  103d63:	83 c4 0c             	add    $0xc,%esp
  103d66:	c3                   	ret    

00103d67 <_GLOBAL__sub_I__ZN9multiboot5checkEmRK16multiboot_headerPK14multiboot_info>:
  103d67:	83 ec 0c             	sub    $0xc,%esp
  103d6a:	83 ec 08             	sub    $0x8,%esp
  103d6d:	68 ff ff 00 00       	push   $0xffff
  103d72:	6a 01                	push   $0x1
  103d74:	e8 b1 ff ff ff       	call   103d2a <_Z41__static_initialization_and_destruction_0ii>
  103d79:	83 c4 10             	add    $0x10,%esp
  103d7c:	83 c4 0c             	add    $0xc,%esp
  103d7f:	c3                   	ret    

00103d80 <liballoc_lock>:

extern "C"
{
int liballoc_lock()
{
    LOCK(liballoc_lock);
  103d80:	b8 00 00 00 00       	mov    $0x0,%eax
  103d85:	ba 01 00 00 00       	mov    $0x1,%edx
  103d8a:	f0 0f b1 15 24 53 11 	lock cmpxchg %edx,0x115324
  103d91:	00 
  103d92:	0f 94 c0             	sete   %al
  103d95:	83 f0 01             	xor    $0x1,%eax
  103d98:	84 c0                	test   %al,%al
  103d9a:	74 02                	je     103d9e <liballoc_lock+0x1e>
  103d9c:	eb e2                	jmp    103d80 <liballoc_lock>
  103d9e:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
    return 0;
  103da3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  103da8:	c3                   	ret    

00103da9 <liballoc_unlock>:

int liballoc_unlock()
{
    UNLOCK(liballoc_lock);
  103da9:	f0 83 0c 24 00       	lock orl $0x0,(%esp)
  103dae:	c7 05 24 53 11 00 00 	movl   $0x0,0x115324
  103db5:	00 00 00 
    return 0;
  103db8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  103dbd:	c3                   	ret    

00103dbe <liballoc_alloc>:

void* liballoc_alloc(size_t pages)
{
    //return Paging::alloc_page_frame(pages);
}
  103dbe:	90                   	nop
  103dbf:	c3                   	ret    

00103dc0 <liballoc_free>:

int liballoc_free(void* ptr, size_t pages)
{
    //return Paging::release_page_frame((uintptr_t)ptr, pages);
}
  103dc0:	90                   	nop
  103dc1:	c3                   	ret    

00103dc2 <_Z5greetv>:

#include <stdio.h>
#include "terminal/terminal.hpp"

void greet()
{
  103dc2:	83 ec 0c             	sub    $0xc,%esp
    puts("Welcome to : \n");
  103dc5:	83 ec 0c             	sub    $0xc,%esp
  103dc8:	68 8c 9c 10 00       	push   $0x109c8c
  103dcd:	e8 a0 32 00 00       	call   107072 <puts>
  103dd2:	83 c4 10             	add    $0x10,%esp
    Terminal::push_color(VGA_COLOR_LIGHT_CYAN);
  103dd5:	83 ec 0c             	sub    $0xc,%esp
  103dd8:	6a 0b                	push   $0xb
  103dda:	e8 6a 38 00 00       	call   107649 <_ZN8Terminal10push_colorEh>
  103ddf:	83 c4 10             	add    $0x10,%esp

    puts(
  103de2:	83 ec 0c             	sub    $0xc,%esp
  103de5:	68 9c 9c 10 00       	push   $0x109c9c
  103dea:	e8 83 32 00 00       	call   107072 <puts>
  103def:	83 c4 10             	add    $0x10,%esp
            #include "ludos_art.txt"
        );

    Terminal::pop_color();
  103df2:	e8 78 38 00 00       	call   10766f <_ZN8Terminal9pop_colorEv>
}
  103df7:	90                   	nop
  103df8:	83 c4 0c             	add    $0xc,%esp
  103dfb:	c3                   	ret    

00103dfc <_Z41__static_initialization_and_destruction_0ii>:
  103dfc:	83 ec 0c             	sub    $0xc,%esp
  103dff:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  103e04:	75 2e                	jne    103e34 <_Z41__static_initialization_and_destruction_0ii+0x38>
  103e06:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  103e0d:	00 
  103e0e:	75 24                	jne    103e34 <_Z41__static_initialization_and_destruction_0ii+0x38>
  103e10:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  103e15:	0f b6 00             	movzbl (%eax),%eax
  103e18:	84 c0                	test   %al,%al
  103e1a:	75 18                	jne    103e34 <_Z41__static_initialization_and_destruction_0ii+0x38>
  103e1c:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  103e21:	c6 00 01             	movb   $0x1,(%eax)
  103e24:	83 ec 0c             	sub    $0xc,%esp
  103e27:	68 60 53 11 00       	push   $0x115360
  103e2c:	e8 09 f3 ff ff       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  103e31:	83 c4 10             	add    $0x10,%esp
  103e34:	90                   	nop
  103e35:	83 c4 0c             	add    $0xc,%esp
  103e38:	c3                   	ret    

00103e39 <_GLOBAL__sub_I__Z5greetv>:
  103e39:	83 ec 0c             	sub    $0xc,%esp
  103e3c:	83 ec 08             	sub    $0x8,%esp
  103e3f:	68 ff ff 00 00       	push   $0xffff
  103e44:	6a 01                	push   $0x1
  103e46:	e8 b1 ff ff ff       	call   103dfc <_Z41__static_initialization_and_destruction_0ii>
  103e4b:	83 c4 10             	add    $0x10,%esp
  103e4e:	83 c4 0c             	add    $0xc,%esp
  103e51:	c3                   	ret    

00103e52 <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE_clES2_>:

void Keyboard::init()
{
    isr::register_handler(IRQ1, &Keyboard::isr);

    handlers[0x48] = [](const Event&)
  103e52:	83 ec 1c             	sub    $0x1c,%esp
    {
        //printf("Hey\n");
        wait();
  103e55:	e8 3c 05 00 00       	call   104396 <_ZN8Keyboard4waitEv>
        uint8_t code = inb(KBD_PORT);
  103e5a:	83 ec 0c             	sub    $0xc,%esp
  103e5d:	6a 60                	push   $0x60
  103e5f:	e8 f6 e3 ff ff       	call   10225a <_Z3inbt>
  103e64:	83 c4 10             	add    $0x10,%esp
  103e67:	88 44 24 0f          	mov    %al,0xf(%esp)
        if (code == 0xE0)
  103e6b:	80 7c 24 0f e0       	cmpb   $0xe0,0xf(%esp)
  103e70:	75 1e                	jne    103e90 <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE_clES2_+0x3e>
        {
            Terminal::show_history(Terminal::current_history()+10);
  103e72:	e8 d3 3b 00 00       	call   107a4a <_ZN8Terminal15current_historyEv>
  103e77:	0f b6 c0             	movzbl %al,%eax
  103e7a:	83 c0 0a             	add    $0xa,%eax
  103e7d:	83 ec 0c             	sub    $0xc,%esp
  103e80:	50                   	push   %eax
  103e81:	e8 a8 3b 00 00       	call   107a2e <_ZN8Terminal12show_historyEi>
  103e86:	83 c4 10             	add    $0x10,%esp
            return false;
  103e89:	b8 00 00 00 00       	mov    $0x0,%eax
  103e8e:	eb 05                	jmp    103e95 <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE_clES2_+0x43>
        }
        return true;
  103e90:	b8 01 00 00 00       	mov    $0x1,%eax
    };
  103e95:	83 c4 1c             	add    $0x1c,%esp
  103e98:	c3                   	ret    

00103e99 <_ZZN8Keyboard4initEvENUlRKNS_5EventEE_4_FUNES2_>:
    handlers[0x48] = [](const Event&)
  103e99:	83 ec 0c             	sub    $0xc,%esp
    };
  103e9c:	83 ec 08             	sub    $0x8,%esp
  103e9f:	ff 74 24 18          	pushl  0x18(%esp)
  103ea3:	6a 00                	push   $0x0
  103ea5:	e8 a8 ff ff ff       	call   103e52 <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE_clES2_>
  103eaa:	83 c4 10             	add    $0x10,%esp
  103ead:	83 c4 0c             	add    $0xc,%esp
  103eb0:	c3                   	ret    
  103eb1:	90                   	nop

00103eb2 <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE_cvPFbS2_EEv>:
  103eb2:	b8 99 3e 10 00       	mov    $0x103e99,%eax
  103eb7:	c3                   	ret    

00103eb8 <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE0_clES2_>:
    handlers[0x50] = [](const Event&)
  103eb8:	83 ec 1c             	sub    $0x1c,%esp
    {
        wait();
  103ebb:	e8 d6 04 00 00       	call   104396 <_ZN8Keyboard4waitEv>
        uint8_t code = inb(KBD_PORT);
  103ec0:	83 ec 0c             	sub    $0xc,%esp
  103ec3:	6a 60                	push   $0x60
  103ec5:	e8 90 e3 ff ff       	call   10225a <_Z3inbt>
  103eca:	83 c4 10             	add    $0x10,%esp
  103ecd:	88 44 24 0f          	mov    %al,0xf(%esp)
        if (code == 0xE0)
  103ed1:	80 7c 24 0f e0       	cmpb   $0xe0,0xf(%esp)
  103ed6:	75 1e                	jne    103ef6 <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE0_clES2_+0x3e>
        {
            Terminal::show_history(Terminal::current_history()-10);
  103ed8:	e8 6d 3b 00 00       	call   107a4a <_ZN8Terminal15current_historyEv>
  103edd:	0f b6 c0             	movzbl %al,%eax
  103ee0:	83 e8 0a             	sub    $0xa,%eax
  103ee3:	83 ec 0c             	sub    $0xc,%esp
  103ee6:	50                   	push   %eax
  103ee7:	e8 42 3b 00 00       	call   107a2e <_ZN8Terminal12show_historyEi>
  103eec:	83 c4 10             	add    $0x10,%esp
            return false;
  103eef:	b8 00 00 00 00       	mov    $0x0,%eax
  103ef4:	eb 05                	jmp    103efb <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE0_clES2_+0x43>
        }
        return true;
  103ef6:	b8 01 00 00 00       	mov    $0x1,%eax
    };
  103efb:	83 c4 1c             	add    $0x1c,%esp
  103efe:	c3                   	ret    

00103eff <_ZZN8Keyboard4initEvENUlRKNS_5EventEE0_4_FUNES2_>:
    handlers[0x50] = [](const Event&)
  103eff:	83 ec 0c             	sub    $0xc,%esp
    };
  103f02:	83 ec 08             	sub    $0x8,%esp
  103f05:	ff 74 24 18          	pushl  0x18(%esp)
  103f09:	6a 00                	push   $0x0
  103f0b:	e8 a8 ff ff ff       	call   103eb8 <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE0_clES2_>
  103f10:	83 c4 10             	add    $0x10,%esp
  103f13:	83 c4 0c             	add    $0xc,%esp
  103f16:	c3                   	ret    
  103f17:	90                   	nop

00103f18 <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE0_cvPFbS2_EEv>:
  103f18:	b8 ff 3e 10 00       	mov    $0x103eff,%eax
  103f1d:	c3                   	ret    

00103f1e <_ZN8Keyboard4initEv>:
{
  103f1e:	83 ec 1c             	sub    $0x1c,%esp
    isr::register_handler(IRQ1, &Keyboard::isr);
  103f21:	83 ec 08             	sub    $0x8,%esp
  103f24:	68 2c 40 10 00       	push   $0x10402c
  103f29:	6a 21                	push   $0x21
  103f2b:	e8 27 e4 ff ff       	call   102357 <_ZN3isr16register_handlerEhPFvPK9registersE>
  103f30:	83 c4 10             	add    $0x10,%esp
    };
  103f33:	83 ec 0c             	sub    $0xc,%esp
  103f36:	8d 44 24 1a          	lea    0x1a(%esp),%eax
  103f3a:	50                   	push   %eax
  103f3b:	e8 72 ff ff ff       	call   103eb2 <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE_cvPFbS2_EEv>
  103f40:	83 c4 10             	add    $0x10,%esp
    handlers[0x48] = [](const Event&)
  103f43:	a3 20 f1 11 00       	mov    %eax,0x11f120
    };
  103f48:	83 ec 0c             	sub    $0xc,%esp
  103f4b:	8d 44 24 1b          	lea    0x1b(%esp),%eax
  103f4f:	50                   	push   %eax
  103f50:	e8 c3 ff ff ff       	call   103f18 <_ZZN8Keyboard4initEvENKUlRKNS_5EventEE0_cvPFbS2_EEv>
  103f55:	83 c4 10             	add    $0x10,%esp
    handlers[0x50] = [](const Event&)
  103f58:	a3 40 f1 11 00       	mov    %eax,0x11f140

    log("Keyboard initialized\n");
  103f5d:	83 ec 0c             	sub    $0xc,%esp
  103f60:	68 6e a0 10 00       	push   $0x10a06e
  103f65:	e8 be 34 00 00       	call   107428 <_Z3logPKcz>
  103f6a:	83 c4 10             	add    $0x10,%esp
}
  103f6d:	90                   	nop
  103f6e:	83 c4 1c             	add    $0x1c,%esp
  103f71:	c3                   	ret    

00103f72 <_ZN8Keyboard8set_ledsEh>:

void Keyboard::set_leds(uint8_t leds)
{
  103f72:	83 ec 1c             	sub    $0x1c,%esp
  103f75:	8b 44 24 20          	mov    0x20(%esp),%eax
  103f79:	88 44 24 0c          	mov    %al,0xc(%esp)
    outb(KBD_PORT, LED_CMD);
  103f7d:	83 ec 08             	sub    $0x8,%esp
  103f80:	68 ed 00 00 00       	push   $0xed
  103f85:	6a 60                	push   $0x60
  103f87:	e8 6f e2 ff ff       	call   1021fb <_Z4outbth>
  103f8c:	83 c4 10             	add    $0x10,%esp
    wait();
  103f8f:	e8 02 04 00 00       	call   104396 <_ZN8Keyboard4waitEv>
    outb(KBD_PORT, leds);
  103f94:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  103f99:	83 ec 08             	sub    $0x8,%esp
  103f9c:	50                   	push   %eax
  103f9d:	6a 60                	push   $0x60
  103f9f:	e8 57 e2 ff ff       	call   1021fb <_Z4outbth>
  103fa4:	83 c4 10             	add    $0x10,%esp
    wait();
  103fa7:	e8 ea 03 00 00       	call   104396 <_ZN8Keyboard4waitEv>
}
  103fac:	90                   	nop
  103fad:	83 c4 1c             	add    $0x1c,%esp
  103fb0:	c3                   	ret    
  103fb1:	90                   	nop

00103fb2 <_ZN8Keyboard10toggle_ledEhb>:

void Keyboard::toggle_led(uint8_t led, bool value)
{
  103fb2:	83 ec 1c             	sub    $0x1c,%esp
  103fb5:	8b 54 24 20          	mov    0x20(%esp),%edx
  103fb9:	8b 44 24 24          	mov    0x24(%esp),%eax
  103fbd:	88 54 24 0c          	mov    %dl,0xc(%esp)
  103fc1:	88 44 24 08          	mov    %al,0x8(%esp)
    leds &= ~led;         // clear
  103fc5:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  103fca:	f7 d0                	not    %eax
  103fcc:	89 c2                	mov    %eax,%edx
  103fce:	0f b6 05 07 f4 11 00 	movzbl 0x11f407,%eax
  103fd5:	21 d0                	and    %edx,%eax
  103fd7:	a2 07 f4 11 00       	mov    %al,0x11f407
    leds |=  led & (value ? 0xFF : 0); // set to val
  103fdc:	80 7c 24 08 00       	cmpb   $0x0,0x8(%esp)
  103fe1:	74 07                	je     103fea <_ZN8Keyboard10toggle_ledEhb+0x38>
  103fe3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  103fe8:	eb 05                	jmp    103fef <_ZN8Keyboard10toggle_ledEhb+0x3d>
  103fea:	ba 00 00 00 00       	mov    $0x0,%edx
  103fef:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  103ff4:	21 c2                	and    %eax,%edx
  103ff6:	0f b6 05 07 f4 11 00 	movzbl 0x11f407,%eax
  103ffd:	09 d0                	or     %edx,%eax
  103fff:	a2 07 f4 11 00       	mov    %al,0x11f407

    set_leds(leds);
  104004:	0f b6 05 07 f4 11 00 	movzbl 0x11f407,%eax
  10400b:	0f b6 c0             	movzbl %al,%eax
  10400e:	83 ec 0c             	sub    $0xc,%esp
  104011:	50                   	push   %eax
  104012:	e8 5b ff ff ff       	call   103f72 <_ZN8Keyboard8set_ledsEh>
  104017:	83 c4 10             	add    $0x10,%esp
}
  10401a:	90                   	nop
  10401b:	83 c4 1c             	add    $0x1c,%esp
  10401e:	c3                   	ret    
  10401f:	90                   	nop

00104020 <_ZN8Keyboard10set_kbdmapEPKh>:

void Keyboard::set_kbdmap(const uint8_t *map)
{
    kbdmap = map;
  104020:	8b 44 24 04          	mov    0x4(%esp),%eax
  104024:	a3 08 00 11 00       	mov    %eax,0x110008
}
  104029:	90                   	nop
  10402a:	c3                   	ret    
  10402b:	90                   	nop

0010402c <_ZN8Keyboard3isrEPK9registers>:

void Keyboard::isr(const registers * const)
{
  10402c:	53                   	push   %ebx
  10402d:	83 ec 28             	sub    $0x28,%esp
    uint8_t key;
    do
    {
        key = inb(0x64);
  104030:	83 ec 0c             	sub    $0xc,%esp
  104033:	6a 64                	push   $0x64
  104035:	e8 20 e2 ff ff       	call   10225a <_Z3inbt>
  10403a:	83 c4 10             	add    $0x10,%esp
  10403d:	88 44 24 1f          	mov    %al,0x1f(%esp)
    } while ((key & 0x01) == 0);
  104041:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  104046:	83 e0 01             	and    $0x1,%eax
  104049:	85 c0                	test   %eax,%eax
  10404b:	75 02                	jne    10404f <_ZN8Keyboard3isrEPK9registers+0x23>
    do
  10404d:	eb e1                	jmp    104030 <_ZN8Keyboard3isrEPK9registers+0x4>

    key = inb(KBD_PORT);
  10404f:	83 ec 0c             	sub    $0xc,%esp
  104052:	6a 60                	push   $0x60
  104054:	e8 01 e2 ff ff       	call   10225a <_Z3inbt>
  104059:	83 c4 10             	add    $0x10,%esp
  10405c:	88 44 24 1f          	mov    %al,0x1f(%esp)
    key--;
  104060:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  104065:	83 e8 01             	sub    $0x1,%eax
  104068:	88 44 24 1f          	mov    %al,0x1f(%esp)

    uint8_t unaltered_key = key;
  10406c:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  104071:	88 44 24 1c          	mov    %al,0x1c(%esp)


    bool pressed = false;
  104075:	c6 44 24 1e 00       	movb   $0x0,0x1e(%esp)

    switch (key)
  10407a:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  10407f:	83 f8 44             	cmp    $0x44,%eax
  104082:	74 35                	je     1040b9 <_ZN8Keyboard3isrEPK9registers+0x8d>
  104084:	83 f8 45             	cmp    $0x45,%eax
  104087:	74 07                	je     104090 <_ZN8Keyboard3isrEPK9registers+0x64>
  104089:	83 f8 39             	cmp    $0x39,%eax
  10408c:	74 54                	je     1040e2 <_ZN8Keyboard3isrEPK9registers+0xb6>
  10408e:	eb 7a                	jmp    10410a <_ZN8Keyboard3isrEPK9registers+0xde>
    {
    case 0x45:
        scroll_lock = !scroll_lock;
  104090:	0f b6 05 05 f4 11 00 	movzbl 0x11f405,%eax
  104097:	83 f0 01             	xor    $0x1,%eax
  10409a:	a2 05 f4 11 00       	mov    %al,0x11f405
        toggle_led(SCROLL_LOCK_LED, scroll_lock);
  10409f:	0f b6 05 05 f4 11 00 	movzbl 0x11f405,%eax
  1040a6:	0f b6 c0             	movzbl %al,%eax
  1040a9:	83 ec 08             	sub    $0x8,%esp
  1040ac:	50                   	push   %eax
  1040ad:	6a 01                	push   $0x1
  1040af:	e8 fe fe ff ff       	call   103fb2 <_ZN8Keyboard10toggle_ledEhb>
  1040b4:	83 c4 10             	add    $0x10,%esp
        break;
  1040b7:	eb 51                	jmp    10410a <_ZN8Keyboard3isrEPK9registers+0xde>
    case 0x44:
        num_lock = !num_lock;
  1040b9:	0f b6 05 06 f4 11 00 	movzbl 0x11f406,%eax
  1040c0:	83 f0 01             	xor    $0x1,%eax
  1040c3:	a2 06 f4 11 00       	mov    %al,0x11f406
        toggle_led(NUM_LOCK_LED, num_lock);
  1040c8:	0f b6 05 06 f4 11 00 	movzbl 0x11f406,%eax
  1040cf:	0f b6 c0             	movzbl %al,%eax
  1040d2:	83 ec 08             	sub    $0x8,%esp
  1040d5:	50                   	push   %eax
  1040d6:	6a 02                	push   $0x2
  1040d8:	e8 d5 fe ff ff       	call   103fb2 <_ZN8Keyboard10toggle_ledEhb>
  1040dd:	83 c4 10             	add    $0x10,%esp
        break;
  1040e0:	eb 28                	jmp    10410a <_ZN8Keyboard3isrEPK9registers+0xde>
    case 0x39:
        caps_lock = !caps_lock;
  1040e2:	0f b6 05 04 f4 11 00 	movzbl 0x11f404,%eax
  1040e9:	83 f0 01             	xor    $0x1,%eax
  1040ec:	a2 04 f4 11 00       	mov    %al,0x11f404
        toggle_led(CAPS_LOCK_LED, caps_lock);
  1040f1:	0f b6 05 04 f4 11 00 	movzbl 0x11f404,%eax
  1040f8:	0f b6 c0             	movzbl %al,%eax
  1040fb:	83 ec 08             	sub    $0x8,%esp
  1040fe:	50                   	push   %eax
  1040ff:	6a 04                	push   $0x4
  104101:	e8 ac fe ff ff       	call   103fb2 <_ZN8Keyboard10toggle_ledEhb>
  104106:	83 c4 10             	add    $0x10,%esp
        break;
  104109:	90                   	nop
    }

    bool is_handle_char { false };
  10410a:	c6 44 24 1d 00       	movb   $0x0,0x1d(%esp)

    if (key < 0x80)
  10410f:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  104114:	84 c0                	test   %al,%al
  104116:	78 52                	js     10416a <_ZN8Keyboard3isrEPK9registers+0x13e>
    {         /* touche enfoncee */
        pressed = true;
  104118:	c6 44 24 1e 01       	movb   $0x1,0x1e(%esp)
        switch (key) {
  10411d:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  104122:	83 f8 29             	cmp    $0x29,%eax
  104125:	74 18                	je     10413f <_ZN8Keyboard3isrEPK9registers+0x113>
  104127:	83 f8 29             	cmp    $0x29,%eax
  10412a:	7f 07                	jg     104133 <_ZN8Keyboard3isrEPK9registers+0x107>
  10412c:	83 f8 1c             	cmp    $0x1c,%eax
  10412f:	74 20                	je     104151 <_ZN8Keyboard3isrEPK9registers+0x125>
  104131:	eb 30                	jmp    104163 <_ZN8Keyboard3isrEPK9registers+0x137>
  104133:	83 f8 35             	cmp    $0x35,%eax
  104136:	74 10                	je     104148 <_ZN8Keyboard3isrEPK9registers+0x11c>
  104138:	83 f8 37             	cmp    $0x37,%eax
  10413b:	74 1d                	je     10415a <_ZN8Keyboard3isrEPK9registers+0x12e>
  10413d:	eb 24                	jmp    104163 <_ZN8Keyboard3isrEPK9registers+0x137>
        case 0x29:
            lshift = true;
  10413f:	c6 05 00 f4 11 00 01 	movb   $0x1,0x11f400
            break;
  104146:	eb 6c                	jmp    1041b4 <_ZN8Keyboard3isrEPK9registers+0x188>
        case 0x35:
            rshift = true;
  104148:	c6 05 01 f4 11 00 01 	movb   $0x1,0x11f401
            break;
  10414f:	eb 63                	jmp    1041b4 <_ZN8Keyboard3isrEPK9registers+0x188>
        case 0x1C:
            ctrl = true;
  104151:	c6 05 02 f4 11 00 01 	movb   $0x1,0x11f402
            break;
  104158:	eb 5a                	jmp    1041b4 <_ZN8Keyboard3isrEPK9registers+0x188>
        case 0x37:
            alt = true;
  10415a:	c6 05 03 f4 11 00 01 	movb   $0x1,0x11f403
            break;
  104161:	eb 51                	jmp    1041b4 <_ZN8Keyboard3isrEPK9registers+0x188>
        default:
            is_handle_char = true;
  104163:	c6 44 24 1d 01       	movb   $0x1,0x1d(%esp)
  104168:	eb 4a                	jmp    1041b4 <_ZN8Keyboard3isrEPK9registers+0x188>
        }
    }
    else
    {                /* touche relachee */
        key -= 0x80;
  10416a:	80 44 24 1f 80       	addb   $0x80,0x1f(%esp)
        switch (key)
  10416f:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  104174:	83 f8 29             	cmp    $0x29,%eax
  104177:	74 18                	je     104191 <_ZN8Keyboard3isrEPK9registers+0x165>
  104179:	83 f8 29             	cmp    $0x29,%eax
  10417c:	7f 07                	jg     104185 <_ZN8Keyboard3isrEPK9registers+0x159>
  10417e:	83 f8 1c             	cmp    $0x1c,%eax
  104181:	74 20                	je     1041a3 <_ZN8Keyboard3isrEPK9registers+0x177>
  104183:	eb 2f                	jmp    1041b4 <_ZN8Keyboard3isrEPK9registers+0x188>
  104185:	83 f8 35             	cmp    $0x35,%eax
  104188:	74 10                	je     10419a <_ZN8Keyboard3isrEPK9registers+0x16e>
  10418a:	83 f8 37             	cmp    $0x37,%eax
  10418d:	74 1d                	je     1041ac <_ZN8Keyboard3isrEPK9registers+0x180>
  10418f:	eb 23                	jmp    1041b4 <_ZN8Keyboard3isrEPK9registers+0x188>
        {
        case 0x29:
            lshift = false;
  104191:	c6 05 00 f4 11 00 00 	movb   $0x0,0x11f400
            break;
  104198:	eb 1a                	jmp    1041b4 <_ZN8Keyboard3isrEPK9registers+0x188>
        case 0x35:
            rshift = false;
  10419a:	c6 05 01 f4 11 00 00 	movb   $0x0,0x11f401
            break;
  1041a1:	eb 11                	jmp    1041b4 <_ZN8Keyboard3isrEPK9registers+0x188>
        case 0x1C:
            ctrl = false;
  1041a3:	c6 05 02 f4 11 00 00 	movb   $0x0,0x11f402
            break;
  1041aa:	eb 08                	jmp    1041b4 <_ZN8Keyboard3isrEPK9registers+0x188>
        case 0x37:
            alt = false;
  1041ac:	c6 05 03 f4 11 00 00 	movb   $0x0,0x11f403
            break;
  1041b3:	90                   	nop
        }
    }

    Event event {(lshift || rshift), alt, ctrl, false, caps_lock, scroll_lock, num_lock, pressed, unaltered_key};
  1041b4:	66 c7 44 24 1a 00 00 	movw   $0x0,0x1a(%esp)
  1041bb:	0f b6 05 00 f4 11 00 	movzbl 0x11f400,%eax
  1041c2:	84 c0                	test   %al,%al
  1041c4:	75 0b                	jne    1041d1 <_ZN8Keyboard3isrEPK9registers+0x1a5>
  1041c6:	0f b6 05 01 f4 11 00 	movzbl 0x11f401,%eax
  1041cd:	84 c0                	test   %al,%al
  1041cf:	74 07                	je     1041d8 <_ZN8Keyboard3isrEPK9registers+0x1ac>
  1041d1:	b8 01 00 00 00       	mov    $0x1,%eax
  1041d6:	eb 05                	jmp    1041dd <_ZN8Keyboard3isrEPK9registers+0x1b1>
  1041d8:	b8 00 00 00 00       	mov    $0x0,%eax
  1041dd:	83 e0 01             	and    $0x1,%eax
  1041e0:	89 c2                	mov    %eax,%edx
  1041e2:	0f b6 44 24 1a       	movzbl 0x1a(%esp),%eax
  1041e7:	83 e0 fe             	and    $0xfffffffe,%eax
  1041ea:	09 d0                	or     %edx,%eax
  1041ec:	88 44 24 1a          	mov    %al,0x1a(%esp)
  1041f0:	0f b6 05 03 f4 11 00 	movzbl 0x11f403,%eax
  1041f7:	83 e0 01             	and    $0x1,%eax
  1041fa:	8d 14 00             	lea    (%eax,%eax,1),%edx
  1041fd:	0f b6 44 24 1a       	movzbl 0x1a(%esp),%eax
  104202:	83 e0 fd             	and    $0xfffffffd,%eax
  104205:	09 d0                	or     %edx,%eax
  104207:	88 44 24 1a          	mov    %al,0x1a(%esp)
  10420b:	0f b6 05 02 f4 11 00 	movzbl 0x11f402,%eax
  104212:	83 e0 01             	and    $0x1,%eax
  104215:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  10421c:	0f b6 44 24 1a       	movzbl 0x1a(%esp),%eax
  104221:	83 e0 fb             	and    $0xfffffffb,%eax
  104224:	09 d0                	or     %edx,%eax
  104226:	88 44 24 1a          	mov    %al,0x1a(%esp)
  10422a:	0f b6 05 04 f4 11 00 	movzbl 0x11f404,%eax
  104231:	83 e0 01             	and    $0x1,%eax
  104234:	c1 e0 04             	shl    $0x4,%eax
  104237:	89 c2                	mov    %eax,%edx
  104239:	0f b6 44 24 1a       	movzbl 0x1a(%esp),%eax
  10423e:	83 e0 ef             	and    $0xffffffef,%eax
  104241:	09 d0                	or     %edx,%eax
  104243:	88 44 24 1a          	mov    %al,0x1a(%esp)
  104247:	0f b6 05 05 f4 11 00 	movzbl 0x11f405,%eax
  10424e:	83 e0 01             	and    $0x1,%eax
  104251:	c1 e0 05             	shl    $0x5,%eax
  104254:	89 c2                	mov    %eax,%edx
  104256:	0f b6 44 24 1a       	movzbl 0x1a(%esp),%eax
  10425b:	83 e0 df             	and    $0xffffffdf,%eax
  10425e:	09 d0                	or     %edx,%eax
  104260:	88 44 24 1a          	mov    %al,0x1a(%esp)
  104264:	0f b6 05 06 f4 11 00 	movzbl 0x11f406,%eax
  10426b:	83 e0 01             	and    $0x1,%eax
  10426e:	c1 e0 06             	shl    $0x6,%eax
  104271:	89 c2                	mov    %eax,%edx
  104273:	0f b6 44 24 1a       	movzbl 0x1a(%esp),%eax
  104278:	83 e0 bf             	and    $0xffffffbf,%eax
  10427b:	09 d0                	or     %edx,%eax
  10427d:	88 44 24 1a          	mov    %al,0x1a(%esp)
  104281:	0f b6 44 24 1e       	movzbl 0x1e(%esp),%eax
  104286:	c1 e0 07             	shl    $0x7,%eax
  104289:	89 c2                	mov    %eax,%edx
  10428b:	0f b6 44 24 1a       	movzbl 0x1a(%esp),%eax
  104290:	83 e0 7f             	and    $0x7f,%eax
  104293:	09 d0                	or     %edx,%eax
  104295:	88 44 24 1a          	mov    %al,0x1a(%esp)
  104299:	0f b6 44 24 1c       	movzbl 0x1c(%esp),%eax
  10429e:	88 44 24 1b          	mov    %al,0x1b(%esp)

    if ((!handlers[unaltered_key] || handlers[unaltered_key](event)) && is_handle_char)
  1042a2:	0f b6 44 24 1c       	movzbl 0x1c(%esp),%eax
  1042a7:	8b 04 85 00 f0 11 00 	mov    0x11f000(,%eax,4),%eax
  1042ae:	85 c0                	test   %eax,%eax
  1042b0:	74 1d                	je     1042cf <_ZN8Keyboard3isrEPK9registers+0x2a3>
  1042b2:	0f b6 44 24 1c       	movzbl 0x1c(%esp),%eax
  1042b7:	8b 04 85 00 f0 11 00 	mov    0x11f000(,%eax,4),%eax
  1042be:	83 ec 0c             	sub    $0xc,%esp
  1042c1:	8d 54 24 26          	lea    0x26(%esp),%edx
  1042c5:	52                   	push   %edx
  1042c6:	ff d0                	call   *%eax
  1042c8:	83 c4 10             	add    $0x10,%esp
  1042cb:	84 c0                	test   %al,%al
  1042cd:	74 0e                	je     1042dd <_ZN8Keyboard3isrEPK9registers+0x2b1>
  1042cf:	80 7c 24 1d 00       	cmpb   $0x0,0x1d(%esp)
  1042d4:	74 07                	je     1042dd <_ZN8Keyboard3isrEPK9registers+0x2b1>
  1042d6:	b8 01 00 00 00       	mov    $0x1,%eax
  1042db:	eb 05                	jmp    1042e2 <_ZN8Keyboard3isrEPK9registers+0x2b6>
  1042dd:	b8 00 00 00 00       	mov    $0x0,%eax
  1042e2:	84 c0                	test   %al,%al
  1042e4:	0f 84 8a 00 00 00    	je     104374 <_ZN8Keyboard3isrEPK9registers+0x348>
    {
        handle_char(kbdmap
  1042ea:	8b 15 ec ef 11 00    	mov    0x11efec,%edx
                    [key * 4 + (((lshift || rshift) ^ caps_lock) ? 1 : alt ? 2 : num_lock ? 3 : 0)]);
  1042f0:	8b 0d 08 00 11 00    	mov    0x110008,%ecx
  1042f6:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  1042fb:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
  104302:	0f b6 05 00 f4 11 00 	movzbl 0x11f400,%eax
  104309:	84 c0                	test   %al,%al
  10430b:	75 0b                	jne    104318 <_ZN8Keyboard3isrEPK9registers+0x2ec>
  10430d:	0f b6 05 01 f4 11 00 	movzbl 0x11f401,%eax
  104314:	84 c0                	test   %al,%al
  104316:	74 07                	je     10431f <_ZN8Keyboard3isrEPK9registers+0x2f3>
  104318:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
  10431d:	eb 05                	jmp    104324 <_ZN8Keyboard3isrEPK9registers+0x2f8>
  10431f:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
  104324:	0f b6 05 04 f4 11 00 	movzbl 0x11f404,%eax
  10432b:	38 44 24 0f          	cmp    %al,0xf(%esp)
  10432f:	75 2b                	jne    10435c <_ZN8Keyboard3isrEPK9registers+0x330>
  104331:	0f b6 05 03 f4 11 00 	movzbl 0x11f403,%eax
  104338:	84 c0                	test   %al,%al
  10433a:	74 07                	je     104343 <_ZN8Keyboard3isrEPK9registers+0x317>
  10433c:	b8 02 00 00 00       	mov    $0x2,%eax
  104341:	eb 1e                	jmp    104361 <_ZN8Keyboard3isrEPK9registers+0x335>
  104343:	0f b6 05 06 f4 11 00 	movzbl 0x11f406,%eax
  10434a:	84 c0                	test   %al,%al
  10434c:	74 07                	je     104355 <_ZN8Keyboard3isrEPK9registers+0x329>
  10434e:	b8 03 00 00 00       	mov    $0x3,%eax
  104353:	eb 0c                	jmp    104361 <_ZN8Keyboard3isrEPK9registers+0x335>
  104355:	b8 00 00 00 00       	mov    $0x0,%eax
  10435a:	eb 05                	jmp    104361 <_ZN8Keyboard3isrEPK9registers+0x335>
  10435c:	b8 01 00 00 00       	mov    $0x1,%eax
  104361:	01 d8                	add    %ebx,%eax
  104363:	01 c8                	add    %ecx,%eax
  104365:	0f b6 00             	movzbl (%eax),%eax
        handle_char(kbdmap
  104368:	0f b6 c0             	movzbl %al,%eax
  10436b:	83 ec 0c             	sub    $0xc,%esp
  10436e:	50                   	push   %eax
  10436f:	ff d2                	call   *%edx
  104371:	83 c4 10             	add    $0x10,%esp
    }

    if (kbd_event)
  104374:	a1 f0 ef 11 00       	mov    0x11eff0,%eax
  104379:	85 c0                	test   %eax,%eax
  10437b:	74 12                	je     10438f <_ZN8Keyboard3isrEPK9registers+0x363>
    {
        kbd_event(event);
  10437d:	a1 f0 ef 11 00       	mov    0x11eff0,%eax
  104382:	83 ec 0c             	sub    $0xc,%esp
  104385:	8d 54 24 26          	lea    0x26(%esp),%edx
  104389:	52                   	push   %edx
  10438a:	ff d0                	call   *%eax
  10438c:	83 c4 10             	add    $0x10,%esp
    }
}
  10438f:	90                   	nop
  104390:	83 c4 28             	add    $0x28,%esp
  104393:	5b                   	pop    %ebx
  104394:	c3                   	ret    
  104395:	90                   	nop

00104396 <_ZN8Keyboard4waitEv>:

void Keyboard::wait()
{
  104396:	83 ec 1c             	sub    $0x1c,%esp
    uint8_t key;
    do
    {
        key = inb(0x64);
  104399:	83 ec 0c             	sub    $0xc,%esp
  10439c:	6a 64                	push   $0x64
  10439e:	e8 b7 de ff ff       	call   10225a <_Z3inbt>
  1043a3:	83 c4 10             	add    $0x10,%esp
  1043a6:	88 44 24 0f          	mov    %al,0xf(%esp)
    } while ((key & 0x01) == 0);
  1043aa:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
  1043af:	83 e0 01             	and    $0x1,%eax
  1043b2:	85 c0                	test   %eax,%eax
  1043b4:	75 02                	jne    1043b8 <_ZN8Keyboard4waitEv+0x22>
    do
  1043b6:	eb e1                	jmp    104399 <_ZN8Keyboard4waitEv+0x3>
}
  1043b8:	90                   	nop
  1043b9:	83 c4 1c             	add    $0x1c,%esp
  1043bc:	c3                   	ret    

001043bd <_Z41__static_initialization_and_destruction_0ii>:
  1043bd:	83 ec 0c             	sub    $0xc,%esp
  1043c0:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  1043c5:	75 2e                	jne    1043f5 <_Z41__static_initialization_and_destruction_0ii+0x38>
  1043c7:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  1043ce:	00 
  1043cf:	75 24                	jne    1043f5 <_Z41__static_initialization_and_destruction_0ii+0x38>
  1043d1:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  1043d6:	0f b6 00             	movzbl (%eax),%eax
  1043d9:	84 c0                	test   %al,%al
  1043db:	75 18                	jne    1043f5 <_Z41__static_initialization_and_destruction_0ii+0x38>
  1043dd:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  1043e2:	c6 00 01             	movb   $0x1,(%eax)
  1043e5:	83 ec 0c             	sub    $0xc,%esp
  1043e8:	68 60 53 11 00       	push   $0x115360
  1043ed:	e8 48 ed ff ff       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  1043f2:	83 c4 10             	add    $0x10,%esp
  1043f5:	90                   	nop
  1043f6:	83 c4 0c             	add    $0xc,%esp
  1043f9:	c3                   	ret    

001043fa <_GLOBAL__sub_I__ZN8Keyboard4initEv>:
  1043fa:	83 ec 0c             	sub    $0xc,%esp
  1043fd:	83 ec 08             	sub    $0x8,%esp
  104400:	68 ff ff 00 00       	push   $0xffff
  104405:	6a 01                	push   $0x1
  104407:	e8 b1 ff ff ff       	call   1043bd <_Z41__static_initialization_and_destruction_0ii>
  10440c:	83 c4 10             	add    $0x10,%esp
  10440f:	83 c4 0c             	add    $0xc,%esp
  104412:	c3                   	ret    

00104413 <_ZN3pic4initEv>:
#include "io.hpp"

namespace pic
{
void init()
{
  104413:	83 ec 0c             	sub    $0xc,%esp
    puts("Beginning PIC initialization");
  104416:	83 ec 0c             	sub    $0xc,%esp
  104419:	68 84 a0 10 00       	push   $0x10a084
  10441e:	e8 4f 2c 00 00       	call   107072 <puts>
  104423:	83 c4 10             	add    $0x10,%esp
    /* set up cascading mode */
    outb(PIC_MASTER_CMD, 0x10 + 0x01);
  104426:	83 ec 08             	sub    $0x8,%esp
  104429:	6a 11                	push   $0x11
  10442b:	6a 20                	push   $0x20
  10442d:	e8 c9 dd ff ff       	call   1021fb <_Z4outbth>
  104432:	83 c4 10             	add    $0x10,%esp
    io_wait();
  104435:	e8 7e de ff ff       	call   1022b8 <_Z7io_waitv>
    outb(PIC_SLAVE_CMD,  0x10 + 0x01);
  10443a:	83 ec 08             	sub    $0x8,%esp
  10443d:	6a 11                	push   $0x11
  10443f:	68 a0 00 00 00       	push   $0xa0
  104444:	e8 b2 dd ff ff       	call   1021fb <_Z4outbth>
  104449:	83 c4 10             	add    $0x10,%esp
    io_wait();
  10444c:	e8 67 de ff ff       	call   1022b8 <_Z7io_waitv>
    /* Setup master's vector offset */
    outb(PIC_MASTER_DATA, 0x20);
  104451:	83 ec 08             	sub    $0x8,%esp
  104454:	6a 20                	push   $0x20
  104456:	6a 21                	push   $0x21
  104458:	e8 9e dd ff ff       	call   1021fb <_Z4outbth>
  10445d:	83 c4 10             	add    $0x10,%esp
    io_wait();
  104460:	e8 53 de ff ff       	call   1022b8 <_Z7io_waitv>
    /* Tell the slave its vector offset */
    outb(PIC_SLAVE_DATA, 0x28);
  104465:	83 ec 08             	sub    $0x8,%esp
  104468:	6a 28                	push   $0x28
  10446a:	68 a1 00 00 00       	push   $0xa1
  10446f:	e8 87 dd ff ff       	call   1021fb <_Z4outbth>
  104474:	83 c4 10             	add    $0x10,%esp
    io_wait();
  104477:	e8 3c de ff ff       	call   1022b8 <_Z7io_waitv>
    /* Tell the master that he has a slave */
    outb(PIC_MASTER_DATA, 4);
  10447c:	83 ec 08             	sub    $0x8,%esp
  10447f:	6a 04                	push   $0x4
  104481:	6a 21                	push   $0x21
  104483:	e8 73 dd ff ff       	call   1021fb <_Z4outbth>
  104488:	83 c4 10             	add    $0x10,%esp
    io_wait();
  10448b:	e8 28 de ff ff       	call   1022b8 <_Z7io_waitv>
    outb(PIC_SLAVE_DATA, 2);
  104490:	83 ec 08             	sub    $0x8,%esp
  104493:	6a 02                	push   $0x2
  104495:	68 a1 00 00 00       	push   $0xa1
  10449a:	e8 5c dd ff ff       	call   1021fb <_Z4outbth>
  10449f:	83 c4 10             	add    $0x10,%esp
    io_wait();
  1044a2:	e8 11 de ff ff       	call   1022b8 <_Z7io_waitv>
    /* Enabled 8086 mode */
    outb(PIC_MASTER_DATA, 0x01);
  1044a7:	83 ec 08             	sub    $0x8,%esp
  1044aa:	6a 01                	push   $0x1
  1044ac:	6a 21                	push   $0x21
  1044ae:	e8 48 dd ff ff       	call   1021fb <_Z4outbth>
  1044b3:	83 c4 10             	add    $0x10,%esp
    io_wait();
  1044b6:	e8 fd dd ff ff       	call   1022b8 <_Z7io_waitv>
    outb(PIC_SLAVE_DATA, 0x01);
  1044bb:	83 ec 08             	sub    $0x8,%esp
  1044be:	6a 01                	push   $0x1
  1044c0:	68 a1 00 00 00       	push   $0xa1
  1044c5:	e8 31 dd ff ff       	call   1021fb <_Z4outbth>
  1044ca:	83 c4 10             	add    $0x10,%esp
    io_wait();
  1044cd:	e8 e6 dd ff ff       	call   1022b8 <_Z7io_waitv>

    puts("Resetting masks");
  1044d2:	83 ec 0c             	sub    $0xc,%esp
  1044d5:	68 a1 a0 10 00       	push   $0x10a0a1
  1044da:	e8 93 2b 00 00       	call   107072 <puts>
  1044df:	83 c4 10             	add    $0x10,%esp
    outb(PIC_MASTER_DATA, 0);
  1044e2:	83 ec 08             	sub    $0x8,%esp
  1044e5:	6a 00                	push   $0x0
  1044e7:	6a 21                	push   $0x21
  1044e9:	e8 0d dd ff ff       	call   1021fb <_Z4outbth>
  1044ee:	83 c4 10             	add    $0x10,%esp
    io_wait();
  1044f1:	e8 c2 dd ff ff       	call   1022b8 <_Z7io_waitv>
    outb(PIC_SLAVE_DATA, 0);
  1044f6:	83 ec 08             	sub    $0x8,%esp
  1044f9:	6a 00                	push   $0x0
  1044fb:	68 a1 00 00 00       	push   $0xa1
  104500:	e8 f6 dc ff ff       	call   1021fb <_Z4outbth>
  104505:	83 c4 10             	add    $0x10,%esp
    io_wait();
  104508:	e8 ab dd ff ff       	call   1022b8 <_Z7io_waitv>
    puts("PIC Init done.");
  10450d:	83 ec 0c             	sub    $0xc,%esp
  104510:	68 b1 a0 10 00       	push   $0x10a0b1
  104515:	e8 58 2b 00 00       	call   107072 <puts>
  10451a:	83 c4 10             	add    $0x10,%esp
}
  10451d:	90                   	nop
  10451e:	83 c4 0c             	add    $0xc,%esp
  104521:	c3                   	ret    

00104522 <_ZN3pic8send_eoiEh>:

void send_eoi(uint8_t irq)
{
  104522:	83 ec 1c             	sub    $0x1c,%esp
  104525:	8b 44 24 20          	mov    0x20(%esp),%eax
  104529:	88 44 24 0c          	mov    %al,0xc(%esp)
    if(irq >= 8)
  10452d:	80 7c 24 0c 07       	cmpb   $0x7,0xc(%esp)
  104532:	76 17                	jbe    10454b <_ZN3pic8send_eoiEh+0x29>
    {
        outb(PIC_SLAVE_CMD, PIC_CMD_EOI);
  104534:	83 ec 08             	sub    $0x8,%esp
  104537:	6a 20                	push   $0x20
  104539:	68 a0 00 00 00       	push   $0xa0
  10453e:	e8 b8 dc ff ff       	call   1021fb <_Z4outbth>
  104543:	83 c4 10             	add    $0x10,%esp
        io_wait();
  104546:	e8 6d dd ff ff       	call   1022b8 <_Z7io_waitv>
    }
    outb(PIC_MASTER_CMD, PIC_CMD_EOI);
  10454b:	83 ec 08             	sub    $0x8,%esp
  10454e:	6a 20                	push   $0x20
  104550:	6a 20                	push   $0x20
  104552:	e8 a4 dc ff ff       	call   1021fb <_Z4outbth>
  104557:	83 c4 10             	add    $0x10,%esp
    io_wait();
  10455a:	e8 59 dd ff ff       	call   1022b8 <_Z7io_waitv>
}
  10455f:	90                   	nop
  104560:	83 c4 1c             	add    $0x1c,%esp
  104563:	c3                   	ret    

00104564 <_ZN3pic8set_maskEh>:

void set_mask(uint8_t irq)
{
  104564:	53                   	push   %ebx
  104565:	83 ec 28             	sub    $0x28,%esp
  104568:	8b 44 24 30          	mov    0x30(%esp),%eax
  10456c:	88 44 24 0c          	mov    %al,0xc(%esp)
    uint16_t port;
    uint8_t value;

    if(irq < 8)
  104570:	80 7c 24 0c 07       	cmpb   $0x7,0xc(%esp)
  104575:	77 09                	ja     104580 <_ZN3pic8set_maskEh+0x1c>
    {
        port = PIC_MASTER_DATA;
  104577:	66 c7 44 24 1e 21 00 	movw   $0x21,0x1e(%esp)
  10457e:	eb 0c                	jmp    10458c <_ZN3pic8set_maskEh+0x28>
    }
    else
    {
        port = PIC_SLAVE_DATA;
  104580:	66 c7 44 24 1e a1 00 	movw   $0xa1,0x1e(%esp)
        irq -= 8;
  104587:	80 6c 24 0c 08       	subb   $0x8,0xc(%esp)
    }
    value = inb(port) | (1 << irq);
  10458c:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
  104591:	83 ec 0c             	sub    $0xc,%esp
  104594:	50                   	push   %eax
  104595:	e8 c0 dc ff ff       	call   10225a <_Z3inbt>
  10459a:	83 c4 10             	add    $0x10,%esp
  10459d:	89 c3                	mov    %eax,%ebx
  10459f:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  1045a4:	ba 01 00 00 00       	mov    $0x1,%edx
  1045a9:	89 c1                	mov    %eax,%ecx
  1045ab:	d3 e2                	shl    %cl,%edx
  1045ad:	89 d0                	mov    %edx,%eax
  1045af:	09 d8                	or     %ebx,%eax
  1045b1:	88 44 24 1d          	mov    %al,0x1d(%esp)
    outb(port, value);
  1045b5:	0f b6 54 24 1d       	movzbl 0x1d(%esp),%edx
  1045ba:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
  1045bf:	83 ec 08             	sub    $0x8,%esp
  1045c2:	52                   	push   %edx
  1045c3:	50                   	push   %eax
  1045c4:	e8 32 dc ff ff       	call   1021fb <_Z4outbth>
  1045c9:	83 c4 10             	add    $0x10,%esp
}
  1045cc:	90                   	nop
  1045cd:	83 c4 28             	add    $0x28,%esp
  1045d0:	5b                   	pop    %ebx
  1045d1:	c3                   	ret    

001045d2 <_ZN3pic14IRQ_clear_maskEh>:

void IRQ_clear_mask(uint8_t irq)
{
  1045d2:	53                   	push   %ebx
  1045d3:	83 ec 28             	sub    $0x28,%esp
  1045d6:	8b 44 24 30          	mov    0x30(%esp),%eax
  1045da:	88 44 24 0c          	mov    %al,0xc(%esp)
    uint16_t port;
    uint8_t value;

    if(irq < 8)
  1045de:	80 7c 24 0c 07       	cmpb   $0x7,0xc(%esp)
  1045e3:	77 09                	ja     1045ee <_ZN3pic14IRQ_clear_maskEh+0x1c>
    {
        port = PIC_MASTER_DATA;
  1045e5:	66 c7 44 24 1e 21 00 	movw   $0x21,0x1e(%esp)
  1045ec:	eb 0c                	jmp    1045fa <_ZN3pic14IRQ_clear_maskEh+0x28>
    }
    else
    {
        port = PIC_SLAVE_DATA;
  1045ee:	66 c7 44 24 1e a1 00 	movw   $0xa1,0x1e(%esp)
        irq -= 8;
  1045f5:	80 6c 24 0c 08       	subb   $0x8,0xc(%esp)
    }
    value = inb(port) & ~(1 << irq);
  1045fa:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
  1045ff:	83 ec 0c             	sub    $0xc,%esp
  104602:	50                   	push   %eax
  104603:	e8 52 dc ff ff       	call   10225a <_Z3inbt>
  104608:	83 c4 10             	add    $0x10,%esp
  10460b:	89 c2                	mov    %eax,%edx
  10460d:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  104612:	bb 01 00 00 00       	mov    $0x1,%ebx
  104617:	89 c1                	mov    %eax,%ecx
  104619:	d3 e3                	shl    %cl,%ebx
  10461b:	89 d8                	mov    %ebx,%eax
  10461d:	f7 d0                	not    %eax
  10461f:	21 d0                	and    %edx,%eax
  104621:	88 44 24 1d          	mov    %al,0x1d(%esp)
    outb(port, value);
  104625:	0f b6 54 24 1d       	movzbl 0x1d(%esp),%edx
  10462a:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
  10462f:	83 ec 08             	sub    $0x8,%esp
  104632:	52                   	push   %edx
  104633:	50                   	push   %eax
  104634:	e8 c2 db ff ff       	call   1021fb <_Z4outbth>
  104639:	83 c4 10             	add    $0x10,%esp
}
  10463c:	90                   	nop
  10463d:	83 c4 28             	add    $0x28,%esp
  104640:	5b                   	pop    %ebx
  104641:	c3                   	ret    

00104642 <_ZN3PIT4initEm>:
#include <io.hpp>
#include "../isr.hpp"
#include "timer.hpp"

void PIT::init(uint32_t freq)
{
  104642:	83 ec 0c             	sub    $0xc,%esp
    isr::register_handler(IRQ0, &irq_callback);
  104645:	83 ec 08             	sub    $0x8,%esp
  104648:	68 50 47 10 00       	push   $0x104750
  10464d:	6a 20                	push   $0x20
  10464f:	e8 03 dd ff ff       	call   102357 <_ZN3isr16register_handlerEhPFvPK9registersE>
  104654:	83 c4 10             	add    $0x10,%esp

    Timer::m_set_frequency_callback = &set_frequency;
  104657:	c7 05 08 f4 11 00 86 	movl   $0x104686,0x11f408
  10465e:	46 10 00 

    Timer::set_frequency(freq);
  104661:	83 ec 0c             	sub    $0xc,%esp
  104664:	ff 74 24 1c          	pushl  0x1c(%esp)
  104668:	e8 f4 33 00 00       	call   107a61 <_ZN5Timer13set_frequencyEm>
  10466d:	83 c4 10             	add    $0x10,%esp

    printf("PIT Timer initialized\n");
  104670:	83 ec 0c             	sub    $0xc,%esp
  104673:	68 e4 a0 10 00       	push   $0x10a0e4
  104678:	e8 55 22 00 00       	call   1068d2 <tfp_printf>
  10467d:	83 c4 10             	add    $0x10,%esp
}
  104680:	90                   	nop
  104681:	83 c4 0c             	add    $0xc,%esp
  104684:	c3                   	ret    
  104685:	90                   	nop

00104686 <_ZN3PIT13set_frequencyEm>:

void PIT::set_frequency(uint32_t freq)
{
  104686:	83 ec 1c             	sub    $0x1c,%esp
    // The value we send to the PIT is the value to divide it's input clock
    // (1193180 Hz) by, to get our required frequency. Important to note is
    // that the divisor must be small enough to fit into 16-bits.
    const uint32_t divisor = 1193180 / freq;
  104689:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
  10468e:	ba 00 00 00 00       	mov    $0x0,%edx
  104693:	f7 74 24 20          	divl   0x20(%esp)
  104697:	89 44 24 0c          	mov    %eax,0xc(%esp)

    // Send the command byte.
    outb(0x43, 0x36);
  10469b:	83 ec 08             	sub    $0x8,%esp
  10469e:	6a 36                	push   $0x36
  1046a0:	6a 43                	push   $0x43
  1046a2:	e8 54 db ff ff       	call   1021fb <_Z4outbth>
  1046a7:	83 c4 10             	add    $0x10,%esp

    // Divisor has to be sent byte-wise, so split here into upper/lower bytes.
    uint8_t l = (uint8_t)(divisor & 0xFF);
  1046aa:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1046ae:	88 44 24 0b          	mov    %al,0xb(%esp)
    uint8_t h = (uint8_t)( (divisor>>8) & 0xFF );
  1046b2:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1046b6:	c1 e8 08             	shr    $0x8,%eax
  1046b9:	88 44 24 0a          	mov    %al,0xa(%esp)

    // Send the frequency divisor.
    outb(0x40, l);
  1046bd:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
  1046c2:	83 ec 08             	sub    $0x8,%esp
  1046c5:	50                   	push   %eax
  1046c6:	6a 40                	push   $0x40
  1046c8:	e8 2e db ff ff       	call   1021fb <_Z4outbth>
  1046cd:	83 c4 10             	add    $0x10,%esp
    outb(0x40, h);
  1046d0:	0f b6 44 24 0a       	movzbl 0xa(%esp),%eax
  1046d5:	83 ec 08             	sub    $0x8,%esp
  1046d8:	50                   	push   %eax
  1046d9:	6a 40                	push   $0x40
  1046db:	e8 1b db ff ff       	call   1021fb <_Z4outbth>
  1046e0:	83 c4 10             	add    $0x10,%esp
}
  1046e3:	90                   	nop
  1046e4:	83 c4 1c             	add    $0x1c,%esp
  1046e7:	c3                   	ret    

001046e8 <_ZN3PIT23set_pcspeaker_frequencyEt>:

void PIT::set_pcspeaker_frequency(uint16_t freq)
{
  1046e8:	83 ec 2c             	sub    $0x2c,%esp
  1046eb:	8b 44 24 30          	mov    0x30(%esp),%eax
  1046ef:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
    const uint16_t div = 1193180 / freq;
  1046f4:	0f b7 4c 24 0c       	movzwl 0xc(%esp),%ecx
  1046f9:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
  1046fe:	99                   	cltd   
  1046ff:	f7 f9                	idiv   %ecx
  104701:	66 89 44 24 1e       	mov    %ax,0x1e(%esp)
    outb(0x43, 0xb6);
  104706:	83 ec 08             	sub    $0x8,%esp
  104709:	68 b6 00 00 00       	push   $0xb6
  10470e:	6a 43                	push   $0x43
  104710:	e8 e6 da ff ff       	call   1021fb <_Z4outbth>
  104715:	83 c4 10             	add    $0x10,%esp
    outb(0x42, (uint8_t) (div) );
  104718:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
  10471d:	0f b6 c0             	movzbl %al,%eax
  104720:	83 ec 08             	sub    $0x8,%esp
  104723:	50                   	push   %eax
  104724:	6a 42                	push   $0x42
  104726:	e8 d0 da ff ff       	call   1021fb <_Z4outbth>
  10472b:	83 c4 10             	add    $0x10,%esp
    outb(0x42, (uint8_t) (div >> 8));
  10472e:	0f b7 44 24 1e       	movzwl 0x1e(%esp),%eax
  104733:	0f b7 c0             	movzwl %ax,%eax
  104736:	c1 f8 08             	sar    $0x8,%eax
  104739:	0f b6 c0             	movzbl %al,%eax
  10473c:	83 ec 08             	sub    $0x8,%esp
  10473f:	50                   	push   %eax
  104740:	6a 42                	push   $0x42
  104742:	e8 b4 da ff ff       	call   1021fb <_Z4outbth>
  104747:	83 c4 10             	add    $0x10,%esp
}
  10474a:	90                   	nop
  10474b:	83 c4 2c             	add    $0x2c,%esp
  10474e:	c3                   	ret    
  10474f:	90                   	nop

00104750 <_ZN3PIT12irq_callbackEPK9registers>:

void PIT::irq_callback(const registers * const)
{
    ++Timer::m_ticks;
  104750:	a1 d4 ef 11 00       	mov    0x11efd4,%eax
  104755:	83 c0 01             	add    $0x1,%eax
  104758:	a3 d4 ef 11 00       	mov    %eax,0x11efd4
}
  10475d:	90                   	nop
  10475e:	c3                   	ret    
  10475f:	90                   	nop

00104760 <_ZN7Speaker4beepEmt>:
#include "io.hpp"
#include "pit.hpp"
#include "timer.hpp"

void Speaker::beep(uint32_t time, uint16_t freq)
{
  104760:	83 ec 1c             	sub    $0x1c,%esp
  104763:	8b 44 24 24          	mov    0x24(%esp),%eax
  104767:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
    play_sound(freq);
  10476c:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
  104771:	83 ec 0c             	sub    $0xc,%esp
  104774:	50                   	push   %eax
  104775:	e8 1c 00 00 00       	call   104796 <_ZN7Speaker10play_soundEt>
  10477a:	83 c4 10             	add    $0x10,%esp
    Timer::sleep(time);
  10477d:	83 ec 0c             	sub    $0xc,%esp
  104780:	ff 74 24 2c          	pushl  0x2c(%esp)
  104784:	e8 10 33 00 00       	call   107a99 <_ZN5Timer5sleepEm>
  104789:	83 c4 10             	add    $0x10,%esp
    stop();
  10478c:	e8 5f 00 00 00       	call   1047f0 <_ZN7Speaker4stopEv>
}
  104791:	90                   	nop
  104792:	83 c4 1c             	add    $0x1c,%esp
  104795:	c3                   	ret    

00104796 <_ZN7Speaker10play_soundEt>:

void Speaker::play_sound(uint16_t freq)
{
  104796:	83 ec 2c             	sub    $0x2c,%esp
  104799:	8b 44 24 30          	mov    0x30(%esp),%eax
  10479d:	66 89 44 24 0c       	mov    %ax,0xc(%esp)
    PIT::set_pcspeaker_frequency(freq);
  1047a2:	0f b7 44 24 0c       	movzwl 0xc(%esp),%eax
  1047a7:	83 ec 0c             	sub    $0xc,%esp
  1047aa:	50                   	push   %eax
  1047ab:	e8 38 ff ff ff       	call   1046e8 <_ZN3PIT23set_pcspeaker_frequencyEt>
  1047b0:	83 c4 10             	add    $0x10,%esp

    uint8_t tmp = inb(0x61);
  1047b3:	83 ec 0c             	sub    $0xc,%esp
  1047b6:	6a 61                	push   $0x61
  1047b8:	e8 9d da ff ff       	call   10225a <_Z3inbt>
  1047bd:	83 c4 10             	add    $0x10,%esp
  1047c0:	88 44 24 1f          	mov    %al,0x1f(%esp)
    if (tmp != (tmp | 3))
  1047c4:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  1047c9:	83 c8 03             	or     $0x3,%eax
  1047cc:	38 44 24 1f          	cmp    %al,0x1f(%esp)
  1047d0:	74 19                	je     1047eb <_ZN7Speaker10play_soundEt+0x55>
    {
        outb(0x61, tmp | 3);
  1047d2:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  1047d7:	83 c8 03             	or     $0x3,%eax
  1047da:	0f b6 c0             	movzbl %al,%eax
  1047dd:	83 ec 08             	sub    $0x8,%esp
  1047e0:	50                   	push   %eax
  1047e1:	6a 61                	push   $0x61
  1047e3:	e8 13 da ff ff       	call   1021fb <_Z4outbth>
  1047e8:	83 c4 10             	add    $0x10,%esp
    }
}
  1047eb:	90                   	nop
  1047ec:	83 c4 2c             	add    $0x2c,%esp
  1047ef:	c3                   	ret    

001047f0 <_ZN7Speaker4stopEv>:

void Speaker::stop()
{
  1047f0:	83 ec 1c             	sub    $0x1c,%esp
    uint8_t tmp = inb(0x61) & 0xFC;
  1047f3:	83 ec 0c             	sub    $0xc,%esp
  1047f6:	6a 61                	push   $0x61
  1047f8:	e8 5d da ff ff       	call   10225a <_Z3inbt>
  1047fd:	83 c4 10             	add    $0x10,%esp
  104800:	83 e0 fc             	and    $0xfffffffc,%eax
  104803:	88 44 24 0f          	mov    %al,0xf(%esp)

    outb(0x61, tmp);
  104807:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
  10480c:	83 ec 08             	sub    $0x8,%esp
  10480f:	50                   	push   %eax
  104810:	6a 61                	push   $0x61
  104812:	e8 e4 d9 ff ff       	call   1021fb <_Z4outbth>
  104817:	83 c4 10             	add    $0x10,%esp
}
  10481a:	90                   	nop
  10481b:	83 c4 1c             	add    $0x1c,%esp
  10481e:	c3                   	ret    
  10481f:	90                   	nop

00104820 <_ZZ5kmainENKUlPvcE_clES_c>:
extern "C" uint32_t kernel_physical_end;

extern "C"
void kmain(uint32_t magic, const multiboot_info_t* mbd_info)
{
    init_printf(nullptr, [](void*, char c){putchar(c);});
  104820:	83 ec 1c             	sub    $0x1c,%esp
  104823:	8b 44 24 28          	mov    0x28(%esp),%eax
  104827:	88 44 24 0c          	mov    %al,0xc(%esp)
  10482b:	0f be 44 24 0c       	movsbl 0xc(%esp),%eax
  104830:	83 ec 0c             	sub    $0xc,%esp
  104833:	50                   	push   %eax
  104834:	e8 bf 27 00 00       	call   106ff8 <putchar>
  104839:	83 c4 10             	add    $0x10,%esp
  10483c:	90                   	nop
  10483d:	83 c4 1c             	add    $0x1c,%esp
  104840:	c3                   	ret    

00104841 <_ZZ5kmainENUlPvcE_4_FUNES_c>:
  104841:	83 ec 1c             	sub    $0x1c,%esp
  104844:	8b 44 24 24          	mov    0x24(%esp),%eax
  104848:	88 44 24 0c          	mov    %al,0xc(%esp)
  10484c:	83 ec 04             	sub    $0x4,%esp
  10484f:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
  104854:	50                   	push   %eax
  104855:	ff 74 24 28          	pushl  0x28(%esp)
  104859:	6a 00                	push   $0x0
  10485b:	e8 c0 ff ff ff       	call   104820 <_ZZ5kmainENKUlPvcE_clES_c>
  104860:	83 c4 10             	add    $0x10,%esp
  104863:	83 c4 1c             	add    $0x1c,%esp
  104866:	c3                   	ret    
  104867:	90                   	nop

00104868 <_ZZ5kmainENKUlPvcE_cvPFvS_cEEv>:
  104868:	b8 41 48 10 00       	mov    $0x104841,%eax
  10486d:	c3                   	ret    

0010486e <kmain>:
{
  10486e:	83 ec 1c             	sub    $0x1c,%esp
    init_printf(nullptr, [](void*, char c){putchar(c);});
  104871:	8d 44 24 0f          	lea    0xf(%esp),%eax
  104875:	50                   	push   %eax
  104876:	e8 ed ff ff ff       	call   104868 <_ZZ5kmainENKUlPvcE_cvPFvS_cEEv>
  10487b:	83 c4 04             	add    $0x4,%esp
  10487e:	83 ec 08             	sub    $0x8,%esp
  104881:	50                   	push   %eax
  104882:	6a 00                	push   $0x0
  104884:	e8 10 20 00 00       	call   106899 <init_printf>
  104889:	83 c4 10             	add    $0x10,%esp

    multiboot::check(magic, mbd, mbd_info);
  10488c:	83 ec 04             	sub    $0x4,%esp
  10488f:	ff 74 24 28          	pushl  0x28(%esp)
  104893:	68 00 00 10 00       	push   $0x100000
  104898:	ff 74 24 2c          	pushl  0x2c(%esp)
  10489c:	e8 ef f2 ff ff       	call   103b90 <_ZN9multiboot5checkEmRK16multiboot_headerPK14multiboot_info>
  1048a1:	83 c4 10             	add    $0x10,%esp
    gdt::init();
  1048a4:	e8 42 d2 ff ff       	call   101aeb <_ZN3gdt4initEv>
    pic::init();
  1048a9:	e8 65 fb ff ff       	call   104413 <_ZN3pic4initEv>
    idt::init();
  1048ae:	e8 18 d4 ff ff       	call   101ccb <_ZN3idt4initEv>
    PIT::init(100);
  1048b3:	83 ec 0c             	sub    $0xc,%esp
  1048b6:	6a 64                	push   $0x64
  1048b8:	e8 85 fd ff ff       	call   104642 <_ZN3PIT4initEm>
  1048bd:	83 c4 10             	add    $0x10,%esp
    FPU::init();
  1048c0:	e8 7d d0 ff ff       	call   101942 <_ZN3FPU4initEv>
    multiboot::parse_info(mbd_info);
  1048c5:	83 ec 0c             	sub    $0xc,%esp
  1048c8:	ff 74 24 30          	pushl  0x30(%esp)
  1048cc:	e8 1f f3 ff ff       	call   103bf0 <_ZN9multiboot10parse_infoEPK14multiboot_info>
  1048d1:	83 c4 10             	add    $0x10,%esp

    log("CPU clock speed : ~%lu MHz\n", clock_speed());
  1048d4:	83 ec 0c             	sub    $0xc,%esp
  1048d7:	6a 00                	push   $0x0
  1048d9:	e8 9e 2e 00 00       	call   10777c <_Z11clock_speedb>
  1048de:	83 c4 10             	add    $0x10,%esp
  1048e1:	83 ec 04             	sub    $0x4,%esp
  1048e4:	52                   	push   %edx
  1048e5:	50                   	push   %eax
  1048e6:	68 2e a4 10 00       	push   $0x10a42e
  1048eb:	e8 38 2b 00 00       	call   107428 <_Z3logPKcz>
  1048f0:	83 c4 10             	add    $0x10,%esp
    detect_cpu();
  1048f3:	e8 08 c7 ff ff       	call   101000 <_Z10detect_cpuv>
    Paging::init();
  1048f8:	e8 e1 db ff ff       	call   1024de <_ZN6Paging4initEv>

    Speaker::beep(200);
  1048fd:	83 ec 08             	sub    $0x8,%esp
  104900:	68 e8 03 00 00       	push   $0x3e8
  104905:	68 c8 00 00 00       	push   $0xc8
  10490a:	e8 51 fe ff ff       	call   104760 <_ZN7Speaker4beepEmt>
  10490f:	83 c4 10             	add    $0x10,%esp

    SMBIOS::locate();
  104912:	e8 97 dd ff ff       	call   1026ae <_ZN6SMBIOS6locateEv>
    SMBIOS::bios_info();
  104917:	e8 02 df ff ff       	call   10281e <_ZN6SMBIOS9bios_infoEv>
    SMBIOS::cpu_info();
  10491c:	e8 71 e0 ff ff       	call   102992 <_ZN6SMBIOS8cpu_infoEv>

    Keyboard::init();
  104921:	e8 f8 f5 ff ff       	call   103f1e <_ZN8Keyboard4initEv>
    Keyboard::handle_char = &Terminal::put_char;
  104926:	c7 05 ec ef 11 00 dd 	movl   $0x107add,0x11efec
  10492d:	7a 10 00 
    Keyboard::set_kbdmap(kbdmap_fr);
  104930:	83 ec 0c             	sub    $0xc,%esp
  104933:	68 a0 a2 10 00       	push   $0x10a2a0
  104938:	e8 e3 f6 ff ff       	call   104020 <_ZN8Keyboard10set_kbdmapEPKh>
  10493d:	83 c4 10             	add    $0x10,%esp

    greet();
  104940:	e8 7d f4 ff ff       	call   103dc2 <_Z5greetv>

    log("%p", &kernel_physical_end);
  104945:	83 ec 08             	sub    $0x8,%esp
  104948:	68 60 53 11 00       	push   $0x115360
  10494d:	68 4a a4 10 00       	push   $0x10a44a
  104952:	e8 d1 2a 00 00       	call   107428 <_Z3logPKcz>
  104957:	83 c4 10             	add    $0x10,%esp

//    liballoc_dump();

    while (1)
    {
        NOP();
  10495a:	90                   	nop
  10495b:	eb fd                	jmp    10495a <kmain+0xec>

0010495d <_Z41__static_initialization_and_destruction_0ii>:
    }
}
  10495d:	83 ec 0c             	sub    $0xc,%esp
  104960:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  104965:	75 2e                	jne    104995 <_Z41__static_initialization_and_destruction_0ii+0x38>
  104967:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  10496e:	00 
  10496f:	75 24                	jne    104995 <_Z41__static_initialization_and_destruction_0ii+0x38>
  104971:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  104976:	0f b6 00             	movzbl (%eax),%eax
  104979:	84 c0                	test   %al,%al
  10497b:	75 18                	jne    104995 <_Z41__static_initialization_and_destruction_0ii+0x38>
  10497d:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  104982:	c6 00 01             	movb   $0x1,(%eax)
  104985:	83 ec 0c             	sub    $0xc,%esp
  104988:	68 60 53 11 00       	push   $0x115360
  10498d:	e8 a8 e7 ff ff       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  104992:	83 c4 10             	add    $0x10,%esp
  104995:	90                   	nop
  104996:	83 c4 0c             	add    $0xc,%esp
  104999:	c3                   	ret    

0010499a <_GLOBAL__sub_I_kmain>:
  10499a:	83 ec 0c             	sub    $0xc,%esp
  10499d:	83 ec 08             	sub    $0x8,%esp
  1049a0:	68 ff ff 00 00       	push   $0xffff
  1049a5:	6a 01                	push   $0x1
  1049a7:	e8 b1 ff ff ff       	call   10495d <_Z41__static_initialization_and_destruction_0ii>
  1049ac:	83 c4 10             	add    $0x10,%esp
  1049af:	83 c4 0c             	add    $0xc,%esp
  1049b2:	c3                   	ret    
  1049b3:	90                   	nop

001049b4 <_ZZ5panicPKczENKUlPvcE_clES1_c>:

    puts("\nKERNEL PANIC : ");

    va_list va;
    va_start(va, fmt);
    tfp_format(nullptr, [](void*, char c){putchar(c);}, fmt, va);
  1049b4:	83 ec 1c             	sub    $0x1c,%esp
  1049b7:	8b 44 24 28          	mov    0x28(%esp),%eax
  1049bb:	88 44 24 0c          	mov    %al,0xc(%esp)
  1049bf:	0f be 44 24 0c       	movsbl 0xc(%esp),%eax
  1049c4:	83 ec 0c             	sub    $0xc,%esp
  1049c7:	50                   	push   %eax
  1049c8:	e8 2b 26 00 00       	call   106ff8 <putchar>
  1049cd:	83 c4 10             	add    $0x10,%esp
  1049d0:	90                   	nop
  1049d1:	83 c4 1c             	add    $0x1c,%esp
  1049d4:	c3                   	ret    

001049d5 <_ZZ5panicPKczENUlPvcE_4_FUNES1_c>:
  1049d5:	83 ec 1c             	sub    $0x1c,%esp
  1049d8:	8b 44 24 24          	mov    0x24(%esp),%eax
  1049dc:	88 44 24 0c          	mov    %al,0xc(%esp)
  1049e0:	83 ec 04             	sub    $0x4,%esp
  1049e3:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
  1049e8:	50                   	push   %eax
  1049e9:	ff 74 24 28          	pushl  0x28(%esp)
  1049ed:	6a 00                	push   $0x0
  1049ef:	e8 c0 ff ff ff       	call   1049b4 <_ZZ5panicPKczENKUlPvcE_clES1_c>
  1049f4:	83 c4 10             	add    $0x10,%esp
  1049f7:	83 c4 1c             	add    $0x1c,%esp
  1049fa:	c3                   	ret    
  1049fb:	90                   	nop

001049fc <_ZZ5panicPKczENKUlPvcE_cvPFvS1_cEEv>:
  1049fc:	b8 d5 49 10 00       	mov    $0x1049d5,%eax
  104a01:	c3                   	ret    

00104a02 <_Z5panicPKcz>:
{
  104a02:	53                   	push   %ebx
  104a03:	83 ec 18             	sub    $0x18,%esp
    Terminal::set_color(VGA_COLOR_RED);
  104a06:	83 ec 0c             	sub    $0xc,%esp
  104a09:	6a 04                	push   $0x4
  104a0b:	e8 f3 30 00 00       	call   107b03 <_ZN8Terminal9set_colorEh>
  104a10:	83 c4 10             	add    $0x10,%esp
    cli();
  104a13:	e8 11 31 00 00       	call   107b29 <_Z3cliv>
    puts("\nKERNEL PANIC : ");
  104a18:	83 ec 0c             	sub    $0xc,%esp
  104a1b:	68 54 a4 10 00       	push   $0x10a454
  104a20:	e8 4d 26 00 00       	call   107072 <puts>
  104a25:	83 c4 10             	add    $0x10,%esp
    va_start(va, fmt);
  104a28:	8d 44 24 24          	lea    0x24(%esp),%eax
  104a2c:	89 44 24 08          	mov    %eax,0x8(%esp)
    tfp_format(nullptr, [](void*, char c){putchar(c);}, fmt, va);
  104a30:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  104a34:	83 ec 0c             	sub    $0xc,%esp
  104a37:	8d 44 24 1b          	lea    0x1b(%esp),%eax
  104a3b:	50                   	push   %eax
  104a3c:	e8 bb ff ff ff       	call   1049fc <_ZZ5panicPKczENKUlPvcE_cvPFvS1_cEEv>
  104a41:	83 c4 10             	add    $0x10,%esp
  104a44:	53                   	push   %ebx
  104a45:	ff 74 24 24          	pushl  0x24(%esp)
  104a49:	50                   	push   %eax
  104a4a:	6a 00                	push   $0x0
  104a4c:	e8 b5 18 00 00       	call   106306 <tfp_format>
  104a51:	83 c4 10             	add    $0x10,%esp
    va_end(va);
    halt();
  104a54:	e8 d3 30 00 00       	call   107b2c <_Z4haltv>

00104a59 <_Z41__static_initialization_and_destruction_0ii>:
}
  104a59:	83 ec 0c             	sub    $0xc,%esp
  104a5c:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  104a61:	75 2e                	jne    104a91 <_Z41__static_initialization_and_destruction_0ii+0x38>
  104a63:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  104a6a:	00 
  104a6b:	75 24                	jne    104a91 <_Z41__static_initialization_and_destruction_0ii+0x38>
  104a6d:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  104a72:	0f b6 00             	movzbl (%eax),%eax
  104a75:	84 c0                	test   %al,%al
  104a77:	75 18                	jne    104a91 <_Z41__static_initialization_and_destruction_0ii+0x38>
  104a79:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  104a7e:	c6 00 01             	movb   $0x1,(%eax)
  104a81:	83 ec 0c             	sub    $0xc,%esp
  104a84:	68 60 53 11 00       	push   $0x115360
  104a89:	e8 ac e6 ff ff       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  104a8e:	83 c4 10             	add    $0x10,%esp
  104a91:	90                   	nop
  104a92:	83 c4 0c             	add    $0xc,%esp
  104a95:	c3                   	ret    

00104a96 <_GLOBAL__sub_I__Z5panicPKcz>:
  104a96:	83 ec 0c             	sub    $0xc,%esp
  104a99:	83 ec 08             	sub    $0x8,%esp
  104a9c:	68 ff ff 00 00       	push   $0xffff
  104aa1:	6a 01                	push   $0x1
  104aa3:	e8 b1 ff ff ff       	call   104a59 <_Z41__static_initialization_and_destruction_0ii>
  104aa8:	83 c4 10             	add    $0x10,%esp
  104aab:	83 c4 0c             	add    $0xc,%esp
  104aae:	c3                   	ret    

00104aaf <liballoc_memset>:


// ***********   HELPER FUNCTIONS  *******************************

static void *liballoc_memset(void* s, int c, size_t n)
{
  104aaf:	83 ec 10             	sub    $0x10,%esp
	unsigned int i;
	for ( i = 0; i < n ; i++)
  104ab2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  104ab9:	00 
  104aba:	eb 15                	jmp    104ad1 <liballoc_memset+0x22>
		((char*)s)[i] = c;
  104abc:	8b 54 24 14          	mov    0x14(%esp),%edx
  104ac0:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104ac4:	01 d0                	add    %edx,%eax
  104ac6:	8b 54 24 18          	mov    0x18(%esp),%edx
  104aca:	88 10                	mov    %dl,(%eax)
	for ( i = 0; i < n ; i++)
  104acc:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
  104ad1:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104ad5:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
  104ad9:	72 e1                	jb     104abc <liballoc_memset+0xd>
	
	return s;
  104adb:	8b 44 24 14          	mov    0x14(%esp),%eax
}
  104adf:	83 c4 10             	add    $0x10,%esp
  104ae2:	c3                   	ret    

00104ae3 <liballoc_memcpy>:
static void* liballoc_memcpy(void* s1, const void* s2, size_t n)
{
  104ae3:	83 ec 10             	sub    $0x10,%esp
  char *cdest;
  char *csrc;
  unsigned int *ldest = (unsigned int*)s1;
  104ae6:	8b 44 24 14          	mov    0x14(%esp),%eax
  104aea:	89 44 24 04          	mov    %eax,0x4(%esp)
  unsigned int *lsrc  = (unsigned int*)s2;
  104aee:	8b 44 24 18          	mov    0x18(%esp),%eax
  104af2:	89 04 24             	mov    %eax,(%esp)

  while ( n >= sizeof(unsigned int) )
  104af5:	eb 1d                	jmp    104b14 <liballoc_memcpy+0x31>
  {
      *ldest++ = *lsrc++;
  104af7:	8b 14 24             	mov    (%esp),%edx
  104afa:	8d 42 04             	lea    0x4(%edx),%eax
  104afd:	89 04 24             	mov    %eax,(%esp)
  104b00:	8b 44 24 04          	mov    0x4(%esp),%eax
  104b04:	8d 48 04             	lea    0x4(%eax),%ecx
  104b07:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104b0b:	8b 12                	mov    (%edx),%edx
  104b0d:	89 10                	mov    %edx,(%eax)
	  n -= sizeof(unsigned int);
  104b0f:	83 6c 24 1c 04       	subl   $0x4,0x1c(%esp)
  while ( n >= sizeof(unsigned int) )
  104b14:	83 7c 24 1c 03       	cmpl   $0x3,0x1c(%esp)
  104b19:	77 dc                	ja     104af7 <liballoc_memcpy+0x14>
  }

  cdest = (char*)ldest;
  104b1b:	8b 44 24 04          	mov    0x4(%esp),%eax
  104b1f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  csrc  = (char*)lsrc;
  104b23:	8b 04 24             	mov    (%esp),%eax
  104b26:	89 44 24 08          	mov    %eax,0x8(%esp)
  
  while ( n > 0 )
  104b2a:	eb 20                	jmp    104b4c <liballoc_memcpy+0x69>
  {
      *cdest++ = *csrc++;
  104b2c:	8b 54 24 08          	mov    0x8(%esp),%edx
  104b30:	8d 42 01             	lea    0x1(%edx),%eax
  104b33:	89 44 24 08          	mov    %eax,0x8(%esp)
  104b37:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104b3b:	8d 48 01             	lea    0x1(%eax),%ecx
  104b3e:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  104b42:	0f b6 12             	movzbl (%edx),%edx
  104b45:	88 10                	mov    %dl,(%eax)
	  n -= 1;
  104b47:	83 6c 24 1c 01       	subl   $0x1,0x1c(%esp)
  while ( n > 0 )
  104b4c:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  104b51:	75 d9                	jne    104b2c <liballoc_memcpy+0x49>
  }
  
  return s1;
  104b53:	8b 44 24 14          	mov    0x14(%esp),%eax
}
  104b57:	83 c4 10             	add    $0x10,%esp
  104b5a:	c3                   	ret    

00104b5b <liballoc_dump>:
 

#if defined DEBUG || defined INFO
void liballoc_dump()
{
  104b5b:	83 ec 1c             	sub    $0x1c,%esp
#ifdef DEBUG
	struct liballoc_major *maj = l_memRoot;
  104b5e:	a1 28 53 11 00       	mov    0x115328,%eax
  104b63:	89 44 24 0c          	mov    %eax,0xc(%esp)
	struct liballoc_minor *min = NULL;
  104b67:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  104b6e:	00 
#endif

	printf( "liballoc: ------ Memory data ---------------\n");
  104b6f:	83 ec 0c             	sub    $0xc,%esp
  104b72:	68 68 a4 10 00       	push   $0x10a468
  104b77:	e8 56 1d 00 00       	call   1068d2 <tfp_printf>
  104b7c:	83 c4 10             	add    $0x10,%esp
	printf( "liballoc: System memory allocated: %i bytes\n", l_allocated );
  104b7f:	a1 30 53 11 00       	mov    0x115330,%eax
  104b84:	8b 15 34 53 11 00    	mov    0x115334,%edx
  104b8a:	83 ec 04             	sub    $0x4,%esp
  104b8d:	52                   	push   %edx
  104b8e:	50                   	push   %eax
  104b8f:	68 98 a4 10 00       	push   $0x10a498
  104b94:	e8 39 1d 00 00       	call   1068d2 <tfp_printf>
  104b99:	83 c4 10             	add    $0x10,%esp
	printf( "liballoc: Memory in used (malloc'ed): %i bytes\n", l_inuse );
  104b9c:	a1 38 53 11 00       	mov    0x115338,%eax
  104ba1:	8b 15 3c 53 11 00    	mov    0x11533c,%edx
  104ba7:	83 ec 04             	sub    $0x4,%esp
  104baa:	52                   	push   %edx
  104bab:	50                   	push   %eax
  104bac:	68 c8 a4 10 00       	push   $0x10a4c8
  104bb1:	e8 1c 1d 00 00       	call   1068d2 <tfp_printf>
  104bb6:	83 c4 10             	add    $0x10,%esp
	printf( "liballoc: Warning count: %i\n", l_warningCount );
  104bb9:	a1 40 53 11 00       	mov    0x115340,%eax
  104bbe:	8b 15 44 53 11 00    	mov    0x115344,%edx
  104bc4:	83 ec 04             	sub    $0x4,%esp
  104bc7:	52                   	push   %edx
  104bc8:	50                   	push   %eax
  104bc9:	68 f8 a4 10 00       	push   $0x10a4f8
  104bce:	e8 ff 1c 00 00       	call   1068d2 <tfp_printf>
  104bd3:	83 c4 10             	add    $0x10,%esp
	printf( "liballoc: Error count: %i\n", l_errorCount );
  104bd6:	a1 48 53 11 00       	mov    0x115348,%eax
  104bdb:	8b 15 4c 53 11 00    	mov    0x11534c,%edx
  104be1:	83 ec 04             	sub    $0x4,%esp
  104be4:	52                   	push   %edx
  104be5:	50                   	push   %eax
  104be6:	68 15 a5 10 00       	push   $0x10a515
  104beb:	e8 e2 1c 00 00       	call   1068d2 <tfp_printf>
  104bf0:	83 c4 10             	add    $0x10,%esp
	printf( "liballoc: Possible overruns: %i\n", l_possibleOverruns );
  104bf3:	a1 50 53 11 00       	mov    0x115350,%eax
  104bf8:	8b 15 54 53 11 00    	mov    0x115354,%edx
  104bfe:	83 ec 04             	sub    $0x4,%esp
  104c01:	52                   	push   %edx
  104c02:	50                   	push   %eax
  104c03:	68 30 a5 10 00       	push   $0x10a530
  104c08:	e8 c5 1c 00 00       	call   1068d2 <tfp_printf>
  104c0d:	83 c4 10             	add    $0x10,%esp

#ifdef DEBUG
		while ( maj != NULL )
  104c10:	eb 67                	jmp    104c79 <liballoc_dump+0x11e>
		{
			printf( "liballoc: %x: total = %i, used = %i\n",
  104c12:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104c16:	8b 50 10             	mov    0x10(%eax),%edx
  104c19:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104c1d:	8b 40 0c             	mov    0xc(%eax),%eax
  104c20:	52                   	push   %edx
  104c21:	50                   	push   %eax
  104c22:	ff 74 24 14          	pushl  0x14(%esp)
  104c26:	68 54 a5 10 00       	push   $0x10a554
  104c2b:	e8 a2 1c 00 00       	call   1068d2 <tfp_printf>
  104c30:	83 c4 10             	add    $0x10,%esp
						maj, 
						maj->size,
						maj->usage );

			min = maj->first;
  104c33:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104c37:	8b 40 14             	mov    0x14(%eax),%eax
  104c3a:	89 44 24 08          	mov    %eax,0x8(%esp)
			while ( min != NULL )
  104c3e:	eb 27                	jmp    104c67 <liballoc_dump+0x10c>
			{
				printf( "liballoc:    %x: %i bytes\n",
  104c40:	8b 44 24 08          	mov    0x8(%esp),%eax
  104c44:	8b 40 10             	mov    0x10(%eax),%eax
  104c47:	83 ec 04             	sub    $0x4,%esp
  104c4a:	50                   	push   %eax
  104c4b:	ff 74 24 10          	pushl  0x10(%esp)
  104c4f:	68 79 a5 10 00       	push   $0x10a579
  104c54:	e8 79 1c 00 00       	call   1068d2 <tfp_printf>
  104c59:	83 c4 10             	add    $0x10,%esp
							min, 
							min->size );
				min = min->next;
  104c5c:	8b 44 24 08          	mov    0x8(%esp),%eax
  104c60:	8b 40 04             	mov    0x4(%eax),%eax
  104c63:	89 44 24 08          	mov    %eax,0x8(%esp)
			while ( min != NULL )
  104c67:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  104c6c:	75 d2                	jne    104c40 <liballoc_dump+0xe5>
			}

			maj = maj->next;
  104c6e:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104c72:	8b 40 04             	mov    0x4(%eax),%eax
  104c75:	89 44 24 0c          	mov    %eax,0xc(%esp)
		while ( maj != NULL )
  104c79:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
  104c7e:	75 92                	jne    104c12 <liballoc_dump+0xb7>
		}
#endif

	FLUSH();
}
  104c80:	90                   	nop
  104c81:	83 c4 1c             	add    $0x1c,%esp
  104c84:	c3                   	ret    

00104c85 <allocate_new_page>:


// ***************************************************************

static struct liballoc_major *allocate_new_page( unsigned int size )
{
  104c85:	53                   	push   %ebx
  104c86:	83 ec 18             	sub    $0x18,%esp
	unsigned int st;
	struct liballoc_major *maj;

		// This is how much space is required.
		st  = size + sizeof(struct liballoc_major);
  104c89:	8b 44 24 20          	mov    0x20(%esp),%eax
  104c8d:	83 c0 18             	add    $0x18,%eax
  104c90:	89 44 24 0c          	mov    %eax,0xc(%esp)
		st += sizeof(struct liballoc_minor);
  104c94:	83 44 24 0c 18       	addl   $0x18,0xc(%esp)

				// Perfect amount of space?
		if ( (st % l_pageSize) == 0 )
  104c99:	8b 0d 00 00 11 00    	mov    0x110000,%ecx
  104c9f:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104ca3:	ba 00 00 00 00       	mov    $0x0,%edx
  104ca8:	f7 f1                	div    %ecx
  104caa:	89 d0                	mov    %edx,%eax
  104cac:	85 c0                	test   %eax,%eax
  104cae:	75 17                	jne    104cc7 <allocate_new_page+0x42>
			st  = st / (l_pageSize);
  104cb0:	8b 1d 00 00 11 00    	mov    0x110000,%ebx
  104cb6:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104cba:	ba 00 00 00 00       	mov    $0x0,%edx
  104cbf:	f7 f3                	div    %ebx
  104cc1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  104cc5:	eb 18                	jmp    104cdf <allocate_new_page+0x5a>
		else
			st  = st / (l_pageSize) + 1;
  104cc7:	8b 1d 00 00 11 00    	mov    0x110000,%ebx
  104ccd:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104cd1:	ba 00 00 00 00       	mov    $0x0,%edx
  104cd6:	f7 f3                	div    %ebx
  104cd8:	83 c0 01             	add    $0x1,%eax
  104cdb:	89 44 24 0c          	mov    %eax,0xc(%esp)
							// No, add the buffer. 

		
		// Make sure it's >= the minimum size.
		if ( st < l_pageCount ) st = l_pageCount;
  104cdf:	a1 04 00 11 00       	mov    0x110004,%eax
  104ce4:	39 44 24 0c          	cmp    %eax,0xc(%esp)
  104ce8:	73 09                	jae    104cf3 <allocate_new_page+0x6e>
  104cea:	a1 04 00 11 00       	mov    0x110004,%eax
  104cef:	89 44 24 0c          	mov    %eax,0xc(%esp)
		
		maj = (struct liballoc_major*)liballoc_alloc( st );
  104cf3:	83 ec 0c             	sub    $0xc,%esp
  104cf6:	ff 74 24 18          	pushl  0x18(%esp)
  104cfa:	e8 bf f0 ff ff       	call   103dbe <liballoc_alloc>
  104cff:	83 c4 10             	add    $0x10,%esp
  104d02:	89 44 24 08          	mov    %eax,0x8(%esp)

		if ( maj == NULL ) 
  104d06:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  104d0b:	75 3a                	jne    104d47 <allocate_new_page+0xc2>
		{
			l_warningCount += 1;
  104d0d:	a1 40 53 11 00       	mov    0x115340,%eax
  104d12:	8b 15 44 53 11 00    	mov    0x115344,%edx
  104d18:	83 c0 01             	add    $0x1,%eax
  104d1b:	83 d2 00             	adc    $0x0,%edx
  104d1e:	a3 40 53 11 00       	mov    %eax,0x115340
  104d23:	89 15 44 53 11 00    	mov    %edx,0x115344
			#if defined DEBUG || defined INFO
			printf( "liballoc: WARNING: liballoc_alloc( %i ) return NULL\n", st );
  104d29:	83 ec 08             	sub    $0x8,%esp
  104d2c:	ff 74 24 14          	pushl  0x14(%esp)
  104d30:	68 94 a5 10 00       	push   $0x10a594
  104d35:	e8 98 1b 00 00       	call   1068d2 <tfp_printf>
  104d3a:	83 c4 10             	add    $0x10,%esp
			FLUSH();
			#endif
			return NULL;	// uh oh, we ran out of memory.
  104d3d:	b8 00 00 00 00       	mov    $0x0,%eax
  104d42:	e9 c1 00 00 00       	jmp    104e08 <allocate_new_page+0x183>
		}
		
		maj->prev 	= NULL;
  104d47:	8b 44 24 08          	mov    0x8(%esp),%eax
  104d4b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		maj->next 	= NULL;
  104d51:	8b 44 24 08          	mov    0x8(%esp),%eax
  104d55:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		maj->pages 	= st;
  104d5c:	8b 44 24 08          	mov    0x8(%esp),%eax
  104d60:	8b 54 24 0c          	mov    0xc(%esp),%edx
  104d64:	89 50 08             	mov    %edx,0x8(%eax)
		maj->size 	= st * l_pageSize;
  104d67:	a1 00 00 11 00       	mov    0x110000,%eax
  104d6c:	0f af 44 24 0c       	imul   0xc(%esp),%eax
  104d71:	89 c2                	mov    %eax,%edx
  104d73:	8b 44 24 08          	mov    0x8(%esp),%eax
  104d77:	89 50 0c             	mov    %edx,0xc(%eax)
		maj->usage 	= sizeof(struct liballoc_major);
  104d7a:	8b 44 24 08          	mov    0x8(%esp),%eax
  104d7e:	c7 40 10 18 00 00 00 	movl   $0x18,0x10(%eax)
		maj->first 	= NULL;
  104d85:	8b 44 24 08          	mov    0x8(%esp),%eax
  104d89:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

		l_allocated += maj->size;
  104d90:	8b 44 24 08          	mov    0x8(%esp),%eax
  104d94:	8b 40 0c             	mov    0xc(%eax),%eax
  104d97:	89 c1                	mov    %eax,%ecx
  104d99:	bb 00 00 00 00       	mov    $0x0,%ebx
  104d9e:	a1 30 53 11 00       	mov    0x115330,%eax
  104da3:	8b 15 34 53 11 00    	mov    0x115334,%edx
  104da9:	01 c8                	add    %ecx,%eax
  104dab:	11 da                	adc    %ebx,%edx
  104dad:	a3 30 53 11 00       	mov    %eax,0x115330
  104db2:	89 15 34 53 11 00    	mov    %edx,0x115334

		#ifdef DEBUG
		printf( "liballoc: Resource allocated %x of %i pages (%i bytes) for %i size.\n", maj, st, maj->size, size );
  104db8:	8b 44 24 08          	mov    0x8(%esp),%eax
  104dbc:	8b 40 0c             	mov    0xc(%eax),%eax
  104dbf:	83 ec 0c             	sub    $0xc,%esp
  104dc2:	ff 74 24 2c          	pushl  0x2c(%esp)
  104dc6:	50                   	push   %eax
  104dc7:	ff 74 24 20          	pushl  0x20(%esp)
  104dcb:	ff 74 24 20          	pushl  0x20(%esp)
  104dcf:	68 cc a5 10 00       	push   $0x10a5cc
  104dd4:	e8 f9 1a 00 00       	call   1068d2 <tfp_printf>
  104dd9:	83 c4 20             	add    $0x20,%esp

		printf( "liballoc: Total memory usage = %i KB\n",  (int)((l_allocated / (1024))) );
  104ddc:	8b 0d 30 53 11 00    	mov    0x115330,%ecx
  104de2:	8b 1d 34 53 11 00    	mov    0x115334,%ebx
  104de8:	89 c8                	mov    %ecx,%eax
  104dea:	89 da                	mov    %ebx,%edx
  104dec:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
  104df0:	c1 ea 0a             	shr    $0xa,%edx
  104df3:	83 ec 08             	sub    $0x8,%esp
  104df6:	50                   	push   %eax
  104df7:	68 14 a6 10 00       	push   $0x10a614
  104dfc:	e8 d1 1a 00 00       	call   1068d2 <tfp_printf>
  104e01:	83 c4 10             	add    $0x10,%esp
		FLUSH();
		#endif
	
		
      return maj;
  104e04:	8b 44 24 08          	mov    0x8(%esp),%eax
}
  104e08:	83 c4 18             	add    $0x18,%esp
  104e0b:	5b                   	pop    %ebx
  104e0c:	c3                   	ret    

00104e0d <kmalloc>:

	


void *PREFIX(malloc)(size_t req_size)
{
  104e0d:	53                   	push   %ebx
  104e0e:	83 ec 48             	sub    $0x48,%esp
	int startedBet = 0;
  104e11:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
  104e18:	00 
	unsigned long long bestSize = 0;
  104e19:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
  104e20:	00 
  104e21:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
  104e28:	00 
	void *p = NULL;
  104e29:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
  104e30:	00 
	uintptr_t diff;
	struct liballoc_major *maj;
	struct liballoc_minor *min;
	struct liballoc_minor *new_min;
	unsigned long size = req_size;
  104e31:	8b 44 24 50          	mov    0x50(%esp),%eax
  104e35:	89 44 24 10          	mov    %eax,0x10(%esp)

	// For alignment, we adjust size so there's enough space to align.
	if ( ALIGNMENT > 1 )
	{
		size += ALIGNMENT + ALIGN_INFO;
  104e39:	83 44 24 10 20       	addl   $0x20,0x10(%esp)
	}
				// So, ideally, we really want an alignment of 0 or 1 in order
				// to save space.
	
	liballoc_lock();
  104e3e:	e8 3d ef ff ff       	call   103d80 <liballoc_lock>

	if ( size == 0 )
  104e43:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
  104e48:	75 48                	jne    104e92 <kmalloc+0x85>
	{
		l_warningCount += 1;
  104e4a:	a1 40 53 11 00       	mov    0x115340,%eax
  104e4f:	8b 15 44 53 11 00    	mov    0x115344,%edx
  104e55:	83 c0 01             	add    $0x1,%eax
  104e58:	83 d2 00             	adc    $0x0,%edx
  104e5b:	a3 40 53 11 00       	mov    %eax,0x115340
  104e60:	89 15 44 53 11 00    	mov    %edx,0x115344
		#if defined DEBUG || defined INFO
		printf( "liballoc: WARNING: alloc( 0 ) called from %x\n",
  104e66:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  104e6a:	83 ec 08             	sub    $0x8,%esp
  104e6d:	50                   	push   %eax
  104e6e:	68 3c a6 10 00       	push   $0x10a63c
  104e73:	e8 5a 1a 00 00       	call   1068d2 <tfp_printf>
  104e78:	83 c4 10             	add    $0x10,%esp
							__builtin_return_address(0) );
		FLUSH();
		#endif
		liballoc_unlock();
  104e7b:	e8 29 ef ff ff       	call   103da9 <liballoc_unlock>
		return PREFIX(malloc)(1);
  104e80:	83 ec 0c             	sub    $0xc,%esp
  104e83:	6a 01                	push   $0x1
  104e85:	e8 83 ff ff ff       	call   104e0d <kmalloc>
  104e8a:	83 c4 10             	add    $0x10,%esp
  104e8d:	e9 fb 07 00 00       	jmp    10568d <kmalloc+0x880>
	}
	

	if ( l_memRoot == NULL )
  104e92:	a1 28 53 11 00       	mov    0x115328,%eax
  104e97:	85 c0                	test   %eax,%eax
  104e99:	75 66                	jne    104f01 <kmalloc+0xf4>
	{
		#if defined DEBUG || defined INFO
		#ifdef DEBUG
		printf( "liballoc: initialization of liballoc " VERSION "\n" );
  104e9b:	83 ec 0c             	sub    $0xc,%esp
  104e9e:	68 6c a6 10 00       	push   $0x10a66c
  104ea3:	e8 2a 1a 00 00       	call   1068d2 <tfp_printf>
  104ea8:	83 c4 10             	add    $0x10,%esp
		#endif
		FLUSH();
		#endif
			
		// This is the first time we are being used.
		l_memRoot = allocate_new_page( size );
  104eab:	83 ec 0c             	sub    $0xc,%esp
  104eae:	ff 74 24 1c          	pushl  0x1c(%esp)
  104eb2:	e8 ce fd ff ff       	call   104c85 <allocate_new_page>
  104eb7:	83 c4 10             	add    $0x10,%esp
  104eba:	a3 28 53 11 00       	mov    %eax,0x115328
		if ( l_memRoot == NULL )
  104ebf:	a1 28 53 11 00       	mov    0x115328,%eax
  104ec4:	85 c0                	test   %eax,%eax
  104ec6:	75 23                	jne    104eeb <kmalloc+0xde>
		{
		  liballoc_unlock();
  104ec8:	e8 dc ee ff ff       	call   103da9 <liballoc_unlock>
		  #ifdef DEBUG
		  printf( "liballoc: initial l_memRoot initialization failed\n", p); 
  104ecd:	83 ec 08             	sub    $0x8,%esp
  104ed0:	ff 74 24 34          	pushl  0x34(%esp)
  104ed4:	68 98 a6 10 00       	push   $0x10a698
  104ed9:	e8 f4 19 00 00       	call   1068d2 <tfp_printf>
  104ede:	83 c4 10             	add    $0x10,%esp
		  FLUSH();
		  #endif
		  return NULL;
  104ee1:	b8 00 00 00 00       	mov    $0x0,%eax
  104ee6:	e9 a2 07 00 00       	jmp    10568d <kmalloc+0x880>
		}

		#ifdef DEBUG
		printf( "liballoc: set up first memory major %x\n", l_memRoot );
  104eeb:	a1 28 53 11 00       	mov    0x115328,%eax
  104ef0:	83 ec 08             	sub    $0x8,%esp
  104ef3:	50                   	push   %eax
  104ef4:	68 cc a6 10 00       	push   $0x10a6cc
  104ef9:	e8 d4 19 00 00       	call   1068d2 <tfp_printf>
  104efe:	83 c4 10             	add    $0x10,%esp
		#endif
	}


	#ifdef DEBUG
	printf( "liballoc: %x PREFIX(malloc)( %i ): ", 
  104f01:	8b 44 24 4c          	mov    0x4c(%esp),%eax
  104f05:	83 ec 04             	sub    $0x4,%esp
  104f08:	ff 74 24 14          	pushl  0x14(%esp)
  104f0c:	50                   	push   %eax
  104f0d:	68 f4 a6 10 00       	push   $0x10a6f4
  104f12:	e8 bb 19 00 00       	call   1068d2 <tfp_printf>
  104f17:	83 c4 10             	add    $0x10,%esp
	FLUSH();
	#endif

	// Now we need to bounce through every major and find enough space....

	maj = l_memRoot;
  104f1a:	a1 28 53 11 00       	mov    0x115328,%eax
  104f1f:	89 44 24 28          	mov    %eax,0x28(%esp)
	startedBet = 0;
  104f23:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
  104f2a:	00 
	
	// Start at the best bet....
	if ( l_bestBet != NULL )
  104f2b:	a1 2c 53 11 00       	mov    0x11532c,%eax
  104f30:	85 c0                	test   %eax,%eax
  104f32:	0f 84 11 07 00 00    	je     105649 <kmalloc+0x83c>
	{
		bestSize = l_bestBet->size - l_bestBet->usage;
  104f38:	a1 2c 53 11 00       	mov    0x11532c,%eax
  104f3d:	8b 50 0c             	mov    0xc(%eax),%edx
  104f40:	a1 2c 53 11 00       	mov    0x11532c,%eax
  104f45:	8b 40 10             	mov    0x10(%eax),%eax
  104f48:	29 c2                	sub    %eax,%edx
  104f4a:	89 d0                	mov    %edx,%eax
  104f4c:	89 44 24 30          	mov    %eax,0x30(%esp)
  104f50:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
  104f57:	00 

		if ( bestSize > (size + sizeof(struct liballoc_minor)))
  104f58:	8b 44 24 10          	mov    0x10(%esp),%eax
  104f5c:	83 c0 18             	add    $0x18,%eax
  104f5f:	ba 00 00 00 00       	mov    $0x0,%edx
  104f64:	39 54 24 34          	cmp    %edx,0x34(%esp)
  104f68:	0f 82 db 06 00 00    	jb     105649 <kmalloc+0x83c>
  104f6e:	39 54 24 34          	cmp    %edx,0x34(%esp)
  104f72:	77 0a                	ja     104f7e <kmalloc+0x171>
  104f74:	39 44 24 30          	cmp    %eax,0x30(%esp)
  104f78:	0f 86 cb 06 00 00    	jbe    105649 <kmalloc+0x83c>
		{
			maj = l_bestBet;
  104f7e:	a1 2c 53 11 00       	mov    0x11532c,%eax
  104f83:	89 44 24 28          	mov    %eax,0x28(%esp)
			startedBet = 1;
  104f87:	c7 44 24 3c 01 00 00 	movl   $0x1,0x3c(%esp)
  104f8e:	00 
		}
	}
	
	while ( maj != NULL )
  104f8f:	e9 b5 06 00 00       	jmp    105649 <kmalloc+0x83c>
	{
		diff  = maj->size - maj->usage;	
  104f94:	8b 44 24 28          	mov    0x28(%esp),%eax
  104f98:	8b 50 0c             	mov    0xc(%eax),%edx
  104f9b:	8b 44 24 28          	mov    0x28(%esp),%eax
  104f9f:	8b 40 10             	mov    0x10(%eax),%eax
  104fa2:	29 c2                	sub    %eax,%edx
  104fa4:	89 d0                	mov    %edx,%eax
  104fa6:	89 44 24 0c          	mov    %eax,0xc(%esp)
										// free memory in the block

		if ( bestSize < diff )
  104faa:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104fae:	ba 00 00 00 00       	mov    $0x0,%edx
  104fb3:	39 54 24 34          	cmp    %edx,0x34(%esp)
  104fb7:	77 25                	ja     104fde <kmalloc+0x1d1>
  104fb9:	39 54 24 34          	cmp    %edx,0x34(%esp)
  104fbd:	72 06                	jb     104fc5 <kmalloc+0x1b8>
  104fbf:	39 44 24 30          	cmp    %eax,0x30(%esp)
  104fc3:	73 19                	jae    104fde <kmalloc+0x1d1>
		{
			// Hmm.. this one has more memory then our bestBet. Remember!
			l_bestBet = maj;
  104fc5:	8b 44 24 28          	mov    0x28(%esp),%eax
  104fc9:	a3 2c 53 11 00       	mov    %eax,0x11532c
			bestSize = diff;
  104fce:	8b 44 24 0c          	mov    0xc(%esp),%eax
  104fd2:	89 44 24 30          	mov    %eax,0x30(%esp)
  104fd6:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
  104fdd:	00 
		
		
#ifdef USE_CASE1
			
		// CASE 1:  There is not enough space in this major block.
		if ( diff < (size + sizeof( struct liballoc_minor )) )
  104fde:	8b 44 24 10          	mov    0x10(%esp),%eax
  104fe2:	83 c0 18             	add    $0x18,%eax
  104fe5:	39 44 24 0c          	cmp    %eax,0xc(%esp)
  104fe9:	0f 83 8b 00 00 00    	jae    10507a <kmalloc+0x26d>
		{
			#ifdef DEBUG
			printf( "CASE 1: Insufficient space in block %x\n", maj);
  104fef:	83 ec 08             	sub    $0x8,%esp
  104ff2:	ff 74 24 30          	pushl  0x30(%esp)
  104ff6:	68 18 a7 10 00       	push   $0x10a718
  104ffb:	e8 d2 18 00 00       	call   1068d2 <tfp_printf>
  105000:	83 c4 10             	add    $0x10,%esp
			FLUSH();
			#endif
				
				// Another major block next to this one?
			if ( maj->next != NULL ) 
  105003:	8b 44 24 28          	mov    0x28(%esp),%eax
  105007:	8b 40 04             	mov    0x4(%eax),%eax
  10500a:	85 c0                	test   %eax,%eax
  10500c:	74 10                	je     10501e <kmalloc+0x211>
			{
				maj = maj->next;		// Hop to that one.
  10500e:	8b 44 24 28          	mov    0x28(%esp),%eax
  105012:	8b 40 04             	mov    0x4(%eax),%eax
  105015:	89 44 24 28          	mov    %eax,0x28(%esp)
				continue;
  105019:	e9 2b 06 00 00       	jmp    105649 <kmalloc+0x83c>
			}

			if ( startedBet == 1 )		// If we started at the best bet,
  10501e:	83 7c 24 3c 01       	cmpl   $0x1,0x3c(%esp)
  105023:	75 16                	jne    10503b <kmalloc+0x22e>
			{							// let's start all over again.
				maj = l_memRoot;
  105025:	a1 28 53 11 00       	mov    0x115328,%eax
  10502a:	89 44 24 28          	mov    %eax,0x28(%esp)
				startedBet = 0;
  10502e:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
  105035:	00 
				continue;
  105036:	e9 0e 06 00 00       	jmp    105649 <kmalloc+0x83c>
			}

			// Create a new major block next to this one and...
			maj->next = allocate_new_page( size );	// next one will be okay.
  10503b:	83 ec 0c             	sub    $0xc,%esp
  10503e:	ff 74 24 1c          	pushl  0x1c(%esp)
  105042:	e8 3e fc ff ff       	call   104c85 <allocate_new_page>
  105047:	83 c4 10             	add    $0x10,%esp
  10504a:	89 c2                	mov    %eax,%edx
  10504c:	8b 44 24 28          	mov    0x28(%esp),%eax
  105050:	89 50 04             	mov    %edx,0x4(%eax)
			if ( maj->next == NULL ) break;			// no more memory.
  105053:	8b 44 24 28          	mov    0x28(%esp),%eax
  105057:	8b 40 04             	mov    0x4(%eax),%eax
  10505a:	85 c0                	test   %eax,%eax
  10505c:	0f 84 f4 05 00 00    	je     105656 <kmalloc+0x849>
			maj->next->prev = maj;
  105062:	8b 44 24 28          	mov    0x28(%esp),%eax
  105066:	8b 40 04             	mov    0x4(%eax),%eax
  105069:	8b 54 24 28          	mov    0x28(%esp),%edx
  10506d:	89 10                	mov    %edx,(%eax)
			maj = maj->next;
  10506f:	8b 44 24 28          	mov    0x28(%esp),%eax
  105073:	8b 40 04             	mov    0x4(%eax),%eax
  105076:	89 44 24 28          	mov    %eax,0x28(%esp)
#endif

#ifdef USE_CASE2
		
		// CASE 2: It's a brand new block.
		if ( maj->first == NULL )
  10507a:	8b 44 24 28          	mov    0x28(%esp),%eax
  10507e:	8b 40 14             	mov    0x14(%eax),%eax
  105081:	85 c0                	test   %eax,%eax
  105083:	0f 85 15 01 00 00    	jne    10519e <kmalloc+0x391>
		{
			maj->first = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
  105089:	8b 44 24 28          	mov    0x28(%esp),%eax
  10508d:	83 c0 18             	add    $0x18,%eax
  105090:	89 c2                	mov    %eax,%edx
  105092:	8b 44 24 28          	mov    0x28(%esp),%eax
  105096:	89 50 14             	mov    %edx,0x14(%eax)

			
			maj->first->magic 		= LIBALLOC_MAGIC;
  105099:	8b 44 24 28          	mov    0x28(%esp),%eax
  10509d:	8b 40 14             	mov    0x14(%eax),%eax
  1050a0:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
			maj->first->prev 		= NULL;
  1050a7:	8b 44 24 28          	mov    0x28(%esp),%eax
  1050ab:	8b 40 14             	mov    0x14(%eax),%eax
  1050ae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			maj->first->next 		= NULL;
  1050b4:	8b 44 24 28          	mov    0x28(%esp),%eax
  1050b8:	8b 40 14             	mov    0x14(%eax),%eax
  1050bb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			maj->first->block 		= maj;
  1050c2:	8b 44 24 28          	mov    0x28(%esp),%eax
  1050c6:	8b 40 14             	mov    0x14(%eax),%eax
  1050c9:	8b 54 24 28          	mov    0x28(%esp),%edx
  1050cd:	89 50 08             	mov    %edx,0x8(%eax)
			maj->first->size 		= size;
  1050d0:	8b 44 24 28          	mov    0x28(%esp),%eax
  1050d4:	8b 40 14             	mov    0x14(%eax),%eax
  1050d7:	8b 54 24 10          	mov    0x10(%esp),%edx
  1050db:	89 50 10             	mov    %edx,0x10(%eax)
			maj->first->req_size 	= req_size;
  1050de:	8b 44 24 28          	mov    0x28(%esp),%eax
  1050e2:	8b 40 14             	mov    0x14(%eax),%eax
  1050e5:	8b 54 24 50          	mov    0x50(%esp),%edx
  1050e9:	89 50 14             	mov    %edx,0x14(%eax)
			maj->usage 	+= size + sizeof( struct liballoc_minor );
  1050ec:	8b 44 24 28          	mov    0x28(%esp),%eax
  1050f0:	8b 50 10             	mov    0x10(%eax),%edx
  1050f3:	8b 44 24 10          	mov    0x10(%esp),%eax
  1050f7:	01 d0                	add    %edx,%eax
  1050f9:	8d 50 18             	lea    0x18(%eax),%edx
  1050fc:	8b 44 24 28          	mov    0x28(%esp),%eax
  105100:	89 50 10             	mov    %edx,0x10(%eax)


			l_inuse += size;
  105103:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  105107:	bb 00 00 00 00       	mov    $0x0,%ebx
  10510c:	a1 38 53 11 00       	mov    0x115338,%eax
  105111:	8b 15 3c 53 11 00    	mov    0x11533c,%edx
  105117:	01 c8                	add    %ecx,%eax
  105119:	11 da                	adc    %ebx,%edx
  10511b:	a3 38 53 11 00       	mov    %eax,0x115338
  105120:	89 15 3c 53 11 00    	mov    %edx,0x11533c
			
			
			p = (void*)((uintptr_t)(maj->first) + sizeof( struct liballoc_minor ));
  105126:	8b 44 24 28          	mov    0x28(%esp),%eax
  10512a:	8b 40 14             	mov    0x14(%eax),%eax
  10512d:	83 c0 18             	add    $0x18,%eax
  105130:	89 44 24 2c          	mov    %eax,0x2c(%esp)

			ALIGN( p );
  105134:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  105138:	83 c0 10             	add    $0x10,%eax
  10513b:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  10513f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  105143:	83 e0 0f             	and    $0xf,%eax
  105146:	89 44 24 20          	mov    %eax,0x20(%esp)
  10514a:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  10514f:	74 1b                	je     10516c <kmalloc+0x35f>
  105151:	b8 10 00 00 00       	mov    $0x10,%eax
  105156:	2b 44 24 20          	sub    0x20(%esp),%eax
  10515a:	89 44 24 20          	mov    %eax,0x20(%esp)
  10515e:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  105162:	8b 44 24 20          	mov    0x20(%esp),%eax
  105166:	01 d0                	add    %edx,%eax
  105168:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  10516c:	8b 44 24 20          	mov    0x20(%esp),%eax
  105170:	8d 50 10             	lea    0x10(%eax),%edx
  105173:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  105177:	83 e8 10             	sub    $0x10,%eax
  10517a:	88 10                	mov    %dl,(%eax)
			
			#ifdef DEBUG
			printf( "CASE 2: returning %x\n", p); 
  10517c:	83 ec 08             	sub    $0x8,%esp
  10517f:	ff 74 24 34          	pushl  0x34(%esp)
  105183:	68 40 a7 10 00       	push   $0x10a740
  105188:	e8 45 17 00 00       	call   1068d2 <tfp_printf>
  10518d:	83 c4 10             	add    $0x10,%esp
			FLUSH();
			#endif
			liballoc_unlock();		// release the lock
  105190:	e8 14 ec ff ff       	call   103da9 <liballoc_unlock>
			return p;
  105195:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  105199:	e9 ef 04 00 00       	jmp    10568d <kmalloc+0x880>
#endif
				
#ifdef USE_CASE3

		// CASE 3: Block in use and enough space at the start of the block.
		diff =  (uintptr_t)(maj->first);
  10519e:	8b 44 24 28          	mov    0x28(%esp),%eax
  1051a2:	8b 40 14             	mov    0x14(%eax),%eax
  1051a5:	89 44 24 0c          	mov    %eax,0xc(%esp)
		diff -= (uintptr_t)maj;
  1051a9:	8b 44 24 28          	mov    0x28(%esp),%eax
  1051ad:	29 44 24 0c          	sub    %eax,0xc(%esp)
		diff -= sizeof(struct liballoc_major);
  1051b1:	83 6c 24 0c 18       	subl   $0x18,0xc(%esp)

		if ( diff >= (size + sizeof(struct liballoc_minor)) )
  1051b6:	8b 44 24 10          	mov    0x10(%esp),%eax
  1051ba:	83 c0 18             	add    $0x18,%eax
  1051bd:	39 44 24 0c          	cmp    %eax,0xc(%esp)
  1051c1:	0f 82 2a 01 00 00    	jb     1052f1 <kmalloc+0x4e4>
		{
			// Yes, space in front. Squeeze in.
			maj->first->prev = (struct liballoc_minor*)((uintptr_t)maj + sizeof(struct liballoc_major) );
  1051c7:	8b 44 24 28          	mov    0x28(%esp),%eax
  1051cb:	8d 50 18             	lea    0x18(%eax),%edx
  1051ce:	8b 44 24 28          	mov    0x28(%esp),%eax
  1051d2:	8b 40 14             	mov    0x14(%eax),%eax
  1051d5:	89 10                	mov    %edx,(%eax)
			maj->first->prev->next = maj->first;
  1051d7:	8b 44 24 28          	mov    0x28(%esp),%eax
  1051db:	8b 40 14             	mov    0x14(%eax),%eax
  1051de:	8b 00                	mov    (%eax),%eax
  1051e0:	8b 54 24 28          	mov    0x28(%esp),%edx
  1051e4:	8b 52 14             	mov    0x14(%edx),%edx
  1051e7:	89 50 04             	mov    %edx,0x4(%eax)
			maj->first = maj->first->prev;
  1051ea:	8b 44 24 28          	mov    0x28(%esp),%eax
  1051ee:	8b 40 14             	mov    0x14(%eax),%eax
  1051f1:	8b 10                	mov    (%eax),%edx
  1051f3:	8b 44 24 28          	mov    0x28(%esp),%eax
  1051f7:	89 50 14             	mov    %edx,0x14(%eax)
				
			maj->first->magic 	= LIBALLOC_MAGIC;
  1051fa:	8b 44 24 28          	mov    0x28(%esp),%eax
  1051fe:	8b 40 14             	mov    0x14(%eax),%eax
  105201:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
			maj->first->prev 	= NULL;
  105208:	8b 44 24 28          	mov    0x28(%esp),%eax
  10520c:	8b 40 14             	mov    0x14(%eax),%eax
  10520f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			maj->first->block 	= maj;
  105215:	8b 44 24 28          	mov    0x28(%esp),%eax
  105219:	8b 40 14             	mov    0x14(%eax),%eax
  10521c:	8b 54 24 28          	mov    0x28(%esp),%edx
  105220:	89 50 08             	mov    %edx,0x8(%eax)
			maj->first->size 	= size;
  105223:	8b 44 24 28          	mov    0x28(%esp),%eax
  105227:	8b 40 14             	mov    0x14(%eax),%eax
  10522a:	8b 54 24 10          	mov    0x10(%esp),%edx
  10522e:	89 50 10             	mov    %edx,0x10(%eax)
			maj->first->req_size 	= req_size;
  105231:	8b 44 24 28          	mov    0x28(%esp),%eax
  105235:	8b 40 14             	mov    0x14(%eax),%eax
  105238:	8b 54 24 50          	mov    0x50(%esp),%edx
  10523c:	89 50 14             	mov    %edx,0x14(%eax)
			maj->usage 			+= size + sizeof( struct liballoc_minor );
  10523f:	8b 44 24 28          	mov    0x28(%esp),%eax
  105243:	8b 50 10             	mov    0x10(%eax),%edx
  105246:	8b 44 24 10          	mov    0x10(%esp),%eax
  10524a:	01 d0                	add    %edx,%eax
  10524c:	8d 50 18             	lea    0x18(%eax),%edx
  10524f:	8b 44 24 28          	mov    0x28(%esp),%eax
  105253:	89 50 10             	mov    %edx,0x10(%eax)

			l_inuse += size;
  105256:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  10525a:	bb 00 00 00 00       	mov    $0x0,%ebx
  10525f:	a1 38 53 11 00       	mov    0x115338,%eax
  105264:	8b 15 3c 53 11 00    	mov    0x11533c,%edx
  10526a:	01 c8                	add    %ecx,%eax
  10526c:	11 da                	adc    %ebx,%edx
  10526e:	a3 38 53 11 00       	mov    %eax,0x115338
  105273:	89 15 3c 53 11 00    	mov    %edx,0x11533c

			p = (void*)((uintptr_t)(maj->first) + sizeof( struct liballoc_minor ));
  105279:	8b 44 24 28          	mov    0x28(%esp),%eax
  10527d:	8b 40 14             	mov    0x14(%eax),%eax
  105280:	83 c0 18             	add    $0x18,%eax
  105283:	89 44 24 2c          	mov    %eax,0x2c(%esp)
			ALIGN( p );
  105287:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  10528b:	83 c0 10             	add    $0x10,%eax
  10528e:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  105292:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  105296:	83 e0 0f             	and    $0xf,%eax
  105299:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  10529d:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
  1052a2:	74 1b                	je     1052bf <kmalloc+0x4b2>
  1052a4:	b8 10 00 00 00       	mov    $0x10,%eax
  1052a9:	2b 44 24 1c          	sub    0x1c(%esp),%eax
  1052ad:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  1052b1:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  1052b5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1052b9:	01 d0                	add    %edx,%eax
  1052bb:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  1052bf:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1052c3:	8d 50 10             	lea    0x10(%eax),%edx
  1052c6:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  1052ca:	83 e8 10             	sub    $0x10,%eax
  1052cd:	88 10                	mov    %dl,(%eax)

			#ifdef DEBUG
			printf( "CASE 3: returning %x\n", p); 
  1052cf:	83 ec 08             	sub    $0x8,%esp
  1052d2:	ff 74 24 34          	pushl  0x34(%esp)
  1052d6:	68 56 a7 10 00       	push   $0x10a756
  1052db:	e8 f2 15 00 00       	call   1068d2 <tfp_printf>
  1052e0:	83 c4 10             	add    $0x10,%esp
			FLUSH();
			#endif
			liballoc_unlock();		// release the lock
  1052e3:	e8 c1 ea ff ff       	call   103da9 <liballoc_unlock>
			return p;
  1052e8:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  1052ec:	e9 9c 03 00 00       	jmp    10568d <kmalloc+0x880>


#ifdef USE_CASE4

		// CASE 4: There is enough space in this block. But is it contiguous?
		min = maj->first;
  1052f1:	8b 44 24 28          	mov    0x28(%esp),%eax
  1052f5:	8b 40 14             	mov    0x14(%eax),%eax
  1052f8:	89 44 24 24          	mov    %eax,0x24(%esp)
		
			// Looping within the block now...
		while ( min != NULL )
  1052fc:	e9 cd 02 00 00       	jmp    1055ce <kmalloc+0x7c1>
		{
				// CASE 4.1: End of minors in a block. Space from last and end?
				if ( min->next == NULL )
  105301:	8b 44 24 24          	mov    0x24(%esp),%eax
  105305:	8b 40 04             	mov    0x4(%eax),%eax
  105308:	85 c0                	test   %eax,%eax
  10530a:	0f 85 51 01 00 00    	jne    105461 <kmalloc+0x654>
				{
					// the rest of this block is free...  is it big enough?
					diff = (uintptr_t)(maj) + maj->size;
  105310:	8b 44 24 28          	mov    0x28(%esp),%eax
  105314:	8b 50 0c             	mov    0xc(%eax),%edx
  105317:	8b 44 24 28          	mov    0x28(%esp),%eax
  10531b:	01 d0                	add    %edx,%eax
  10531d:	89 44 24 0c          	mov    %eax,0xc(%esp)
					diff -= (uintptr_t)min;
  105321:	8b 44 24 24          	mov    0x24(%esp),%eax
  105325:	29 44 24 0c          	sub    %eax,0xc(%esp)
					diff -= sizeof( struct liballoc_minor );
  105329:	83 6c 24 0c 18       	subl   $0x18,0xc(%esp)
					diff -= min->size; 
  10532e:	8b 44 24 24          	mov    0x24(%esp),%eax
  105332:	8b 40 10             	mov    0x10(%eax),%eax
  105335:	29 44 24 0c          	sub    %eax,0xc(%esp)
						// minus already existing usage..

					if ( diff >= (size + sizeof( struct liballoc_minor )) )
  105339:	8b 44 24 10          	mov    0x10(%esp),%eax
  10533d:	83 c0 18             	add    $0x18,%eax
  105340:	39 44 24 0c          	cmp    %eax,0xc(%esp)
  105344:	0f 82 17 01 00 00    	jb     105461 <kmalloc+0x654>
					{
						// yay....
						min->next = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
  10534a:	8b 44 24 24          	mov    0x24(%esp),%eax
  10534e:	8b 50 10             	mov    0x10(%eax),%edx
  105351:	8b 44 24 24          	mov    0x24(%esp),%eax
  105355:	01 d0                	add    %edx,%eax
  105357:	83 c0 18             	add    $0x18,%eax
  10535a:	89 c2                	mov    %eax,%edx
  10535c:	8b 44 24 24          	mov    0x24(%esp),%eax
  105360:	89 50 04             	mov    %edx,0x4(%eax)
						min->next->prev = min;
  105363:	8b 44 24 24          	mov    0x24(%esp),%eax
  105367:	8b 40 04             	mov    0x4(%eax),%eax
  10536a:	8b 54 24 24          	mov    0x24(%esp),%edx
  10536e:	89 10                	mov    %edx,(%eax)
						min = min->next;
  105370:	8b 44 24 24          	mov    0x24(%esp),%eax
  105374:	8b 40 04             	mov    0x4(%eax),%eax
  105377:	89 44 24 24          	mov    %eax,0x24(%esp)
						min->next = NULL;
  10537b:	8b 44 24 24          	mov    0x24(%esp),%eax
  10537f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
						min->magic = LIBALLOC_MAGIC;
  105386:	8b 44 24 24          	mov    0x24(%esp),%eax
  10538a:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
						min->block = maj;
  105391:	8b 44 24 24          	mov    0x24(%esp),%eax
  105395:	8b 54 24 28          	mov    0x28(%esp),%edx
  105399:	89 50 08             	mov    %edx,0x8(%eax)
						min->size = size;
  10539c:	8b 44 24 24          	mov    0x24(%esp),%eax
  1053a0:	8b 54 24 10          	mov    0x10(%esp),%edx
  1053a4:	89 50 10             	mov    %edx,0x10(%eax)
						min->req_size = req_size;
  1053a7:	8b 44 24 24          	mov    0x24(%esp),%eax
  1053ab:	8b 54 24 50          	mov    0x50(%esp),%edx
  1053af:	89 50 14             	mov    %edx,0x14(%eax)
						maj->usage += size + sizeof( struct liballoc_minor );
  1053b2:	8b 44 24 28          	mov    0x28(%esp),%eax
  1053b6:	8b 50 10             	mov    0x10(%eax),%edx
  1053b9:	8b 44 24 10          	mov    0x10(%esp),%eax
  1053bd:	01 d0                	add    %edx,%eax
  1053bf:	8d 50 18             	lea    0x18(%eax),%edx
  1053c2:	8b 44 24 28          	mov    0x28(%esp),%eax
  1053c6:	89 50 10             	mov    %edx,0x10(%eax)

						l_inuse += size;
  1053c9:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  1053cd:	bb 00 00 00 00       	mov    $0x0,%ebx
  1053d2:	a1 38 53 11 00       	mov    0x115338,%eax
  1053d7:	8b 15 3c 53 11 00    	mov    0x11533c,%edx
  1053dd:	01 c8                	add    %ecx,%eax
  1053df:	11 da                	adc    %ebx,%edx
  1053e1:	a3 38 53 11 00       	mov    %eax,0x115338
  1053e6:	89 15 3c 53 11 00    	mov    %edx,0x11533c
						
						p = (void*)((uintptr_t)min + sizeof( struct liballoc_minor ));
  1053ec:	8b 44 24 24          	mov    0x24(%esp),%eax
  1053f0:	83 c0 18             	add    $0x18,%eax
  1053f3:	89 44 24 2c          	mov    %eax,0x2c(%esp)
						ALIGN( p );
  1053f7:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  1053fb:	83 c0 10             	add    $0x10,%eax
  1053fe:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  105402:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  105406:	83 e0 0f             	and    $0xf,%eax
  105409:	89 44 24 18          	mov    %eax,0x18(%esp)
  10540d:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
  105412:	74 1b                	je     10542f <kmalloc+0x622>
  105414:	b8 10 00 00 00       	mov    $0x10,%eax
  105419:	2b 44 24 18          	sub    0x18(%esp),%eax
  10541d:	89 44 24 18          	mov    %eax,0x18(%esp)
  105421:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  105425:	8b 44 24 18          	mov    0x18(%esp),%eax
  105429:	01 d0                	add    %edx,%eax
  10542b:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  10542f:	8b 44 24 18          	mov    0x18(%esp),%eax
  105433:	8d 50 10             	lea    0x10(%eax),%edx
  105436:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  10543a:	83 e8 10             	sub    $0x10,%eax
  10543d:	88 10                	mov    %dl,(%eax)

						#ifdef DEBUG
						printf( "CASE 4.1: returning %x\n", p); 
  10543f:	83 ec 08             	sub    $0x8,%esp
  105442:	ff 74 24 34          	pushl  0x34(%esp)
  105446:	68 6c a7 10 00       	push   $0x10a76c
  10544b:	e8 82 14 00 00       	call   1068d2 <tfp_printf>
  105450:	83 c4 10             	add    $0x10,%esp
						FLUSH();
						#endif
						liballoc_unlock();		// release the lock
  105453:	e8 51 e9 ff ff       	call   103da9 <liballoc_unlock>
						return p;
  105458:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  10545c:	e9 2c 02 00 00       	jmp    10568d <kmalloc+0x880>
				}



				// CASE 4.2: Is there space between two minors?
				if ( min->next != NULL )
  105461:	8b 44 24 24          	mov    0x24(%esp),%eax
  105465:	8b 40 04             	mov    0x4(%eax),%eax
  105468:	85 c0                	test   %eax,%eax
  10546a:	0f 84 53 01 00 00    	je     1055c3 <kmalloc+0x7b6>
				{
					// is the difference between here and next big enough?
					diff  = (uintptr_t)(min->next);
  105470:	8b 44 24 24          	mov    0x24(%esp),%eax
  105474:	8b 40 04             	mov    0x4(%eax),%eax
  105477:	89 44 24 0c          	mov    %eax,0xc(%esp)
					diff -= (uintptr_t)min;
  10547b:	8b 44 24 24          	mov    0x24(%esp),%eax
  10547f:	29 44 24 0c          	sub    %eax,0xc(%esp)
					diff -= sizeof( struct liballoc_minor );
  105483:	83 6c 24 0c 18       	subl   $0x18,0xc(%esp)
					diff -= min->size;
  105488:	8b 44 24 24          	mov    0x24(%esp),%eax
  10548c:	8b 40 10             	mov    0x10(%eax),%eax
  10548f:	29 44 24 0c          	sub    %eax,0xc(%esp)
										// minus our existing usage.

					if ( diff >= (size + sizeof( struct liballoc_minor )) )
  105493:	8b 44 24 10          	mov    0x10(%esp),%eax
  105497:	83 c0 18             	add    $0x18,%eax
  10549a:	39 44 24 0c          	cmp    %eax,0xc(%esp)
  10549e:	0f 82 1f 01 00 00    	jb     1055c3 <kmalloc+0x7b6>
					{
						// yay......
						new_min = (struct liballoc_minor*)((uintptr_t)min + sizeof( struct liballoc_minor ) + min->size);
  1054a4:	8b 44 24 24          	mov    0x24(%esp),%eax
  1054a8:	8b 50 10             	mov    0x10(%eax),%edx
  1054ab:	8b 44 24 24          	mov    0x24(%esp),%eax
  1054af:	01 d0                	add    %edx,%eax
  1054b1:	83 c0 18             	add    $0x18,%eax
  1054b4:	89 44 24 08          	mov    %eax,0x8(%esp)

						new_min->magic = LIBALLOC_MAGIC;
  1054b8:	8b 44 24 08          	mov    0x8(%esp),%eax
  1054bc:	c7 40 0c de c0 01 c0 	movl   $0xc001c0de,0xc(%eax)
						new_min->next = min->next;
  1054c3:	8b 44 24 24          	mov    0x24(%esp),%eax
  1054c7:	8b 50 04             	mov    0x4(%eax),%edx
  1054ca:	8b 44 24 08          	mov    0x8(%esp),%eax
  1054ce:	89 50 04             	mov    %edx,0x4(%eax)
						new_min->prev = min;
  1054d1:	8b 44 24 08          	mov    0x8(%esp),%eax
  1054d5:	8b 54 24 24          	mov    0x24(%esp),%edx
  1054d9:	89 10                	mov    %edx,(%eax)
						new_min->size = size;
  1054db:	8b 44 24 08          	mov    0x8(%esp),%eax
  1054df:	8b 54 24 10          	mov    0x10(%esp),%edx
  1054e3:	89 50 10             	mov    %edx,0x10(%eax)
						new_min->req_size = req_size;
  1054e6:	8b 44 24 08          	mov    0x8(%esp),%eax
  1054ea:	8b 54 24 50          	mov    0x50(%esp),%edx
  1054ee:	89 50 14             	mov    %edx,0x14(%eax)
						new_min->block = maj;
  1054f1:	8b 44 24 08          	mov    0x8(%esp),%eax
  1054f5:	8b 54 24 28          	mov    0x28(%esp),%edx
  1054f9:	89 50 08             	mov    %edx,0x8(%eax)
						min->next->prev = new_min;
  1054fc:	8b 44 24 24          	mov    0x24(%esp),%eax
  105500:	8b 40 04             	mov    0x4(%eax),%eax
  105503:	8b 54 24 08          	mov    0x8(%esp),%edx
  105507:	89 10                	mov    %edx,(%eax)
						min->next = new_min;
  105509:	8b 44 24 24          	mov    0x24(%esp),%eax
  10550d:	8b 54 24 08          	mov    0x8(%esp),%edx
  105511:	89 50 04             	mov    %edx,0x4(%eax)
						maj->usage += size + sizeof( struct liballoc_minor );
  105514:	8b 44 24 28          	mov    0x28(%esp),%eax
  105518:	8b 50 10             	mov    0x10(%eax),%edx
  10551b:	8b 44 24 10          	mov    0x10(%esp),%eax
  10551f:	01 d0                	add    %edx,%eax
  105521:	8d 50 18             	lea    0x18(%eax),%edx
  105524:	8b 44 24 28          	mov    0x28(%esp),%eax
  105528:	89 50 10             	mov    %edx,0x10(%eax)
						
						l_inuse += size;
  10552b:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  10552f:	bb 00 00 00 00       	mov    $0x0,%ebx
  105534:	a1 38 53 11 00       	mov    0x115338,%eax
  105539:	8b 15 3c 53 11 00    	mov    0x11533c,%edx
  10553f:	01 c8                	add    %ecx,%eax
  105541:	11 da                	adc    %ebx,%edx
  105543:	a3 38 53 11 00       	mov    %eax,0x115338
  105548:	89 15 3c 53 11 00    	mov    %edx,0x11533c
						
						p = (void*)((uintptr_t)new_min + sizeof( struct liballoc_minor ));
  10554e:	8b 44 24 08          	mov    0x8(%esp),%eax
  105552:	83 c0 18             	add    $0x18,%eax
  105555:	89 44 24 2c          	mov    %eax,0x2c(%esp)
						ALIGN( p );
  105559:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  10555d:	83 c0 10             	add    $0x10,%eax
  105560:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  105564:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  105568:	83 e0 0f             	and    $0xf,%eax
  10556b:	89 44 24 14          	mov    %eax,0x14(%esp)
  10556f:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
  105574:	74 1b                	je     105591 <kmalloc+0x784>
  105576:	b8 10 00 00 00       	mov    $0x10,%eax
  10557b:	2b 44 24 14          	sub    0x14(%esp),%eax
  10557f:	89 44 24 14          	mov    %eax,0x14(%esp)
  105583:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  105587:	8b 44 24 14          	mov    0x14(%esp),%eax
  10558b:	01 d0                	add    %edx,%eax
  10558d:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  105591:	8b 44 24 14          	mov    0x14(%esp),%eax
  105595:	8d 50 10             	lea    0x10(%eax),%edx
  105598:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  10559c:	83 e8 10             	sub    $0x10,%eax
  10559f:	88 10                	mov    %dl,(%eax)


						#ifdef DEBUG
						printf( "CASE 4.2: returning %x\n", p); 
  1055a1:	83 ec 08             	sub    $0x8,%esp
  1055a4:	ff 74 24 34          	pushl  0x34(%esp)
  1055a8:	68 84 a7 10 00       	push   $0x10a784
  1055ad:	e8 20 13 00 00       	call   1068d2 <tfp_printf>
  1055b2:	83 c4 10             	add    $0x10,%esp
						FLUSH();
						#endif
						
						liballoc_unlock();		// release the lock
  1055b5:	e8 ef e7 ff ff       	call   103da9 <liballoc_unlock>
						return p;
  1055ba:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  1055be:	e9 ca 00 00 00       	jmp    10568d <kmalloc+0x880>
					}
				}	// min->next != NULL

				min = min->next;
  1055c3:	8b 44 24 24          	mov    0x24(%esp),%eax
  1055c7:	8b 40 04             	mov    0x4(%eax),%eax
  1055ca:	89 44 24 24          	mov    %eax,0x24(%esp)
		while ( min != NULL )
  1055ce:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  1055d3:	0f 85 28 fd ff ff    	jne    105301 <kmalloc+0x4f4>
#endif

#ifdef USE_CASE5

		// CASE 5: Block full! Ensure next block and loop.
		if ( maj->next == NULL ) 
  1055d9:	8b 44 24 28          	mov    0x28(%esp),%eax
  1055dd:	8b 40 04             	mov    0x4(%eax),%eax
  1055e0:	85 c0                	test   %eax,%eax
  1055e2:	75 5a                	jne    10563e <kmalloc+0x831>
		{
			#ifdef DEBUG
			printf( "CASE 5: block full\n");
  1055e4:	83 ec 0c             	sub    $0xc,%esp
  1055e7:	68 9c a7 10 00       	push   $0x10a79c
  1055ec:	e8 e1 12 00 00       	call   1068d2 <tfp_printf>
  1055f1:	83 c4 10             	add    $0x10,%esp
			FLUSH();
			#endif

			if ( startedBet == 1 )
  1055f4:	83 7c 24 3c 01       	cmpl   $0x1,0x3c(%esp)
  1055f9:	75 13                	jne    10560e <kmalloc+0x801>
			{
				maj = l_memRoot;
  1055fb:	a1 28 53 11 00       	mov    0x115328,%eax
  105600:	89 44 24 28          	mov    %eax,0x28(%esp)
				startedBet = 0;
  105604:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
  10560b:	00 
				continue;
  10560c:	eb 3b                	jmp    105649 <kmalloc+0x83c>
			}
				
			// we've run out. we need more...
			maj->next = allocate_new_page( size );		// next one guaranteed to be okay
  10560e:	83 ec 0c             	sub    $0xc,%esp
  105611:	ff 74 24 1c          	pushl  0x1c(%esp)
  105615:	e8 6b f6 ff ff       	call   104c85 <allocate_new_page>
  10561a:	83 c4 10             	add    $0x10,%esp
  10561d:	89 c2                	mov    %eax,%edx
  10561f:	8b 44 24 28          	mov    0x28(%esp),%eax
  105623:	89 50 04             	mov    %edx,0x4(%eax)
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
  105626:	8b 44 24 28          	mov    0x28(%esp),%eax
  10562a:	8b 40 04             	mov    0x4(%eax),%eax
  10562d:	85 c0                	test   %eax,%eax
  10562f:	74 28                	je     105659 <kmalloc+0x84c>
			maj->next->prev = maj;
  105631:	8b 44 24 28          	mov    0x28(%esp),%eax
  105635:	8b 40 04             	mov    0x4(%eax),%eax
  105638:	8b 54 24 28          	mov    0x28(%esp),%edx
  10563c:	89 10                	mov    %edx,(%eax)

		}

#endif

		maj = maj->next;
  10563e:	8b 44 24 28          	mov    0x28(%esp),%eax
  105642:	8b 40 04             	mov    0x4(%eax),%eax
  105645:	89 44 24 28          	mov    %eax,0x28(%esp)
	while ( maj != NULL )
  105649:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
  10564e:	0f 85 40 f9 ff ff    	jne    104f94 <kmalloc+0x187>
  105654:	eb 04                	jmp    10565a <kmalloc+0x84d>
			if ( maj->next == NULL ) break;			// no more memory.
  105656:	90                   	nop
  105657:	eb 01                	jmp    10565a <kmalloc+0x84d>
			if ( maj->next == NULL ) break;			//  uh oh,  no more memory.....
  105659:	90                   	nop
	} // while (maj != NULL)


	
	liballoc_unlock();		// release the lock
  10565a:	e8 4a e7 ff ff       	call   103da9 <liballoc_unlock>

	#ifdef DEBUG
	printf( "All cases exhausted. No memory available.\n");
  10565f:	83 ec 0c             	sub    $0xc,%esp
  105662:	68 b0 a7 10 00       	push   $0x10a7b0
  105667:	e8 66 12 00 00       	call   1068d2 <tfp_printf>
  10566c:	83 c4 10             	add    $0x10,%esp
	FLUSH();
	#endif
	#if defined DEBUG || defined INFO
	printf( "liballoc: WARNING: PREFIX(malloc)( %i ) returning NULL.\n", size);
  10566f:	83 ec 08             	sub    $0x8,%esp
  105672:	ff 74 24 18          	pushl  0x18(%esp)
  105676:	68 dc a7 10 00       	push   $0x10a7dc
  10567b:	e8 52 12 00 00       	call   1068d2 <tfp_printf>
  105680:	83 c4 10             	add    $0x10,%esp
	liballoc_dump();
  105683:	e8 d3 f4 ff ff       	call   104b5b <liballoc_dump>
	FLUSH();
	#endif
	return NULL;
  105688:	b8 00 00 00 00       	mov    $0x0,%eax
}
  10568d:	83 c4 48             	add    $0x48,%esp
  105690:	5b                   	pop    %ebx
  105691:	c3                   	ret    

00105692 <kfree>:




void PREFIX(free)(void *ptr)
{
  105692:	53                   	push   %ebx
  105693:	83 ec 28             	sub    $0x28,%esp
	struct liballoc_minor *min;
	struct liballoc_major *maj;

	if ( ptr == NULL ) 
  105696:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
  10569b:	75 36                	jne    1056d3 <kfree+0x41>
	{
		l_warningCount += 1;
  10569d:	a1 40 53 11 00       	mov    0x115340,%eax
  1056a2:	8b 15 44 53 11 00    	mov    0x115344,%edx
  1056a8:	83 c0 01             	add    $0x1,%eax
  1056ab:	83 d2 00             	adc    $0x0,%edx
  1056ae:	a3 40 53 11 00       	mov    %eax,0x115340
  1056b3:	89 15 44 53 11 00    	mov    %edx,0x115344
		#if defined DEBUG || defined INFO
		printf( "liballoc: WARNING: PREFIX(free)( NULL ) called from %x\n",
  1056b9:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  1056bd:	83 ec 08             	sub    $0x8,%esp
  1056c0:	50                   	push   %eax
  1056c1:	68 18 a8 10 00       	push   $0x10a818
  1056c6:	e8 07 12 00 00       	call   1068d2 <tfp_printf>
  1056cb:	83 c4 10             	add    $0x10,%esp
							__builtin_return_address(0) );
		FLUSH();
		#endif
		return;
  1056ce:	e9 e6 02 00 00       	jmp    1059b9 <kfree+0x327>
	}

	UNALIGN( ptr );
  1056d3:	8b 44 24 30          	mov    0x30(%esp),%eax
  1056d7:	83 e8 10             	sub    $0x10,%eax
  1056da:	0f b6 00             	movzbl (%eax),%eax
  1056dd:	0f be c0             	movsbl %al,%eax
  1056e0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  1056e4:	83 7c 24 1c 1f       	cmpl   $0x1f,0x1c(%esp)
  1056e9:	77 0c                	ja     1056f7 <kfree+0x65>
  1056eb:	8b 44 24 30          	mov    0x30(%esp),%eax
  1056ef:	2b 44 24 1c          	sub    0x1c(%esp),%eax
  1056f3:	89 44 24 30          	mov    %eax,0x30(%esp)

	liballoc_lock();		// lockit
  1056f7:	e8 84 e6 ff ff       	call   103d80 <liballoc_lock>


	min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
  1056fc:	8b 44 24 30          	mov    0x30(%esp),%eax
  105700:	83 e8 18             	sub    $0x18,%eax
  105703:	89 44 24 18          	mov    %eax,0x18(%esp)

	
	if ( min->magic != LIBALLOC_MAGIC ) 
  105707:	8b 44 24 18          	mov    0x18(%esp),%eax
  10570b:	8b 40 0c             	mov    0xc(%eax),%eax
  10570e:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
  105713:	0f 84 d6 00 00 00    	je     1057ef <kfree+0x15d>
	{
		l_errorCount += 1;
  105719:	a1 48 53 11 00       	mov    0x115348,%eax
  10571e:	8b 15 4c 53 11 00    	mov    0x11534c,%edx
  105724:	83 c0 01             	add    $0x1,%eax
  105727:	83 d2 00             	adc    $0x0,%edx
  10572a:	a3 48 53 11 00       	mov    %eax,0x115348
  10572f:	89 15 4c 53 11 00    	mov    %edx,0x11534c

		// Check for overrun errors. For all bytes of LIBALLOC_MAGIC 
		if ( 
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
  105735:	8b 44 24 18          	mov    0x18(%esp),%eax
  105739:	8b 40 0c             	mov    0xc(%eax),%eax
  10573c:	25 ff ff ff 00       	and    $0xffffff,%eax
		if ( 
  105741:	3d de c0 01 00       	cmp    $0x1c0de,%eax
  105746:	74 22                	je     10576a <kfree+0xd8>
			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
  105748:	8b 44 24 18          	mov    0x18(%esp),%eax
  10574c:	8b 40 0c             	mov    0xc(%eax),%eax
  10574f:	0f b7 c0             	movzwl %ax,%eax
			((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
  105752:	3d de c0 00 00       	cmp    $0xc0de,%eax
  105757:	74 11                	je     10576a <kfree+0xd8>
			((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF)) 
  105759:	8b 44 24 18          	mov    0x18(%esp),%eax
  10575d:	8b 40 0c             	mov    0xc(%eax),%eax
  105760:	0f b6 c0             	movzbl %al,%eax
			((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
  105763:	3d de 00 00 00       	cmp    $0xde,%eax
  105768:	75 39                	jne    1057a3 <kfree+0x111>
		   )
		{
			l_possibleOverruns += 1;
  10576a:	a1 50 53 11 00       	mov    0x115350,%eax
  10576f:	8b 15 54 53 11 00    	mov    0x115354,%edx
  105775:	83 c0 01             	add    $0x1,%eax
  105778:	83 d2 00             	adc    $0x0,%edx
  10577b:	a3 50 53 11 00       	mov    %eax,0x115350
  105780:	89 15 54 53 11 00    	mov    %edx,0x115354
			#if defined DEBUG || defined INFO
			printf( "liballoc: ERROR: Possible 1-3 byte overrun for magic %x != %x\n",
  105786:	8b 44 24 18          	mov    0x18(%esp),%eax
  10578a:	8b 40 0c             	mov    0xc(%eax),%eax
  10578d:	83 ec 04             	sub    $0x4,%esp
  105790:	68 de c0 01 c0       	push   $0xc001c0de
  105795:	50                   	push   %eax
  105796:	68 50 a8 10 00       	push   $0x10a850
  10579b:	e8 32 11 00 00       	call   1068d2 <tfp_printf>
  1057a0:	83 c4 10             	add    $0x10,%esp
			FLUSH();
			#endif
		}
						
						
		if ( min->magic == LIBALLOC_DEAD )
  1057a3:	8b 44 24 18          	mov    0x18(%esp),%eax
  1057a7:	8b 40 0c             	mov    0xc(%eax),%eax
  1057aa:	3d ad de ad de       	cmp    $0xdeaddead,%eax
  1057af:	75 1b                	jne    1057cc <kfree+0x13a>
		{
			#if defined DEBUG || defined INFO
			printf( "liballoc: ERROR: multiple PREFIX(free)() attempt on %x from %x.\n", 
  1057b1:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  1057b5:	83 ec 04             	sub    $0x4,%esp
  1057b8:	50                   	push   %eax
  1057b9:	ff 74 24 38          	pushl  0x38(%esp)
  1057bd:	68 90 a8 10 00       	push   $0x10a890
  1057c2:	e8 0b 11 00 00       	call   1068d2 <tfp_printf>
  1057c7:	83 c4 10             	add    $0x10,%esp
  1057ca:	eb 19                	jmp    1057e5 <kfree+0x153>
			#endif
		}
		else
		{
			#if defined DEBUG || defined INFO
			printf( "liballoc: ERROR: Bad PREFIX(free)( %x ) called from %x\n",
  1057cc:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  1057d0:	83 ec 04             	sub    $0x4,%esp
  1057d3:	50                   	push   %eax
  1057d4:	ff 74 24 38          	pushl  0x38(%esp)
  1057d8:	68 d4 a8 10 00       	push   $0x10a8d4
  1057dd:	e8 f0 10 00 00       	call   1068d2 <tfp_printf>
  1057e2:	83 c4 10             	add    $0x10,%esp
			FLUSH();
			#endif
		}
			
		// being lied to...
		liballoc_unlock();		// release the lock
  1057e5:	e8 bf e5 ff ff       	call   103da9 <liballoc_unlock>
		return;
  1057ea:	e9 ca 01 00 00       	jmp    1059b9 <kfree+0x327>
	}

	#ifdef DEBUG
	printf( "liballoc: %x PREFIX(free)( %x ): ", 
  1057ef:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  1057f3:	83 ec 04             	sub    $0x4,%esp
  1057f6:	ff 74 24 34          	pushl  0x34(%esp)
  1057fa:	50                   	push   %eax
  1057fb:	68 0c a9 10 00       	push   $0x10a90c
  105800:	e8 cd 10 00 00       	call   1068d2 <tfp_printf>
  105805:	83 c4 10             	add    $0x10,%esp
				ptr );
	FLUSH();
	#endif
	

		maj = min->block;
  105808:	8b 44 24 18          	mov    0x18(%esp),%eax
  10580c:	8b 40 08             	mov    0x8(%eax),%eax
  10580f:	89 44 24 14          	mov    %eax,0x14(%esp)

		l_inuse -= min->size;
  105813:	a1 38 53 11 00       	mov    0x115338,%eax
  105818:	8b 15 3c 53 11 00    	mov    0x11533c,%edx
  10581e:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  105822:	8b 49 10             	mov    0x10(%ecx),%ecx
  105825:	bb 00 00 00 00       	mov    $0x0,%ebx
  10582a:	29 c8                	sub    %ecx,%eax
  10582c:	19 da                	sbb    %ebx,%edx
  10582e:	a3 38 53 11 00       	mov    %eax,0x115338
  105833:	89 15 3c 53 11 00    	mov    %edx,0x11533c

		maj->usage -= (min->size + sizeof( struct liballoc_minor ));
  105839:	8b 44 24 14          	mov    0x14(%esp),%eax
  10583d:	8b 50 10             	mov    0x10(%eax),%edx
  105840:	8b 44 24 18          	mov    0x18(%esp),%eax
  105844:	8b 40 10             	mov    0x10(%eax),%eax
  105847:	29 c2                	sub    %eax,%edx
  105849:	89 d0                	mov    %edx,%eax
  10584b:	8d 50 e8             	lea    -0x18(%eax),%edx
  10584e:	8b 44 24 14          	mov    0x14(%esp),%eax
  105852:	89 50 10             	mov    %edx,0x10(%eax)
		min->magic  = LIBALLOC_DEAD;		// No mojo.
  105855:	8b 44 24 18          	mov    0x18(%esp),%eax
  105859:	c7 40 0c ad de ad de 	movl   $0xdeaddead,0xc(%eax)

		if ( min->next != NULL ) min->next->prev = min->prev;
  105860:	8b 44 24 18          	mov    0x18(%esp),%eax
  105864:	8b 40 04             	mov    0x4(%eax),%eax
  105867:	85 c0                	test   %eax,%eax
  105869:	74 0f                	je     10587a <kfree+0x1e8>
  10586b:	8b 44 24 18          	mov    0x18(%esp),%eax
  10586f:	8b 40 04             	mov    0x4(%eax),%eax
  105872:	8b 54 24 18          	mov    0x18(%esp),%edx
  105876:	8b 12                	mov    (%edx),%edx
  105878:	89 10                	mov    %edx,(%eax)
		if ( min->prev != NULL ) min->prev->next = min->next;
  10587a:	8b 44 24 18          	mov    0x18(%esp),%eax
  10587e:	8b 00                	mov    (%eax),%eax
  105880:	85 c0                	test   %eax,%eax
  105882:	74 10                	je     105894 <kfree+0x202>
  105884:	8b 44 24 18          	mov    0x18(%esp),%eax
  105888:	8b 00                	mov    (%eax),%eax
  10588a:	8b 54 24 18          	mov    0x18(%esp),%edx
  10588e:	8b 52 04             	mov    0x4(%edx),%edx
  105891:	89 50 04             	mov    %edx,0x4(%eax)

		if ( min->prev == NULL ) maj->first = min->next;	
  105894:	8b 44 24 18          	mov    0x18(%esp),%eax
  105898:	8b 00                	mov    (%eax),%eax
  10589a:	85 c0                	test   %eax,%eax
  10589c:	75 0e                	jne    1058ac <kfree+0x21a>
  10589e:	8b 44 24 18          	mov    0x18(%esp),%eax
  1058a2:	8b 50 04             	mov    0x4(%eax),%edx
  1058a5:	8b 44 24 14          	mov    0x14(%esp),%eax
  1058a9:	89 50 14             	mov    %edx,0x14(%eax)
							// minor.


	// We need to clean up after the majors now....

	if ( maj->first == NULL )	// Block completely unused.
  1058ac:	8b 44 24 14          	mov    0x14(%esp),%eax
  1058b0:	8b 40 14             	mov    0x14(%eax),%eax
  1058b3:	85 c0                	test   %eax,%eax
  1058b5:	0f 85 9f 00 00 00    	jne    10595a <kfree+0x2c8>
	{
		if ( l_memRoot == maj ) l_memRoot = maj->next;
  1058bb:	a1 28 53 11 00       	mov    0x115328,%eax
  1058c0:	39 44 24 14          	cmp    %eax,0x14(%esp)
  1058c4:	75 0c                	jne    1058d2 <kfree+0x240>
  1058c6:	8b 44 24 14          	mov    0x14(%esp),%eax
  1058ca:	8b 40 04             	mov    0x4(%eax),%eax
  1058cd:	a3 28 53 11 00       	mov    %eax,0x115328
		if ( l_bestBet == maj ) l_bestBet = NULL;
  1058d2:	a1 2c 53 11 00       	mov    0x11532c,%eax
  1058d7:	39 44 24 14          	cmp    %eax,0x14(%esp)
  1058db:	75 0a                	jne    1058e7 <kfree+0x255>
  1058dd:	c7 05 2c 53 11 00 00 	movl   $0x0,0x11532c
  1058e4:	00 00 00 
		if ( maj->prev != NULL ) maj->prev->next = maj->next;
  1058e7:	8b 44 24 14          	mov    0x14(%esp),%eax
  1058eb:	8b 00                	mov    (%eax),%eax
  1058ed:	85 c0                	test   %eax,%eax
  1058ef:	74 10                	je     105901 <kfree+0x26f>
  1058f1:	8b 44 24 14          	mov    0x14(%esp),%eax
  1058f5:	8b 00                	mov    (%eax),%eax
  1058f7:	8b 54 24 14          	mov    0x14(%esp),%edx
  1058fb:	8b 52 04             	mov    0x4(%edx),%edx
  1058fe:	89 50 04             	mov    %edx,0x4(%eax)
		if ( maj->next != NULL ) maj->next->prev = maj->prev;
  105901:	8b 44 24 14          	mov    0x14(%esp),%eax
  105905:	8b 40 04             	mov    0x4(%eax),%eax
  105908:	85 c0                	test   %eax,%eax
  10590a:	74 0f                	je     10591b <kfree+0x289>
  10590c:	8b 44 24 14          	mov    0x14(%esp),%eax
  105910:	8b 40 04             	mov    0x4(%eax),%eax
  105913:	8b 54 24 14          	mov    0x14(%esp),%edx
  105917:	8b 12                	mov    (%edx),%edx
  105919:	89 10                	mov    %edx,(%eax)
		l_allocated -= maj->size;
  10591b:	a1 30 53 11 00       	mov    0x115330,%eax
  105920:	8b 15 34 53 11 00    	mov    0x115334,%edx
  105926:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  10592a:	8b 49 0c             	mov    0xc(%ecx),%ecx
  10592d:	bb 00 00 00 00       	mov    $0x0,%ebx
  105932:	29 c8                	sub    %ecx,%eax
  105934:	19 da                	sbb    %ebx,%edx
  105936:	a3 30 53 11 00       	mov    %eax,0x115330
  10593b:	89 15 34 53 11 00    	mov    %edx,0x115334

		liballoc_free( maj, maj->pages );
  105941:	8b 44 24 14          	mov    0x14(%esp),%eax
  105945:	8b 40 08             	mov    0x8(%eax),%eax
  105948:	83 ec 08             	sub    $0x8,%esp
  10594b:	50                   	push   %eax
  10594c:	ff 74 24 20          	pushl  0x20(%esp)
  105950:	e8 6b e4 ff ff       	call   103dc0 <liballoc_free>
  105955:	83 c4 10             	add    $0x10,%esp
  105958:	eb 4a                	jmp    1059a4 <kfree+0x312>
	}
	else
	{
		if ( l_bestBet != NULL )
  10595a:	a1 2c 53 11 00       	mov    0x11532c,%eax
  10595f:	85 c0                	test   %eax,%eax
  105961:	74 41                	je     1059a4 <kfree+0x312>
		{
			int bestSize = l_bestBet->size  - l_bestBet->usage;
  105963:	a1 2c 53 11 00       	mov    0x11532c,%eax
  105968:	8b 50 0c             	mov    0xc(%eax),%edx
  10596b:	a1 2c 53 11 00       	mov    0x11532c,%eax
  105970:	8b 40 10             	mov    0x10(%eax),%eax
  105973:	29 c2                	sub    %eax,%edx
  105975:	89 d0                	mov    %edx,%eax
  105977:	89 44 24 10          	mov    %eax,0x10(%esp)
			int majSize = maj->size - maj->usage;
  10597b:	8b 44 24 14          	mov    0x14(%esp),%eax
  10597f:	8b 50 0c             	mov    0xc(%eax),%edx
  105982:	8b 44 24 14          	mov    0x14(%esp),%eax
  105986:	8b 40 10             	mov    0x10(%eax),%eax
  105989:	29 c2                	sub    %eax,%edx
  10598b:	89 d0                	mov    %edx,%eax
  10598d:	89 44 24 0c          	mov    %eax,0xc(%esp)

			if ( majSize > bestSize ) l_bestBet = maj;
  105991:	8b 44 24 0c          	mov    0xc(%esp),%eax
  105995:	3b 44 24 10          	cmp    0x10(%esp),%eax
  105999:	7e 09                	jle    1059a4 <kfree+0x312>
  10599b:	8b 44 24 14          	mov    0x14(%esp),%eax
  10599f:	a3 2c 53 11 00       	mov    %eax,0x11532c

	}
	

	#ifdef DEBUG
	printf( "OK\n");
  1059a4:	83 ec 0c             	sub    $0xc,%esp
  1059a7:	68 2e a9 10 00       	push   $0x10a92e
  1059ac:	e8 21 0f 00 00       	call   1068d2 <tfp_printf>
  1059b1:	83 c4 10             	add    $0x10,%esp
	FLUSH();
	#endif
	
	liballoc_unlock();		// release the lock
  1059b4:	e8 f0 e3 ff ff       	call   103da9 <liballoc_unlock>
}
  1059b9:	83 c4 28             	add    $0x28,%esp
  1059bc:	5b                   	pop    %ebx
  1059bd:	c3                   	ret    

001059be <kcalloc>:




void* PREFIX(calloc)(size_t nobj, size_t size)
{
  1059be:	83 ec 1c             	sub    $0x1c,%esp
       int real_size;
       void *p;

       real_size = nobj * size;
  1059c1:	8b 44 24 20          	mov    0x20(%esp),%eax
  1059c5:	0f af 44 24 24       	imul   0x24(%esp),%eax
  1059ca:	89 44 24 0c          	mov    %eax,0xc(%esp)
       
       p = PREFIX(malloc)( real_size );
  1059ce:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1059d2:	83 ec 0c             	sub    $0xc,%esp
  1059d5:	50                   	push   %eax
  1059d6:	e8 32 f4 ff ff       	call   104e0d <kmalloc>
  1059db:	83 c4 10             	add    $0x10,%esp
  1059de:	89 44 24 08          	mov    %eax,0x8(%esp)

       liballoc_memset( p, 0, real_size );
  1059e2:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1059e6:	83 ec 04             	sub    $0x4,%esp
  1059e9:	50                   	push   %eax
  1059ea:	6a 00                	push   $0x0
  1059ec:	ff 74 24 14          	pushl  0x14(%esp)
  1059f0:	e8 ba f0 ff ff       	call   104aaf <liballoc_memset>
  1059f5:	83 c4 10             	add    $0x10,%esp

       return p;
  1059f8:	8b 44 24 08          	mov    0x8(%esp),%eax
}
  1059fc:	83 c4 1c             	add    $0x1c,%esp
  1059ff:	c3                   	ret    

00105a00 <krealloc>:



void*   PREFIX(realloc)(void *p, size_t size)
{
  105a00:	83 ec 1c             	sub    $0x1c,%esp
	void *ptr;
	struct liballoc_minor *min;
	unsigned int real_size;
	
	// Honour the case of size == 0 => free old and return NULL
	if ( size == 0 )
  105a03:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  105a08:	75 19                	jne    105a23 <krealloc+0x23>
	{
		PREFIX(free)( p );
  105a0a:	83 ec 0c             	sub    $0xc,%esp
  105a0d:	ff 74 24 2c          	pushl  0x2c(%esp)
  105a11:	e8 7c fc ff ff       	call   105692 <kfree>
  105a16:	83 c4 10             	add    $0x10,%esp
		return NULL;
  105a19:	b8 00 00 00 00       	mov    $0x0,%eax
  105a1e:	e9 ac 01 00 00       	jmp    105bcf <krealloc+0x1cf>
	}

	// In the case of a NULL pointer, return a simple malloc.
	if ( p == NULL ) return PREFIX(malloc)( size );
  105a23:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
  105a28:	75 14                	jne    105a3e <krealloc+0x3e>
  105a2a:	83 ec 0c             	sub    $0xc,%esp
  105a2d:	ff 74 24 30          	pushl  0x30(%esp)
  105a31:	e8 d7 f3 ff ff       	call   104e0d <kmalloc>
  105a36:	83 c4 10             	add    $0x10,%esp
  105a39:	e9 91 01 00 00       	jmp    105bcf <krealloc+0x1cf>

	// Unalign the pointer if required.
	ptr = p;
  105a3e:	8b 44 24 20          	mov    0x20(%esp),%eax
  105a42:	89 44 24 0c          	mov    %eax,0xc(%esp)
	UNALIGN(ptr);
  105a46:	8b 44 24 0c          	mov    0xc(%esp),%eax
  105a4a:	83 e8 10             	sub    $0x10,%eax
  105a4d:	0f b6 00             	movzbl (%eax),%eax
  105a50:	0f be c0             	movsbl %al,%eax
  105a53:	89 44 24 08          	mov    %eax,0x8(%esp)
  105a57:	83 7c 24 08 1f       	cmpl   $0x1f,0x8(%esp)
  105a5c:	77 0c                	ja     105a6a <krealloc+0x6a>
  105a5e:	8b 44 24 0c          	mov    0xc(%esp),%eax
  105a62:	2b 44 24 08          	sub    0x8(%esp),%eax
  105a66:	89 44 24 0c          	mov    %eax,0xc(%esp)

	liballoc_lock();		// lockit
  105a6a:	e8 11 e3 ff ff       	call   103d80 <liballoc_lock>

		min = (struct liballoc_minor*)((uintptr_t)ptr - sizeof( struct liballoc_minor ));
  105a6f:	8b 44 24 0c          	mov    0xc(%esp),%eax
  105a73:	83 e8 18             	sub    $0x18,%eax
  105a76:	89 44 24 04          	mov    %eax,0x4(%esp)

		// Ensure it is a valid structure.
		if ( min->magic != LIBALLOC_MAGIC ) 
  105a7a:	8b 44 24 04          	mov    0x4(%esp),%eax
  105a7e:	8b 40 0c             	mov    0xc(%eax),%eax
  105a81:	3d de c0 01 c0       	cmp    $0xc001c0de,%eax
  105a86:	0f 84 d8 00 00 00    	je     105b64 <krealloc+0x164>
		{
			l_errorCount += 1;
  105a8c:	a1 48 53 11 00       	mov    0x115348,%eax
  105a91:	8b 15 4c 53 11 00    	mov    0x11534c,%edx
  105a97:	83 c0 01             	add    $0x1,%eax
  105a9a:	83 d2 00             	adc    $0x0,%edx
  105a9d:	a3 48 53 11 00       	mov    %eax,0x115348
  105aa2:	89 15 4c 53 11 00    	mov    %edx,0x11534c
	
			// Check for overrun errors. For all bytes of LIBALLOC_MAGIC 
			if ( 
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
  105aa8:	8b 44 24 04          	mov    0x4(%esp),%eax
  105aac:	8b 40 0c             	mov    0xc(%eax),%eax
  105aaf:	25 ff ff ff 00       	and    $0xffffff,%eax
			if ( 
  105ab4:	3d de c0 01 00       	cmp    $0x1c0de,%eax
  105ab9:	74 22                	je     105add <krealloc+0xdd>
				((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
  105abb:	8b 44 24 04          	mov    0x4(%esp),%eax
  105abf:	8b 40 0c             	mov    0xc(%eax),%eax
  105ac2:	0f b7 c0             	movzwl %ax,%eax
				((min->magic & 0xFFFFFF) == (LIBALLOC_MAGIC & 0xFFFFFF)) || 
  105ac5:	3d de c0 00 00       	cmp    $0xc0de,%eax
  105aca:	74 11                	je     105add <krealloc+0xdd>
				((min->magic & 0xFF) == (LIBALLOC_MAGIC & 0xFF)) 
  105acc:	8b 44 24 04          	mov    0x4(%esp),%eax
  105ad0:	8b 40 0c             	mov    0xc(%eax),%eax
  105ad3:	0f b6 c0             	movzbl %al,%eax
				((min->magic & 0xFFFF) == (LIBALLOC_MAGIC & 0xFFFF)) || 
  105ad6:	3d de 00 00 00       	cmp    $0xde,%eax
  105adb:	75 39                	jne    105b16 <krealloc+0x116>
			   )
			{
				l_possibleOverruns += 1;
  105add:	a1 50 53 11 00       	mov    0x115350,%eax
  105ae2:	8b 15 54 53 11 00    	mov    0x115354,%edx
  105ae8:	83 c0 01             	add    $0x1,%eax
  105aeb:	83 d2 00             	adc    $0x0,%edx
  105aee:	a3 50 53 11 00       	mov    %eax,0x115350
  105af3:	89 15 54 53 11 00    	mov    %edx,0x115354
				#if defined DEBUG || defined INFO
				printf( "liballoc: ERROR: Possible 1-3 byte overrun for magic %x != %x\n",
  105af9:	8b 44 24 04          	mov    0x4(%esp),%eax
  105afd:	8b 40 0c             	mov    0xc(%eax),%eax
  105b00:	83 ec 04             	sub    $0x4,%esp
  105b03:	68 de c0 01 c0       	push   $0xc001c0de
  105b08:	50                   	push   %eax
  105b09:	68 50 a8 10 00       	push   $0x10a850
  105b0e:	e8 bf 0d 00 00       	call   1068d2 <tfp_printf>
  105b13:	83 c4 10             	add    $0x10,%esp
				FLUSH();
				#endif
			}
							
							
			if ( min->magic == LIBALLOC_DEAD )
  105b16:	8b 44 24 04          	mov    0x4(%esp),%eax
  105b1a:	8b 40 0c             	mov    0xc(%eax),%eax
  105b1d:	3d ad de ad de       	cmp    $0xdeaddead,%eax
  105b22:	75 1b                	jne    105b3f <krealloc+0x13f>
			{
				#if defined DEBUG || defined INFO
				printf( "liballoc: ERROR: multiple PREFIX(free)() attempt on %x from %x.\n", 
  105b24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  105b28:	83 ec 04             	sub    $0x4,%esp
  105b2b:	50                   	push   %eax
  105b2c:	ff 74 24 14          	pushl  0x14(%esp)
  105b30:	68 90 a8 10 00       	push   $0x10a890
  105b35:	e8 98 0d 00 00       	call   1068d2 <tfp_printf>
  105b3a:	83 c4 10             	add    $0x10,%esp
  105b3d:	eb 19                	jmp    105b58 <krealloc+0x158>
				#endif
			}
			else
			{
				#if defined DEBUG || defined INFO
				printf( "liballoc: ERROR: Bad PREFIX(free)( %x ) called from %x\n",
  105b3f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  105b43:	83 ec 04             	sub    $0x4,%esp
  105b46:	50                   	push   %eax
  105b47:	ff 74 24 14          	pushl  0x14(%esp)
  105b4b:	68 d4 a8 10 00       	push   $0x10a8d4
  105b50:	e8 7d 0d 00 00       	call   1068d2 <tfp_printf>
  105b55:	83 c4 10             	add    $0x10,%esp
				FLUSH();
				#endif
			}
			
			// being lied to...
			liballoc_unlock();		// release the lock
  105b58:	e8 4c e2 ff ff       	call   103da9 <liballoc_unlock>
			return NULL;
  105b5d:	b8 00 00 00 00       	mov    $0x0,%eax
  105b62:	eb 6b                	jmp    105bcf <krealloc+0x1cf>
		}	
		
		// Definitely a memory block.
		
		real_size = min->req_size;
  105b64:	8b 44 24 04          	mov    0x4(%esp),%eax
  105b68:	8b 40 14             	mov    0x14(%eax),%eax
  105b6b:	89 04 24             	mov    %eax,(%esp)

		if ( real_size >= size ) 
  105b6e:	8b 04 24             	mov    (%esp),%eax
  105b71:	3b 44 24 24          	cmp    0x24(%esp),%eax
  105b75:	72 16                	jb     105b8d <krealloc+0x18d>
		{
			min->req_size = size;
  105b77:	8b 44 24 04          	mov    0x4(%esp),%eax
  105b7b:	8b 54 24 24          	mov    0x24(%esp),%edx
  105b7f:	89 50 14             	mov    %edx,0x14(%eax)
			liballoc_unlock();
  105b82:	e8 22 e2 ff ff       	call   103da9 <liballoc_unlock>
			return p;
  105b87:	8b 44 24 20          	mov    0x20(%esp),%eax
  105b8b:	eb 42                	jmp    105bcf <krealloc+0x1cf>
		}

	liballoc_unlock();
  105b8d:	e8 17 e2 ff ff       	call   103da9 <liballoc_unlock>

	// If we got here then we're reallocating to a block bigger than us.
	ptr = PREFIX(malloc)( size );					// We need to allocate new memory
  105b92:	83 ec 0c             	sub    $0xc,%esp
  105b95:	ff 74 24 30          	pushl  0x30(%esp)
  105b99:	e8 6f f2 ff ff       	call   104e0d <kmalloc>
  105b9e:	83 c4 10             	add    $0x10,%esp
  105ba1:	89 44 24 0c          	mov    %eax,0xc(%esp)
	liballoc_memcpy( ptr, p, real_size );
  105ba5:	83 ec 04             	sub    $0x4,%esp
  105ba8:	ff 74 24 04          	pushl  0x4(%esp)
  105bac:	ff 74 24 28          	pushl  0x28(%esp)
  105bb0:	ff 74 24 18          	pushl  0x18(%esp)
  105bb4:	e8 2a ef ff ff       	call   104ae3 <liballoc_memcpy>
  105bb9:	83 c4 10             	add    $0x10,%esp
	PREFIX(free)( p );
  105bbc:	83 ec 0c             	sub    $0xc,%esp
  105bbf:	ff 74 24 2c          	pushl  0x2c(%esp)
  105bc3:	e8 ca fa ff ff       	call   105692 <kfree>
  105bc8:	83 c4 10             	add    $0x10,%esp

	return ptr;
  105bcb:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  105bcf:	83 c4 1c             	add    $0x1c,%esp
  105bd2:	c3                   	ret    

00105bd3 <ulli2a>:


#ifdef PRINTF_LONG_LONG_SUPPORT
static void _TFP_GCC_NO_INLINE_ ulli2a(
        unsigned long long int num, struct param *p)
{
  105bd3:	57                   	push   %edi
  105bd4:	56                   	push   %esi
  105bd5:	53                   	push   %ebx
  105bd6:	83 ec 30             	sub    $0x30,%esp
  105bd9:	8b 44 24 40          	mov    0x40(%esp),%eax
  105bdd:	89 44 24 08          	mov    %eax,0x8(%esp)
  105be1:	8b 44 24 44          	mov    0x44(%esp),%eax
  105be5:	89 44 24 0c          	mov    %eax,0xc(%esp)
    int n = 0;
  105be9:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
  105bf0:	00 
    unsigned long long int d = 1;
  105bf1:	c7 44 24 20 01 00 00 	movl   $0x1,0x20(%esp)
  105bf8:	00 
  105bf9:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
  105c00:	00 
    char *bf = p->bf;
  105c01:	8b 44 24 48          	mov    0x48(%esp),%eax
  105c05:	8b 40 14             	mov    0x14(%eax),%eax
  105c08:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    while (num / d >= p->base)
  105c0c:	eb 36                	jmp    105c44 <ulli2a+0x71>
        d *= p->base;
  105c0e:	8b 44 24 48          	mov    0x48(%esp),%eax
  105c12:	8b 40 10             	mov    0x10(%eax),%eax
  105c15:	ba 00 00 00 00       	mov    $0x0,%edx
  105c1a:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  105c1e:	89 cb                	mov    %ecx,%ebx
  105c20:	0f af d8             	imul   %eax,%ebx
  105c23:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  105c27:	0f af ca             	imul   %edx,%ecx
  105c2a:	01 d9                	add    %ebx,%ecx
  105c2c:	f7 64 24 20          	mull   0x20(%esp)
  105c30:	01 d1                	add    %edx,%ecx
  105c32:	89 ca                	mov    %ecx,%edx
  105c34:	89 44 24 20          	mov    %eax,0x20(%esp)
  105c38:	89 54 24 24          	mov    %edx,0x24(%esp)
  105c3c:	89 44 24 20          	mov    %eax,0x20(%esp)
  105c40:	89 54 24 24          	mov    %edx,0x24(%esp)
    while (num / d >= p->base)
  105c44:	ff 74 24 24          	pushl  0x24(%esp)
  105c48:	ff 74 24 24          	pushl  0x24(%esp)
  105c4c:	ff 74 24 14          	pushl  0x14(%esp)
  105c50:	ff 74 24 14          	pushl  0x14(%esp)
  105c54:	e8 37 15 00 00       	call   107190 <__udivdi3>
  105c59:	83 c4 10             	add    $0x10,%esp
  105c5c:	89 c1                	mov    %eax,%ecx
  105c5e:	89 d3                	mov    %edx,%ebx
  105c60:	8b 44 24 48          	mov    0x48(%esp),%eax
  105c64:	8b 40 10             	mov    0x10(%eax),%eax
  105c67:	ba 00 00 00 00       	mov    $0x0,%edx
  105c6c:	39 d3                	cmp    %edx,%ebx
  105c6e:	77 9e                	ja     105c0e <ulli2a+0x3b>
  105c70:	39 d3                	cmp    %edx,%ebx
  105c72:	0f 82 e2 00 00 00    	jb     105d5a <ulli2a+0x187>
  105c78:	39 c1                	cmp    %eax,%ecx
  105c7a:	73 92                	jae    105c0e <ulli2a+0x3b>
    while (d != 0) {
  105c7c:	e9 d9 00 00 00       	jmp    105d5a <ulli2a+0x187>
        int dgt = num / d;
  105c81:	ff 74 24 24          	pushl  0x24(%esp)
  105c85:	ff 74 24 24          	pushl  0x24(%esp)
  105c89:	ff 74 24 14          	pushl  0x14(%esp)
  105c8d:	ff 74 24 14          	pushl  0x14(%esp)
  105c91:	e8 fa 14 00 00       	call   107190 <__udivdi3>
  105c96:	83 c4 10             	add    $0x10,%esp
  105c99:	89 44 24 18          	mov    %eax,0x18(%esp)
        num %= d;
  105c9d:	8b 44 24 08          	mov    0x8(%esp),%eax
  105ca1:	8b 54 24 0c          	mov    0xc(%esp),%edx
  105ca5:	ff 74 24 24          	pushl  0x24(%esp)
  105ca9:	ff 74 24 24          	pushl  0x24(%esp)
  105cad:	52                   	push   %edx
  105cae:	50                   	push   %eax
  105caf:	e8 0c 16 00 00       	call   1072c0 <__umoddi3>
  105cb4:	83 c4 10             	add    $0x10,%esp
  105cb7:	89 44 24 08          	mov    %eax,0x8(%esp)
  105cbb:	89 54 24 0c          	mov    %edx,0xc(%esp)
        d /= p->base;
  105cbf:	8b 44 24 48          	mov    0x48(%esp),%eax
  105cc3:	8b 40 10             	mov    0x10(%eax),%eax
  105cc6:	ba 00 00 00 00       	mov    $0x0,%edx
  105ccb:	52                   	push   %edx
  105ccc:	50                   	push   %eax
  105ccd:	ff 74 24 2c          	pushl  0x2c(%esp)
  105cd1:	ff 74 24 2c          	pushl  0x2c(%esp)
  105cd5:	e8 b6 14 00 00       	call   107190 <__udivdi3>
  105cda:	83 c4 10             	add    $0x10,%esp
  105cdd:	89 44 24 20          	mov    %eax,0x20(%esp)
  105ce1:	89 54 24 24          	mov    %edx,0x24(%esp)
        if (n || dgt > 0 || d == 0) {
  105ce5:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
  105cea:	75 2b                	jne    105d17 <ulli2a+0x144>
  105cec:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
  105cf1:	7f 24                	jg     105d17 <ulli2a+0x144>
  105cf3:	8b 44 24 20          	mov    0x20(%esp),%eax
  105cf7:	80 f4 00             	xor    $0x0,%ah
  105cfa:	89 04 24             	mov    %eax,(%esp)
  105cfd:	8b 44 24 24          	mov    0x24(%esp),%eax
  105d01:	80 f4 00             	xor    $0x0,%ah
  105d04:	89 44 24 04          	mov    %eax,0x4(%esp)
  105d08:	8b 14 24             	mov    (%esp),%edx
  105d0b:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  105d0f:	89 c8                	mov    %ecx,%eax
  105d11:	09 d0                	or     %edx,%eax
  105d13:	85 c0                	test   %eax,%eax
  105d15:	75 43                	jne    105d5a <ulli2a+0x187>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
  105d17:	83 7c 24 18 09       	cmpl   $0x9,0x18(%esp)
  105d1c:	7e 1c                	jle    105d3a <ulli2a+0x167>
  105d1e:	8b 44 24 48          	mov    0x48(%esp),%eax
  105d22:	0f b6 00             	movzbl (%eax),%eax
  105d25:	83 e0 04             	and    $0x4,%eax
  105d28:	84 c0                	test   %al,%al
  105d2a:	74 07                	je     105d33 <ulli2a+0x160>
  105d2c:	b8 37 00 00 00       	mov    $0x37,%eax
  105d31:	eb 0c                	jmp    105d3f <ulli2a+0x16c>
  105d33:	b8 57 00 00 00       	mov    $0x57,%eax
  105d38:	eb 05                	jmp    105d3f <ulli2a+0x16c>
  105d3a:	b8 30 00 00 00       	mov    $0x30,%eax
  105d3f:	8b 54 24 18          	mov    0x18(%esp),%edx
  105d43:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
  105d46:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  105d4a:	8d 50 01             	lea    0x1(%eax),%edx
  105d4d:	89 54 24 1c          	mov    %edx,0x1c(%esp)
  105d51:	89 ca                	mov    %ecx,%edx
  105d53:	88 10                	mov    %dl,(%eax)
            ++n;
  105d55:	83 44 24 2c 01       	addl   $0x1,0x2c(%esp)
    while (d != 0) {
  105d5a:	8b 44 24 20          	mov    0x20(%esp),%eax
  105d5e:	80 f4 00             	xor    $0x0,%ah
  105d61:	89 c6                	mov    %eax,%esi
  105d63:	8b 44 24 24          	mov    0x24(%esp),%eax
  105d67:	80 f4 00             	xor    $0x0,%ah
  105d6a:	89 c7                	mov    %eax,%edi
  105d6c:	89 f8                	mov    %edi,%eax
  105d6e:	09 f0                	or     %esi,%eax
  105d70:	85 c0                	test   %eax,%eax
  105d72:	0f 85 09 ff ff ff    	jne    105c81 <ulli2a+0xae>
        }
    }
    *bf = 0;
  105d78:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  105d7c:	c6 00 00             	movb   $0x0,(%eax)
}
  105d7f:	90                   	nop
  105d80:	83 c4 30             	add    $0x30,%esp
  105d83:	5b                   	pop    %ebx
  105d84:	5e                   	pop    %esi
  105d85:	5f                   	pop    %edi
  105d86:	c3                   	ret    

00105d87 <lli2a>:

static void lli2a(long long int num, struct param *p)
{
  105d87:	83 ec 1c             	sub    $0x1c,%esp
  105d8a:	8b 44 24 20          	mov    0x20(%esp),%eax
  105d8e:	89 44 24 08          	mov    %eax,0x8(%esp)
  105d92:	8b 44 24 24          	mov    0x24(%esp),%eax
  105d96:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (num < 0) {
  105d9a:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
  105d9f:	79 15                	jns    105db6 <lli2a+0x2f>
        num = -num;
  105da1:	f7 5c 24 08          	negl   0x8(%esp)
  105da5:	83 54 24 0c 00       	adcl   $0x0,0xc(%esp)
  105daa:	f7 5c 24 0c          	negl   0xc(%esp)
        p->sign = '-';
  105dae:	8b 44 24 28          	mov    0x28(%esp),%eax
  105db2:	c6 40 0c 2d          	movb   $0x2d,0xc(%eax)
    }
    ulli2a(num, p);
  105db6:	8b 44 24 08          	mov    0x8(%esp),%eax
  105dba:	8b 54 24 0c          	mov    0xc(%esp),%edx
  105dbe:	83 ec 04             	sub    $0x4,%esp
  105dc1:	ff 74 24 2c          	pushl  0x2c(%esp)
  105dc5:	52                   	push   %edx
  105dc6:	50                   	push   %eax
  105dc7:	e8 07 fe ff ff       	call   105bd3 <ulli2a>
  105dcc:	83 c4 10             	add    $0x10,%esp
}
  105dcf:	90                   	nop
  105dd0:	83 c4 1c             	add    $0x1c,%esp
  105dd3:	c3                   	ret    

00105dd4 <uli2a>:
#endif

#ifdef PRINTF_LONG_SUPPORT
static void uli2a(unsigned long int num, struct param *p)
{
  105dd4:	83 ec 10             	sub    $0x10,%esp
    int n = 0;
  105dd7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105dde:	00 
    unsigned long int d = 1;
  105ddf:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  105de6:	00 
    char *bf = p->bf;
  105de7:	8b 44 24 18          	mov    0x18(%esp),%eax
  105deb:	8b 40 14             	mov    0x14(%eax),%eax
  105dee:	89 44 24 04          	mov    %eax,0x4(%esp)
    while (num / d >= p->base)
  105df2:	eb 12                	jmp    105e06 <uli2a+0x32>
        d *= p->base;
  105df4:	8b 44 24 18          	mov    0x18(%esp),%eax
  105df8:	8b 40 10             	mov    0x10(%eax),%eax
  105dfb:	8b 54 24 08          	mov    0x8(%esp),%edx
  105dff:	0f af c2             	imul   %edx,%eax
  105e02:	89 44 24 08          	mov    %eax,0x8(%esp)
    while (num / d >= p->base)
  105e06:	8b 44 24 14          	mov    0x14(%esp),%eax
  105e0a:	ba 00 00 00 00       	mov    $0x0,%edx
  105e0f:	f7 74 24 08          	divl   0x8(%esp)
  105e13:	89 c2                	mov    %eax,%edx
  105e15:	8b 44 24 18          	mov    0x18(%esp),%eax
  105e19:	8b 40 10             	mov    0x10(%eax),%eax
  105e1c:	39 c2                	cmp    %eax,%edx
  105e1e:	73 d4                	jae    105df4 <uli2a+0x20>
    while (d != 0) {
  105e20:	e9 8c 00 00 00       	jmp    105eb1 <uli2a+0xdd>
        int dgt = num / d;
  105e25:	8b 44 24 14          	mov    0x14(%esp),%eax
  105e29:	ba 00 00 00 00       	mov    $0x0,%edx
  105e2e:	f7 74 24 08          	divl   0x8(%esp)
  105e32:	89 04 24             	mov    %eax,(%esp)
        num %= d;
  105e35:	8b 44 24 14          	mov    0x14(%esp),%eax
  105e39:	ba 00 00 00 00       	mov    $0x0,%edx
  105e3e:	f7 74 24 08          	divl   0x8(%esp)
  105e42:	89 54 24 14          	mov    %edx,0x14(%esp)
        d /= p->base;
  105e46:	8b 44 24 18          	mov    0x18(%esp),%eax
  105e4a:	8b 48 10             	mov    0x10(%eax),%ecx
  105e4d:	8b 44 24 08          	mov    0x8(%esp),%eax
  105e51:	ba 00 00 00 00       	mov    $0x0,%edx
  105e56:	f7 f1                	div    %ecx
  105e58:	89 44 24 08          	mov    %eax,0x8(%esp)
        if (n || dgt > 0 || d == 0) {
  105e5c:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
  105e61:	75 0d                	jne    105e70 <uli2a+0x9c>
  105e63:	83 3c 24 00          	cmpl   $0x0,(%esp)
  105e67:	7f 07                	jg     105e70 <uli2a+0x9c>
  105e69:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  105e6e:	75 41                	jne    105eb1 <uli2a+0xdd>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
  105e70:	83 3c 24 09          	cmpl   $0x9,(%esp)
  105e74:	7e 1c                	jle    105e92 <uli2a+0xbe>
  105e76:	8b 44 24 18          	mov    0x18(%esp),%eax
  105e7a:	0f b6 00             	movzbl (%eax),%eax
  105e7d:	83 e0 04             	and    $0x4,%eax
  105e80:	84 c0                	test   %al,%al
  105e82:	74 07                	je     105e8b <uli2a+0xb7>
  105e84:	b8 37 00 00 00       	mov    $0x37,%eax
  105e89:	eb 0c                	jmp    105e97 <uli2a+0xc3>
  105e8b:	b8 57 00 00 00       	mov    $0x57,%eax
  105e90:	eb 05                	jmp    105e97 <uli2a+0xc3>
  105e92:	b8 30 00 00 00       	mov    $0x30,%eax
  105e97:	8b 14 24             	mov    (%esp),%edx
  105e9a:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
  105e9d:	8b 44 24 04          	mov    0x4(%esp),%eax
  105ea1:	8d 50 01             	lea    0x1(%eax),%edx
  105ea4:	89 54 24 04          	mov    %edx,0x4(%esp)
  105ea8:	89 ca                	mov    %ecx,%edx
  105eaa:	88 10                	mov    %dl,(%eax)
            ++n;
  105eac:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    while (d != 0) {
  105eb1:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  105eb6:	0f 85 69 ff ff ff    	jne    105e25 <uli2a+0x51>
        }
    }
    *bf = 0;
  105ebc:	8b 44 24 04          	mov    0x4(%esp),%eax
  105ec0:	c6 00 00             	movb   $0x0,(%eax)
}
  105ec3:	90                   	nop
  105ec4:	83 c4 10             	add    $0x10,%esp
  105ec7:	c3                   	ret    

00105ec8 <li2a>:

static void li2a(long num, struct param *p)
{
    if (num < 0) {
  105ec8:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  105ecd:	79 0c                	jns    105edb <li2a+0x13>
        num = -num;
  105ecf:	f7 5c 24 04          	negl   0x4(%esp)
        p->sign = '-';
  105ed3:	8b 44 24 08          	mov    0x8(%esp),%eax
  105ed7:	c6 40 0c 2d          	movb   $0x2d,0xc(%eax)
    }
    uli2a(num, p);
  105edb:	8b 44 24 04          	mov    0x4(%esp),%eax
  105edf:	ff 74 24 08          	pushl  0x8(%esp)
  105ee3:	50                   	push   %eax
  105ee4:	e8 eb fe ff ff       	call   105dd4 <uli2a>
  105ee9:	83 c4 08             	add    $0x8,%esp
}
  105eec:	90                   	nop
  105eed:	c3                   	ret    

00105eee <ui2a>:
#endif

static void ui2a(unsigned int num, struct param *p)
{
  105eee:	83 ec 10             	sub    $0x10,%esp
    int n = 0;
  105ef1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105ef8:	00 
    unsigned int d = 1;
  105ef9:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  105f00:	00 
    char *bf = p->bf;
  105f01:	8b 44 24 18          	mov    0x18(%esp),%eax
  105f05:	8b 40 14             	mov    0x14(%eax),%eax
  105f08:	89 44 24 04          	mov    %eax,0x4(%esp)
    while (num / d >= p->base)
  105f0c:	eb 12                	jmp    105f20 <ui2a+0x32>
        d *= p->base;
  105f0e:	8b 44 24 18          	mov    0x18(%esp),%eax
  105f12:	8b 40 10             	mov    0x10(%eax),%eax
  105f15:	8b 54 24 08          	mov    0x8(%esp),%edx
  105f19:	0f af c2             	imul   %edx,%eax
  105f1c:	89 44 24 08          	mov    %eax,0x8(%esp)
    while (num / d >= p->base)
  105f20:	8b 44 24 14          	mov    0x14(%esp),%eax
  105f24:	ba 00 00 00 00       	mov    $0x0,%edx
  105f29:	f7 74 24 08          	divl   0x8(%esp)
  105f2d:	89 c2                	mov    %eax,%edx
  105f2f:	8b 44 24 18          	mov    0x18(%esp),%eax
  105f33:	8b 40 10             	mov    0x10(%eax),%eax
  105f36:	39 c2                	cmp    %eax,%edx
  105f38:	73 d4                	jae    105f0e <ui2a+0x20>
    while (d != 0) {
  105f3a:	e9 8c 00 00 00       	jmp    105fcb <ui2a+0xdd>
        int dgt = num / d;
  105f3f:	8b 44 24 14          	mov    0x14(%esp),%eax
  105f43:	ba 00 00 00 00       	mov    $0x0,%edx
  105f48:	f7 74 24 08          	divl   0x8(%esp)
  105f4c:	89 04 24             	mov    %eax,(%esp)
        num %= d;
  105f4f:	8b 44 24 14          	mov    0x14(%esp),%eax
  105f53:	ba 00 00 00 00       	mov    $0x0,%edx
  105f58:	f7 74 24 08          	divl   0x8(%esp)
  105f5c:	89 54 24 14          	mov    %edx,0x14(%esp)
        d /= p->base;
  105f60:	8b 44 24 18          	mov    0x18(%esp),%eax
  105f64:	8b 48 10             	mov    0x10(%eax),%ecx
  105f67:	8b 44 24 08          	mov    0x8(%esp),%eax
  105f6b:	ba 00 00 00 00       	mov    $0x0,%edx
  105f70:	f7 f1                	div    %ecx
  105f72:	89 44 24 08          	mov    %eax,0x8(%esp)
        if (n || dgt > 0 || d == 0) {
  105f76:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
  105f7b:	75 0d                	jne    105f8a <ui2a+0x9c>
  105f7d:	83 3c 24 00          	cmpl   $0x0,(%esp)
  105f81:	7f 07                	jg     105f8a <ui2a+0x9c>
  105f83:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  105f88:	75 41                	jne    105fcb <ui2a+0xdd>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
  105f8a:	83 3c 24 09          	cmpl   $0x9,(%esp)
  105f8e:	7e 1c                	jle    105fac <ui2a+0xbe>
  105f90:	8b 44 24 18          	mov    0x18(%esp),%eax
  105f94:	0f b6 00             	movzbl (%eax),%eax
  105f97:	83 e0 04             	and    $0x4,%eax
  105f9a:	84 c0                	test   %al,%al
  105f9c:	74 07                	je     105fa5 <ui2a+0xb7>
  105f9e:	b8 37 00 00 00       	mov    $0x37,%eax
  105fa3:	eb 0c                	jmp    105fb1 <ui2a+0xc3>
  105fa5:	b8 57 00 00 00       	mov    $0x57,%eax
  105faa:	eb 05                	jmp    105fb1 <ui2a+0xc3>
  105fac:	b8 30 00 00 00       	mov    $0x30,%eax
  105fb1:	8b 14 24             	mov    (%esp),%edx
  105fb4:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
  105fb7:	8b 44 24 04          	mov    0x4(%esp),%eax
  105fbb:	8d 50 01             	lea    0x1(%eax),%edx
  105fbe:	89 54 24 04          	mov    %edx,0x4(%esp)
  105fc2:	89 ca                	mov    %ecx,%edx
  105fc4:	88 10                	mov    %dl,(%eax)
            ++n;
  105fc6:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
    while (d != 0) {
  105fcb:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  105fd0:	0f 85 69 ff ff ff    	jne    105f3f <ui2a+0x51>
        }
    }
    *bf = 0;
  105fd6:	8b 44 24 04          	mov    0x4(%esp),%eax
  105fda:	c6 00 00             	movb   $0x0,(%eax)
}
  105fdd:	90                   	nop
  105fde:	83 c4 10             	add    $0x10,%esp
  105fe1:	c3                   	ret    

00105fe2 <i2a>:

static void i2a(int num, struct param *p)
{
    if (num < 0) {
  105fe2:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
  105fe7:	79 0c                	jns    105ff5 <i2a+0x13>
        num = -num;
  105fe9:	f7 5c 24 04          	negl   0x4(%esp)
        p->sign = '-';
  105fed:	8b 44 24 08          	mov    0x8(%esp),%eax
  105ff1:	c6 40 0c 2d          	movb   $0x2d,0xc(%eax)
    }
    ui2a(num, p);
  105ff5:	8b 44 24 04          	mov    0x4(%esp),%eax
  105ff9:	ff 74 24 08          	pushl  0x8(%esp)
  105ffd:	50                   	push   %eax
  105ffe:	e8 eb fe ff ff       	call   105eee <ui2a>
  106003:	83 c4 08             	add    $0x8,%esp
}
  106006:	90                   	nop
  106007:	c3                   	ret    

00106008 <a2d>:

static int a2d(char ch)
{
  106008:	83 ec 04             	sub    $0x4,%esp
  10600b:	8b 44 24 08          	mov    0x8(%esp),%eax
  10600f:	88 04 24             	mov    %al,(%esp)
    if (ch >= '0' && ch <= '9')
  106012:	80 3c 24 2f          	cmpb   $0x2f,(%esp)
  106016:	7e 0f                	jle    106027 <a2d+0x1f>
  106018:	80 3c 24 39          	cmpb   $0x39,(%esp)
  10601c:	7f 09                	jg     106027 <a2d+0x1f>
        return ch - '0';
  10601e:	0f be 04 24          	movsbl (%esp),%eax
  106022:	83 e8 30             	sub    $0x30,%eax
  106025:	eb 2f                	jmp    106056 <a2d+0x4e>
    else if (ch >= 'a' && ch <= 'f')
  106027:	80 3c 24 60          	cmpb   $0x60,(%esp)
  10602b:	7e 0f                	jle    10603c <a2d+0x34>
  10602d:	80 3c 24 66          	cmpb   $0x66,(%esp)
  106031:	7f 09                	jg     10603c <a2d+0x34>
        return ch - 'a' + 10;
  106033:	0f be 04 24          	movsbl (%esp),%eax
  106037:	83 e8 57             	sub    $0x57,%eax
  10603a:	eb 1a                	jmp    106056 <a2d+0x4e>
    else if (ch >= 'A' && ch <= 'F')
  10603c:	80 3c 24 40          	cmpb   $0x40,(%esp)
  106040:	7e 0f                	jle    106051 <a2d+0x49>
  106042:	80 3c 24 46          	cmpb   $0x46,(%esp)
  106046:	7f 09                	jg     106051 <a2d+0x49>
        return ch - 'A' + 10;
  106048:	0f be 04 24          	movsbl (%esp),%eax
  10604c:	83 e8 37             	sub    $0x37,%eax
  10604f:	eb 05                	jmp    106056 <a2d+0x4e>
    else
        return -1;
  106051:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  106056:	83 c4 04             	add    $0x4,%esp
  106059:	c3                   	ret    

0010605a <a2u>:

static char a2u(char ch, const char **src, int base, unsigned int *nump)
{
  10605a:	83 ec 14             	sub    $0x14,%esp
  10605d:	8b 44 24 18          	mov    0x18(%esp),%eax
  106061:	88 04 24             	mov    %al,(%esp)
    const char *p = *src;
  106064:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  106068:	8b 00                	mov    (%eax),%eax
  10606a:	89 44 24 10          	mov    %eax,0x10(%esp)
    unsigned int num = 0;
  10606e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106075:	00 
    int digit;
    while ((digit = a2d(ch)) >= 0) {
  106076:	eb 30                	jmp    1060a8 <a2u+0x4e>
        if (digit > base)
  106078:	8b 44 24 08          	mov    0x8(%esp),%eax
  10607c:	3b 44 24 20          	cmp    0x20(%esp),%eax
  106080:	7f 40                	jg     1060c2 <a2u+0x68>
            break;
        num = num * base + digit;
  106082:	8b 44 24 20          	mov    0x20(%esp),%eax
  106086:	0f af 44 24 0c       	imul   0xc(%esp),%eax
  10608b:	89 c2                	mov    %eax,%edx
  10608d:	8b 44 24 08          	mov    0x8(%esp),%eax
  106091:	01 d0                	add    %edx,%eax
  106093:	89 44 24 0c          	mov    %eax,0xc(%esp)
        ch = *p++;
  106097:	8b 44 24 10          	mov    0x10(%esp),%eax
  10609b:	8d 50 01             	lea    0x1(%eax),%edx
  10609e:	89 54 24 10          	mov    %edx,0x10(%esp)
  1060a2:	0f b6 00             	movzbl (%eax),%eax
  1060a5:	88 04 24             	mov    %al,(%esp)
    while ((digit = a2d(ch)) >= 0) {
  1060a8:	0f be 04 24          	movsbl (%esp),%eax
  1060ac:	50                   	push   %eax
  1060ad:	e8 56 ff ff ff       	call   106008 <a2d>
  1060b2:	83 c4 04             	add    $0x4,%esp
  1060b5:	89 44 24 08          	mov    %eax,0x8(%esp)
  1060b9:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
  1060be:	79 b8                	jns    106078 <a2u+0x1e>
  1060c0:	eb 01                	jmp    1060c3 <a2u+0x69>
            break;
  1060c2:	90                   	nop
    }
    *src = p;
  1060c3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1060c7:	8b 54 24 10          	mov    0x10(%esp),%edx
  1060cb:	89 10                	mov    %edx,(%eax)
    *nump = num;
  1060cd:	8b 44 24 24          	mov    0x24(%esp),%eax
  1060d1:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1060d5:	89 10                	mov    %edx,(%eax)
    return ch;
  1060d7:	0f b6 04 24          	movzbl (%esp),%eax
}
  1060db:	83 c4 14             	add    $0x14,%esp
  1060de:	c3                   	ret    

001060df <putchw>:

static void putchw(void *putp, putcf putf, struct param *p)
{
  1060df:	83 ec 1c             	sub    $0x1c,%esp
    char ch;
    int n = p->width;
  1060e2:	8b 44 24 28          	mov    0x28(%esp),%eax
  1060e6:	8b 40 04             	mov    0x4(%eax),%eax
  1060e9:	89 44 24 0c          	mov    %eax,0xc(%esp)
    char *bf = p->bf;
  1060ed:	8b 44 24 28          	mov    0x28(%esp),%eax
  1060f1:	8b 40 14             	mov    0x14(%eax),%eax
  1060f4:	89 44 24 08          	mov    %eax,0x8(%esp)

    /* Number of filling characters */
    while (*bf++ && n > 0)
  1060f8:	eb 05                	jmp    1060ff <putchw+0x20>
        n--;
  1060fa:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)
    while (*bf++ && n > 0)
  1060ff:	8b 44 24 08          	mov    0x8(%esp),%eax
  106103:	8d 50 01             	lea    0x1(%eax),%edx
  106106:	89 54 24 08          	mov    %edx,0x8(%esp)
  10610a:	0f b6 00             	movzbl (%eax),%eax
  10610d:	84 c0                	test   %al,%al
  10610f:	74 07                	je     106118 <putchw+0x39>
  106111:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
  106116:	7f e2                	jg     1060fa <putchw+0x1b>
    if (p->sign)
  106118:	8b 44 24 28          	mov    0x28(%esp),%eax
  10611c:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  106120:	84 c0                	test   %al,%al
  106122:	74 05                	je     106129 <putchw+0x4a>
        n--;
  106124:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)
    if (p->alt && p->base == 16)
  106129:	8b 44 24 28          	mov    0x28(%esp),%eax
  10612d:	0f b6 00             	movzbl (%eax),%eax
  106130:	83 e0 02             	and    $0x2,%eax
  106133:	84 c0                	test   %al,%al
  106135:	74 13                	je     10614a <putchw+0x6b>
  106137:	8b 44 24 28          	mov    0x28(%esp),%eax
  10613b:	8b 40 10             	mov    0x10(%eax),%eax
  10613e:	83 f8 10             	cmp    $0x10,%eax
  106141:	75 07                	jne    10614a <putchw+0x6b>
        n -= 2;
  106143:	83 6c 24 0c 02       	subl   $0x2,0xc(%esp)
  106148:	eb 1f                	jmp    106169 <putchw+0x8a>
    else if (p->alt && p->base == 8)
  10614a:	8b 44 24 28          	mov    0x28(%esp),%eax
  10614e:	0f b6 00             	movzbl (%eax),%eax
  106151:	83 e0 02             	and    $0x2,%eax
  106154:	84 c0                	test   %al,%al
  106156:	74 11                	je     106169 <putchw+0x8a>
  106158:	8b 44 24 28          	mov    0x28(%esp),%eax
  10615c:	8b 40 10             	mov    0x10(%eax),%eax
  10615f:	83 f8 08             	cmp    $0x8,%eax
  106162:	75 05                	jne    106169 <putchw+0x8a>
        n--;
  106164:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)

    /* Fill with space to align to the right, before alternate or sign */
    if (!p->lz && !p->align_left) {
  106169:	8b 44 24 28          	mov    0x28(%esp),%eax
  10616d:	0f b6 00             	movzbl (%eax),%eax
  106170:	83 e0 01             	and    $0x1,%eax
  106173:	84 c0                	test   %al,%al
  106175:	75 31                	jne    1061a8 <putchw+0xc9>
  106177:	8b 44 24 28          	mov    0x28(%esp),%eax
  10617b:	0f b6 00             	movzbl (%eax),%eax
  10617e:	83 e0 08             	and    $0x8,%eax
  106181:	84 c0                	test   %al,%al
  106183:	75 23                	jne    1061a8 <putchw+0xc9>
        while (n-- > 0)
  106185:	eb 12                	jmp    106199 <putchw+0xba>
            putf(putp, ' ');
  106187:	83 ec 08             	sub    $0x8,%esp
  10618a:	6a 20                	push   $0x20
  10618c:	ff 74 24 2c          	pushl  0x2c(%esp)
  106190:	8b 44 24 34          	mov    0x34(%esp),%eax
  106194:	ff d0                	call   *%eax
  106196:	83 c4 10             	add    $0x10,%esp
        while (n-- > 0)
  106199:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10619d:	8d 50 ff             	lea    -0x1(%eax),%edx
  1061a0:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1061a4:	85 c0                	test   %eax,%eax
  1061a6:	7f df                	jg     106187 <putchw+0xa8>
    }

    /* print sign */
    if (p->sign)
  1061a8:	8b 44 24 28          	mov    0x28(%esp),%eax
  1061ac:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1061b0:	84 c0                	test   %al,%al
  1061b2:	74 1c                	je     1061d0 <putchw+0xf1>
        putf(putp, p->sign);
  1061b4:	8b 44 24 28          	mov    0x28(%esp),%eax
  1061b8:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  1061bc:	0f be c0             	movsbl %al,%eax
  1061bf:	83 ec 08             	sub    $0x8,%esp
  1061c2:	50                   	push   %eax
  1061c3:	ff 74 24 2c          	pushl  0x2c(%esp)
  1061c7:	8b 44 24 34          	mov    0x34(%esp),%eax
  1061cb:	ff d0                	call   *%eax
  1061cd:	83 c4 10             	add    $0x10,%esp

    /* Alternate */
    if (p->alt && p->base == 16) {
  1061d0:	8b 44 24 28          	mov    0x28(%esp),%eax
  1061d4:	0f b6 00             	movzbl (%eax),%eax
  1061d7:	83 e0 02             	and    $0x2,%eax
  1061da:	84 c0                	test   %al,%al
  1061dc:	74 4b                	je     106229 <putchw+0x14a>
  1061de:	8b 44 24 28          	mov    0x28(%esp),%eax
  1061e2:	8b 40 10             	mov    0x10(%eax),%eax
  1061e5:	83 f8 10             	cmp    $0x10,%eax
  1061e8:	75 3f                	jne    106229 <putchw+0x14a>
        putf(putp, '0');
  1061ea:	83 ec 08             	sub    $0x8,%esp
  1061ed:	6a 30                	push   $0x30
  1061ef:	ff 74 24 2c          	pushl  0x2c(%esp)
  1061f3:	8b 44 24 34          	mov    0x34(%esp),%eax
  1061f7:	ff d0                	call   *%eax
  1061f9:	83 c4 10             	add    $0x10,%esp
        putf(putp, (p->uc ? 'X' : 'x'));
  1061fc:	8b 44 24 28          	mov    0x28(%esp),%eax
  106200:	0f b6 00             	movzbl (%eax),%eax
  106203:	83 e0 04             	and    $0x4,%eax
  106206:	84 c0                	test   %al,%al
  106208:	74 07                	je     106211 <putchw+0x132>
  10620a:	b8 58 00 00 00       	mov    $0x58,%eax
  10620f:	eb 05                	jmp    106216 <putchw+0x137>
  106211:	b8 78 00 00 00       	mov    $0x78,%eax
  106216:	83 ec 08             	sub    $0x8,%esp
  106219:	50                   	push   %eax
  10621a:	ff 74 24 2c          	pushl  0x2c(%esp)
  10621e:	8b 44 24 34          	mov    0x34(%esp),%eax
  106222:	ff d0                	call   *%eax
  106224:	83 c4 10             	add    $0x10,%esp
  106227:	eb 2c                	jmp    106255 <putchw+0x176>
    } else if (p->alt && p->base == 8) {
  106229:	8b 44 24 28          	mov    0x28(%esp),%eax
  10622d:	0f b6 00             	movzbl (%eax),%eax
  106230:	83 e0 02             	and    $0x2,%eax
  106233:	84 c0                	test   %al,%al
  106235:	74 1e                	je     106255 <putchw+0x176>
  106237:	8b 44 24 28          	mov    0x28(%esp),%eax
  10623b:	8b 40 10             	mov    0x10(%eax),%eax
  10623e:	83 f8 08             	cmp    $0x8,%eax
  106241:	75 12                	jne    106255 <putchw+0x176>
        putf(putp, '0');
  106243:	83 ec 08             	sub    $0x8,%esp
  106246:	6a 30                	push   $0x30
  106248:	ff 74 24 2c          	pushl  0x2c(%esp)
  10624c:	8b 44 24 34          	mov    0x34(%esp),%eax
  106250:	ff d0                	call   *%eax
  106252:	83 c4 10             	add    $0x10,%esp
    }

    /* Fill with zeros, after alternate or sign */
    if (p->lz) {
  106255:	8b 44 24 28          	mov    0x28(%esp),%eax
  106259:	0f b6 00             	movzbl (%eax),%eax
  10625c:	83 e0 01             	and    $0x1,%eax
  10625f:	84 c0                	test   %al,%al
  106261:	74 23                	je     106286 <putchw+0x1a7>
        while (n-- > 0)
  106263:	eb 12                	jmp    106277 <putchw+0x198>
            putf(putp, '0');
  106265:	83 ec 08             	sub    $0x8,%esp
  106268:	6a 30                	push   $0x30
  10626a:	ff 74 24 2c          	pushl  0x2c(%esp)
  10626e:	8b 44 24 34          	mov    0x34(%esp),%eax
  106272:	ff d0                	call   *%eax
  106274:	83 c4 10             	add    $0x10,%esp
        while (n-- > 0)
  106277:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10627b:	8d 50 ff             	lea    -0x1(%eax),%edx
  10627e:	89 54 24 0c          	mov    %edx,0xc(%esp)
  106282:	85 c0                	test   %eax,%eax
  106284:	7f df                	jg     106265 <putchw+0x186>
    }

    /* Put actual buffer */
    bf = p->bf;
  106286:	8b 44 24 28          	mov    0x28(%esp),%eax
  10628a:	8b 40 14             	mov    0x14(%eax),%eax
  10628d:	89 44 24 08          	mov    %eax,0x8(%esp)
    while ((ch = *bf++))
  106291:	eb 16                	jmp    1062a9 <putchw+0x1ca>
        putf(putp, ch);
  106293:	0f be 44 24 07       	movsbl 0x7(%esp),%eax
  106298:	83 ec 08             	sub    $0x8,%esp
  10629b:	50                   	push   %eax
  10629c:	ff 74 24 2c          	pushl  0x2c(%esp)
  1062a0:	8b 44 24 34          	mov    0x34(%esp),%eax
  1062a4:	ff d0                	call   *%eax
  1062a6:	83 c4 10             	add    $0x10,%esp
    while ((ch = *bf++))
  1062a9:	8b 44 24 08          	mov    0x8(%esp),%eax
  1062ad:	8d 50 01             	lea    0x1(%eax),%edx
  1062b0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1062b4:	0f b6 00             	movzbl (%eax),%eax
  1062b7:	88 44 24 07          	mov    %al,0x7(%esp)
  1062bb:	80 7c 24 07 00       	cmpb   $0x0,0x7(%esp)
  1062c0:	75 d1                	jne    106293 <putchw+0x1b4>

    /* Fill with space to align to the left, after string */
    if (!p->lz && p->align_left) {
  1062c2:	8b 44 24 28          	mov    0x28(%esp),%eax
  1062c6:	0f b6 00             	movzbl (%eax),%eax
  1062c9:	83 e0 01             	and    $0x1,%eax
  1062cc:	84 c0                	test   %al,%al
  1062ce:	75 31                	jne    106301 <putchw+0x222>
  1062d0:	8b 44 24 28          	mov    0x28(%esp),%eax
  1062d4:	0f b6 00             	movzbl (%eax),%eax
  1062d7:	83 e0 08             	and    $0x8,%eax
  1062da:	84 c0                	test   %al,%al
  1062dc:	74 23                	je     106301 <putchw+0x222>
        while (n-- > 0)
  1062de:	eb 12                	jmp    1062f2 <putchw+0x213>
            putf(putp, ' ');
  1062e0:	83 ec 08             	sub    $0x8,%esp
  1062e3:	6a 20                	push   $0x20
  1062e5:	ff 74 24 2c          	pushl  0x2c(%esp)
  1062e9:	8b 44 24 34          	mov    0x34(%esp),%eax
  1062ed:	ff d0                	call   *%eax
  1062ef:	83 c4 10             	add    $0x10,%esp
        while (n-- > 0)
  1062f2:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1062f6:	8d 50 ff             	lea    -0x1(%eax),%edx
  1062f9:	89 54 24 0c          	mov    %edx,0xc(%esp)
  1062fd:	85 c0                	test   %eax,%eax
  1062ff:	7f df                	jg     1062e0 <putchw+0x201>
    }
}
  106301:	90                   	nop
  106302:	83 c4 1c             	add    $0x1c,%esp
  106305:	c3                   	ret    

00106306 <tfp_format>:

void tfp_format(void *putp, putcf putf, const char *fmt, va_list va)
{
  106306:	53                   	push   %ebx
  106307:	81 ec 88 00 00 00    	sub    $0x88,%esp
    char bf[23];  /* long = 64b on some architectures */
#else
    char bf[12];  /* int = 32b on some architectures */
#endif
    char ch;
    p.bf = bf;
  10630d:	8d 44 24 49          	lea    0x49(%esp),%eax
  106311:	89 44 24 74          	mov    %eax,0x74(%esp)
    p.precision = 6;
  106315:	c7 44 24 68 06 00 00 	movl   $0x6,0x68(%esp)
  10631c:	00 

    while ((ch = *(fmt++))) {
  10631d:	e9 48 05 00 00       	jmp    10686a <tfp_format+0x564>
        if (ch != '%') {
  106322:	80 7c 24 7f 25       	cmpb   $0x25,0x7f(%esp)
  106327:	74 21                	je     10634a <tfp_format+0x44>
            putf(putp, ch);
  106329:	0f be 44 24 7f       	movsbl 0x7f(%esp),%eax
  10632e:	83 ec 08             	sub    $0x8,%esp
  106331:	50                   	push   %eax
  106332:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  106339:	8b 84 24 a4 00 00 00 	mov    0xa4(%esp),%eax
  106340:	ff d0                	call   *%eax
  106342:	83 c4 10             	add    $0x10,%esp
  106345:	e9 20 05 00 00       	jmp    10686a <tfp_format+0x564>
        } else {
#ifdef PRINTF_LONG_SUPPORT
            char lng = 0;  /* 1 for long, 2 for long long */
  10634a:	c6 44 24 7e 00       	movb   $0x0,0x7e(%esp)
#endif
            /* Init parameter struct */
            p.lz = 0;
  10634f:	0f b6 44 24 60       	movzbl 0x60(%esp),%eax
  106354:	83 e0 fe             	and    $0xfffffffe,%eax
  106357:	88 44 24 60          	mov    %al,0x60(%esp)
            p.alt = 0;
  10635b:	0f b6 44 24 60       	movzbl 0x60(%esp),%eax
  106360:	83 e0 fd             	and    $0xfffffffd,%eax
  106363:	88 44 24 60          	mov    %al,0x60(%esp)
            p.width = 0;
  106367:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
  10636e:	00 
            p.align_left = 0;
  10636f:	0f b6 44 24 60       	movzbl 0x60(%esp),%eax
  106374:	83 e0 f7             	and    $0xfffffff7,%eax
  106377:	88 44 24 60          	mov    %al,0x60(%esp)
            p.sign = 0;
  10637b:	c6 44 24 6c 00       	movb   $0x0,0x6c(%esp)

            /* Flags */
            while ((ch = *(fmt++))) {
  106380:	eb 40                	jmp    1063c2 <tfp_format+0xbc>
                switch (ch) {
  106382:	0f be 44 24 7f       	movsbl 0x7f(%esp),%eax
  106387:	83 f8 2d             	cmp    $0x2d,%eax
  10638a:	74 0d                	je     106399 <tfp_format+0x93>
  10638c:	83 f8 30             	cmp    $0x30,%eax
  10638f:	74 16                	je     1063a7 <tfp_format+0xa1>
  106391:	83 f8 23             	cmp    $0x23,%eax
  106394:	74 1f                	je     1063b5 <tfp_format+0xaf>
                    continue;
                case '#':
                    p.alt = 1;
                    continue;
                default:
                    break;
  106396:	90                   	nop
                }
                break;
  106397:	eb 48                	jmp    1063e1 <tfp_format+0xdb>
                    p.align_left = 1;
  106399:	0f b6 44 24 60       	movzbl 0x60(%esp),%eax
  10639e:	83 c8 08             	or     $0x8,%eax
  1063a1:	88 44 24 60          	mov    %al,0x60(%esp)
                    continue;
  1063a5:	eb 1b                	jmp    1063c2 <tfp_format+0xbc>
                    p.lz = 1;
  1063a7:	0f b6 44 24 60       	movzbl 0x60(%esp),%eax
  1063ac:	83 c8 01             	or     $0x1,%eax
  1063af:	88 44 24 60          	mov    %al,0x60(%esp)
                    continue;
  1063b3:	eb 0d                	jmp    1063c2 <tfp_format+0xbc>
                    p.alt = 1;
  1063b5:	0f b6 44 24 60       	movzbl 0x60(%esp),%eax
  1063ba:	83 c8 02             	or     $0x2,%eax
  1063bd:	88 44 24 60          	mov    %al,0x60(%esp)
                    continue;
  1063c1:	90                   	nop
            while ((ch = *(fmt++))) {
  1063c2:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
  1063c9:	8d 50 01             	lea    0x1(%eax),%edx
  1063cc:	89 94 24 98 00 00 00 	mov    %edx,0x98(%esp)
  1063d3:	0f b6 00             	movzbl (%eax),%eax
  1063d6:	88 44 24 7f          	mov    %al,0x7f(%esp)
  1063da:	80 7c 24 7f 00       	cmpb   $0x0,0x7f(%esp)
  1063df:	75 a1                	jne    106382 <tfp_format+0x7c>
            }

            /* Width */
            if (ch >= '0' && ch <= '9') {
  1063e1:	80 7c 24 7f 2f       	cmpb   $0x2f,0x7f(%esp)
  1063e6:	7e 2b                	jle    106413 <tfp_format+0x10d>
  1063e8:	80 7c 24 7f 39       	cmpb   $0x39,0x7f(%esp)
  1063ed:	7f 24                	jg     106413 <tfp_format+0x10d>
                ch = a2u(ch, &fmt, 10, &(p.width));
  1063ef:	0f be 44 24 7f       	movsbl 0x7f(%esp),%eax
  1063f4:	8d 54 24 60          	lea    0x60(%esp),%edx
  1063f8:	83 c2 04             	add    $0x4,%edx
  1063fb:	52                   	push   %edx
  1063fc:	6a 0a                	push   $0xa
  1063fe:	8d 94 24 a0 00 00 00 	lea    0xa0(%esp),%edx
  106405:	52                   	push   %edx
  106406:	50                   	push   %eax
  106407:	e8 4e fc ff ff       	call   10605a <a2u>
  10640c:	83 c4 10             	add    $0x10,%esp
  10640f:	88 44 24 7f          	mov    %al,0x7f(%esp)
            }
            /* We accept 'x.y' format but don't support it completely:
             * we ignore the 'y' digit => this ignores 0-fill
             * size and makes it == width (ie. 'x') */
            if (ch == '.') {
  106413:	80 7c 24 7f 2e       	cmpb   $0x2e,0x7f(%esp)
  106418:	75 62                	jne    10647c <tfp_format+0x176>
                char prec[64];
                size_t idx = 0;
  10641a:	c7 44 24 78 00 00 00 	movl   $0x0,0x78(%esp)
  106421:	00 

                p.lz = 1;  /* zero-padding */
  106422:	0f b6 44 24 60       	movzbl 0x60(%esp),%eax
  106427:	83 c8 01             	or     $0x1,%eax
  10642a:	88 44 24 60          	mov    %al,0x60(%esp)
                /* ignore actual 0-fill size: */
                do {
                    ch = *(fmt++);
  10642e:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
  106435:	8d 50 01             	lea    0x1(%eax),%edx
  106438:	89 94 24 98 00 00 00 	mov    %edx,0x98(%esp)
  10643f:	0f b6 00             	movzbl (%eax),%eax
  106442:	88 44 24 7f          	mov    %al,0x7f(%esp)
                    prec[idx++] = ch;
  106446:	8b 44 24 78          	mov    0x78(%esp),%eax
  10644a:	8d 50 01             	lea    0x1(%eax),%edx
  10644d:	89 54 24 78          	mov    %edx,0x78(%esp)
  106451:	0f b6 54 24 7f       	movzbl 0x7f(%esp),%edx
  106456:	88 54 04 09          	mov    %dl,0x9(%esp,%eax,1)
                } while ((ch >= '0') && (ch <= '9'));
  10645a:	80 7c 24 7f 2f       	cmpb   $0x2f,0x7f(%esp)
  10645f:	7e 07                	jle    106468 <tfp_format+0x162>
  106461:	80 7c 24 7f 39       	cmpb   $0x39,0x7f(%esp)
  106466:	7e c6                	jle    10642e <tfp_format+0x128>
                p.precision = atoi(prec);
  106468:	83 ec 0c             	sub    $0xc,%esp
  10646b:	8d 44 24 15          	lea    0x15(%esp),%eax
  10646f:	50                   	push   %eax
  106470:	e8 20 06 00 00       	call   106a95 <atoi>
  106475:	83 c4 10             	add    $0x10,%esp
  106478:	89 44 24 68          	mov    %eax,0x68(%esp)
            }

#ifdef PRINTF_SIZE_T_SUPPORT
# ifdef PRINTF_LONG_SUPPORT
            if (ch == 'z') {
  10647c:	80 7c 24 7f 7a       	cmpb   $0x7a,0x7f(%esp)
  106481:	75 1f                	jne    1064a2 <tfp_format+0x19c>
                ch = *(fmt++);
  106483:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
  10648a:	8d 50 01             	lea    0x1(%eax),%edx
  10648d:	89 94 24 98 00 00 00 	mov    %edx,0x98(%esp)
  106494:	0f b6 00             	movzbl (%eax),%eax
  106497:	88 44 24 7f          	mov    %al,0x7f(%esp)
                if (sizeof(size_t) == sizeof(unsigned long int))
                    lng = 1;
  10649b:	c6 44 24 7e 01       	movb   $0x1,0x7e(%esp)
  1064a0:	eb 48                	jmp    1064ea <tfp_format+0x1e4>
            } else
# endif
#endif

#ifdef PRINTF_LONG_SUPPORT
                if (ch == 'l') {
  1064a2:	80 7c 24 7f 6c       	cmpb   $0x6c,0x7f(%esp)
  1064a7:	75 41                	jne    1064ea <tfp_format+0x1e4>
                    ch = *(fmt++);
  1064a9:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
  1064b0:	8d 50 01             	lea    0x1(%eax),%edx
  1064b3:	89 94 24 98 00 00 00 	mov    %edx,0x98(%esp)
  1064ba:	0f b6 00             	movzbl (%eax),%eax
  1064bd:	88 44 24 7f          	mov    %al,0x7f(%esp)
                    lng = 1;
  1064c1:	c6 44 24 7e 01       	movb   $0x1,0x7e(%esp)
#ifdef PRINTF_LONG_LONG_SUPPORT
                    if (ch == 'l') {
  1064c6:	80 7c 24 7f 6c       	cmpb   $0x6c,0x7f(%esp)
  1064cb:	75 1d                	jne    1064ea <tfp_format+0x1e4>
                        ch = *(fmt++);
  1064cd:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
  1064d4:	8d 50 01             	lea    0x1(%eax),%edx
  1064d7:	89 94 24 98 00 00 00 	mov    %edx,0x98(%esp)
  1064de:	0f b6 00             	movzbl (%eax),%eax
  1064e1:	88 44 24 7f          	mov    %al,0x7f(%esp)
                        lng = 2;
  1064e5:	c6 44 24 7e 02       	movb   $0x2,0x7e(%esp)
                    }
#endif
                }
#endif
            switch (ch) {
  1064ea:	0f be 44 24 7f       	movsbl 0x7f(%esp),%eax
  1064ef:	83 f8 78             	cmp    $0x78,%eax
  1064f2:	0f 87 71 03 00 00    	ja     106869 <tfp_format+0x563>
  1064f8:	8b 04 85 34 a9 10 00 	mov    0x10a934(,%eax,4),%eax
  1064ff:	ff e0                	jmp    *%eax
            case 0:
                goto abort;
            case 'u':
                p.base = 10;
  106501:	c7 44 24 70 0a 00 00 	movl   $0xa,0x70(%esp)
  106508:	00 
#ifdef PRINTF_LONG_SUPPORT
#ifdef PRINTF_LONG_LONG_SUPPORT
                if (2 == lng)
  106509:	80 7c 24 7e 02       	cmpb   $0x2,0x7e(%esp)
  10650e:	75 2a                	jne    10653a <tfp_format+0x234>
                    ulli2a(va_arg(va, unsigned long long int), &p);
  106510:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  106517:	8d 50 08             	lea    0x8(%eax),%edx
  10651a:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  106521:	8b 50 04             	mov    0x4(%eax),%edx
  106524:	8b 00                	mov    (%eax),%eax
  106526:	83 ec 04             	sub    $0x4,%esp
  106529:	8d 4c 24 64          	lea    0x64(%esp),%ecx
  10652d:	51                   	push   %ecx
  10652e:	52                   	push   %edx
  10652f:	50                   	push   %eax
  106530:	e8 9e f6 ff ff       	call   105bd3 <ulli2a>
  106535:	83 c4 10             	add    $0x10,%esp
  106538:	eb 51                	jmp    10658b <tfp_format+0x285>
                else
#endif
                    if (1 == lng)
  10653a:	80 7c 24 7e 01       	cmpb   $0x1,0x7e(%esp)
  10653f:	75 26                	jne    106567 <tfp_format+0x261>
                        uli2a(va_arg(va, unsigned long int), &p);
  106541:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  106548:	8d 50 04             	lea    0x4(%eax),%edx
  10654b:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  106552:	8b 00                	mov    (%eax),%eax
  106554:	83 ec 08             	sub    $0x8,%esp
  106557:	8d 54 24 68          	lea    0x68(%esp),%edx
  10655b:	52                   	push   %edx
  10655c:	50                   	push   %eax
  10655d:	e8 72 f8 ff ff       	call   105dd4 <uli2a>
  106562:	83 c4 10             	add    $0x10,%esp
  106565:	eb 24                	jmp    10658b <tfp_format+0x285>
                    else
#endif
                        ui2a(va_arg(va, unsigned int), &p);
  106567:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  10656e:	8d 50 04             	lea    0x4(%eax),%edx
  106571:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  106578:	8b 00                	mov    (%eax),%eax
  10657a:	83 ec 08             	sub    $0x8,%esp
  10657d:	8d 54 24 68          	lea    0x68(%esp),%edx
  106581:	52                   	push   %edx
  106582:	50                   	push   %eax
  106583:	e8 66 f9 ff ff       	call   105eee <ui2a>
  106588:	83 c4 10             	add    $0x10,%esp
                putchw(putp, putf, &p);
  10658b:	83 ec 04             	sub    $0x4,%esp
  10658e:	8d 44 24 64          	lea    0x64(%esp),%eax
  106592:	50                   	push   %eax
  106593:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  10659a:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  1065a1:	e8 39 fb ff ff       	call   1060df <putchw>
  1065a6:	83 c4 10             	add    $0x10,%esp
                break;
  1065a9:	e9 bc 02 00 00       	jmp    10686a <tfp_format+0x564>
            case 'd':
            case 'i':
                p.base = 10;
  1065ae:	c7 44 24 70 0a 00 00 	movl   $0xa,0x70(%esp)
  1065b5:	00 
#ifdef PRINTF_LONG_SUPPORT
#ifdef PRINTF_LONG_LONG_SUPPORT
                if (2 == lng)
  1065b6:	80 7c 24 7e 02       	cmpb   $0x2,0x7e(%esp)
  1065bb:	75 2a                	jne    1065e7 <tfp_format+0x2e1>
                    lli2a(va_arg(va, long long int), &p);
  1065bd:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  1065c4:	8d 50 08             	lea    0x8(%eax),%edx
  1065c7:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  1065ce:	8b 50 04             	mov    0x4(%eax),%edx
  1065d1:	8b 00                	mov    (%eax),%eax
  1065d3:	83 ec 04             	sub    $0x4,%esp
  1065d6:	8d 4c 24 64          	lea    0x64(%esp),%ecx
  1065da:	51                   	push   %ecx
  1065db:	52                   	push   %edx
  1065dc:	50                   	push   %eax
  1065dd:	e8 a5 f7 ff ff       	call   105d87 <lli2a>
  1065e2:	83 c4 10             	add    $0x10,%esp
  1065e5:	eb 51                	jmp    106638 <tfp_format+0x332>
                else
#endif
                    if (1 == lng)
  1065e7:	80 7c 24 7e 01       	cmpb   $0x1,0x7e(%esp)
  1065ec:	75 26                	jne    106614 <tfp_format+0x30e>
                        li2a(va_arg(va, long int), &p);
  1065ee:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  1065f5:	8d 50 04             	lea    0x4(%eax),%edx
  1065f8:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  1065ff:	8b 00                	mov    (%eax),%eax
  106601:	83 ec 08             	sub    $0x8,%esp
  106604:	8d 54 24 68          	lea    0x68(%esp),%edx
  106608:	52                   	push   %edx
  106609:	50                   	push   %eax
  10660a:	e8 b9 f8 ff ff       	call   105ec8 <li2a>
  10660f:	83 c4 10             	add    $0x10,%esp
  106612:	eb 24                	jmp    106638 <tfp_format+0x332>
                    else
#endif
                        i2a(va_arg(va, int), &p);
  106614:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  10661b:	8d 50 04             	lea    0x4(%eax),%edx
  10661e:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  106625:	8b 00                	mov    (%eax),%eax
  106627:	83 ec 08             	sub    $0x8,%esp
  10662a:	8d 54 24 68          	lea    0x68(%esp),%edx
  10662e:	52                   	push   %edx
  10662f:	50                   	push   %eax
  106630:	e8 ad f9 ff ff       	call   105fe2 <i2a>
  106635:	83 c4 10             	add    $0x10,%esp
                putchw(putp, putf, &p);
  106638:	83 ec 04             	sub    $0x4,%esp
  10663b:	8d 44 24 64          	lea    0x64(%esp),%eax
  10663f:	50                   	push   %eax
  106640:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  106647:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  10664e:	e8 8c fa ff ff       	call   1060df <putchw>
  106653:	83 c4 10             	add    $0x10,%esp
                break;
  106656:	e9 0f 02 00 00       	jmp    10686a <tfp_format+0x564>
#ifdef SIZEOF_POINTER
            case 'p':
                p.alt = 1;
  10665b:	0f b6 44 24 60       	movzbl 0x60(%esp),%eax
  106660:	83 c8 02             	or     $0x2,%eax
  106663:	88 44 24 60          	mov    %al,0x60(%esp)
# if defined(SIZEOF_INT) && SIZEOF_POINTER <= SIZEOF_INT
                lng = 0;
  106667:	c6 44 24 7e 00       	movb   $0x0,0x7e(%esp)
                lng = 2;
# endif
#endif
            case 'x':
            case 'X':
                p.base = 16;
  10666c:	c7 44 24 70 10 00 00 	movl   $0x10,0x70(%esp)
  106673:	00 
                p.uc = (ch == 'X')?1:0;
  106674:	80 7c 24 7f 58       	cmpb   $0x58,0x7f(%esp)
  106679:	0f 94 c0             	sete   %al
  10667c:	c1 e0 07             	shl    $0x7,%eax
  10667f:	c0 f8 07             	sar    $0x7,%al
  106682:	83 e0 01             	and    $0x1,%eax
  106685:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  10668c:	0f b6 44 24 60       	movzbl 0x60(%esp),%eax
  106691:	83 e0 fb             	and    $0xfffffffb,%eax
  106694:	09 d0                	or     %edx,%eax
  106696:	88 44 24 60          	mov    %al,0x60(%esp)
#ifdef PRINTF_LONG_SUPPORT
#ifdef PRINTF_LONG_LONG_SUPPORT
                if (2 == lng)
  10669a:	80 7c 24 7e 02       	cmpb   $0x2,0x7e(%esp)
  10669f:	75 2a                	jne    1066cb <tfp_format+0x3c5>
                    ulli2a(va_arg(va, unsigned long long int), &p);
  1066a1:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  1066a8:	8d 50 08             	lea    0x8(%eax),%edx
  1066ab:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  1066b2:	8b 50 04             	mov    0x4(%eax),%edx
  1066b5:	8b 00                	mov    (%eax),%eax
  1066b7:	83 ec 04             	sub    $0x4,%esp
  1066ba:	8d 4c 24 64          	lea    0x64(%esp),%ecx
  1066be:	51                   	push   %ecx
  1066bf:	52                   	push   %edx
  1066c0:	50                   	push   %eax
  1066c1:	e8 0d f5 ff ff       	call   105bd3 <ulli2a>
  1066c6:	83 c4 10             	add    $0x10,%esp
  1066c9:	eb 51                	jmp    10671c <tfp_format+0x416>
                else
#endif
                    if (1 == lng)
  1066cb:	80 7c 24 7e 01       	cmpb   $0x1,0x7e(%esp)
  1066d0:	75 26                	jne    1066f8 <tfp_format+0x3f2>
                        uli2a(va_arg(va, unsigned long int), &p);
  1066d2:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  1066d9:	8d 50 04             	lea    0x4(%eax),%edx
  1066dc:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  1066e3:	8b 00                	mov    (%eax),%eax
  1066e5:	83 ec 08             	sub    $0x8,%esp
  1066e8:	8d 54 24 68          	lea    0x68(%esp),%edx
  1066ec:	52                   	push   %edx
  1066ed:	50                   	push   %eax
  1066ee:	e8 e1 f6 ff ff       	call   105dd4 <uli2a>
  1066f3:	83 c4 10             	add    $0x10,%esp
  1066f6:	eb 24                	jmp    10671c <tfp_format+0x416>
                    else
#endif
                        ui2a(va_arg(va, unsigned int), &p);
  1066f8:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  1066ff:	8d 50 04             	lea    0x4(%eax),%edx
  106702:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  106709:	8b 00                	mov    (%eax),%eax
  10670b:	83 ec 08             	sub    $0x8,%esp
  10670e:	8d 54 24 68          	lea    0x68(%esp),%edx
  106712:	52                   	push   %edx
  106713:	50                   	push   %eax
  106714:	e8 d5 f7 ff ff       	call   105eee <ui2a>
  106719:	83 c4 10             	add    $0x10,%esp
                putchw(putp, putf, &p);
  10671c:	83 ec 04             	sub    $0x4,%esp
  10671f:	8d 44 24 64          	lea    0x64(%esp),%eax
  106723:	50                   	push   %eax
  106724:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  10672b:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  106732:	e8 a8 f9 ff ff       	call   1060df <putchw>
  106737:	83 c4 10             	add    $0x10,%esp
                break;
  10673a:	e9 2b 01 00 00       	jmp    10686a <tfp_format+0x564>
            case 'f':
            case 'F':
                ftoa(va_arg(va, double), p.bf, p.precision);
  10673f:	8b 44 24 68          	mov    0x68(%esp),%eax
  106743:	89 c3                	mov    %eax,%ebx
  106745:	8b 54 24 74          	mov    0x74(%esp),%edx
  106749:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  106750:	8d 48 08             	lea    0x8(%eax),%ecx
  106753:	89 8c 24 9c 00 00 00 	mov    %ecx,0x9c(%esp)
  10675a:	dd 00                	fldl   (%eax)
  10675c:	53                   	push   %ebx
  10675d:	52                   	push   %edx
  10675e:	8d 64 24 f8          	lea    -0x8(%esp),%esp
  106762:	dd 1c 24             	fstpl  (%esp)
  106765:	e8 fe 03 00 00       	call   106b68 <ftoa>
  10676a:	83 c4 10             	add    $0x10,%esp
                putchw(putp, putf, &p);
  10676d:	83 ec 04             	sub    $0x4,%esp
  106770:	8d 44 24 64          	lea    0x64(%esp),%eax
  106774:	50                   	push   %eax
  106775:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  10677c:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  106783:	e8 57 f9 ff ff       	call   1060df <putchw>
  106788:	83 c4 10             	add    $0x10,%esp
                break;
  10678b:	e9 da 00 00 00       	jmp    10686a <tfp_format+0x564>
            case 'o':
                p.base = 8;
  106790:	c7 44 24 70 08 00 00 	movl   $0x8,0x70(%esp)
  106797:	00 
                ui2a(va_arg(va, unsigned int), &p);
  106798:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  10679f:	8d 50 04             	lea    0x4(%eax),%edx
  1067a2:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  1067a9:	8b 00                	mov    (%eax),%eax
  1067ab:	83 ec 08             	sub    $0x8,%esp
  1067ae:	8d 54 24 68          	lea    0x68(%esp),%edx
  1067b2:	52                   	push   %edx
  1067b3:	50                   	push   %eax
  1067b4:	e8 35 f7 ff ff       	call   105eee <ui2a>
  1067b9:	83 c4 10             	add    $0x10,%esp
                putchw(putp, putf, &p);
  1067bc:	83 ec 04             	sub    $0x4,%esp
  1067bf:	8d 44 24 64          	lea    0x64(%esp),%eax
  1067c3:	50                   	push   %eax
  1067c4:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  1067cb:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  1067d2:	e8 08 f9 ff ff       	call   1060df <putchw>
  1067d7:	83 c4 10             	add    $0x10,%esp
                break;
  1067da:	e9 8b 00 00 00       	jmp    10686a <tfp_format+0x564>
            case 'c':
                putf(putp, (char)(va_arg(va, int)));
  1067df:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  1067e6:	8d 50 04             	lea    0x4(%eax),%edx
  1067e9:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  1067f0:	8b 00                	mov    (%eax),%eax
  1067f2:	0f be c0             	movsbl %al,%eax
  1067f5:	83 ec 08             	sub    $0x8,%esp
  1067f8:	50                   	push   %eax
  1067f9:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  106800:	8b 84 24 a4 00 00 00 	mov    0xa4(%esp),%eax
  106807:	ff d0                	call   *%eax
  106809:	83 c4 10             	add    $0x10,%esp
                break;
  10680c:	eb 5c                	jmp    10686a <tfp_format+0x564>
            case 's':
                p.bf = va_arg(va, char *);
  10680e:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
  106815:	8d 50 04             	lea    0x4(%eax),%edx
  106818:	89 94 24 9c 00 00 00 	mov    %edx,0x9c(%esp)
  10681f:	8b 00                	mov    (%eax),%eax
  106821:	89 44 24 74          	mov    %eax,0x74(%esp)
                putchw(putp, putf, &p);
  106825:	83 ec 04             	sub    $0x4,%esp
  106828:	8d 44 24 64          	lea    0x64(%esp),%eax
  10682c:	50                   	push   %eax
  10682d:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  106834:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  10683b:	e8 9f f8 ff ff       	call   1060df <putchw>
  106840:	83 c4 10             	add    $0x10,%esp
                p.bf = bf;
  106843:	8d 44 24 49          	lea    0x49(%esp),%eax
  106847:	89 44 24 74          	mov    %eax,0x74(%esp)
                break;
  10684b:	eb 1d                	jmp    10686a <tfp_format+0x564>
            case '%':
                putf(putp, ch);
  10684d:	0f be 44 24 7f       	movsbl 0x7f(%esp),%eax
  106852:	83 ec 08             	sub    $0x8,%esp
  106855:	50                   	push   %eax
  106856:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
  10685d:	8b 84 24 a4 00 00 00 	mov    0xa4(%esp),%eax
  106864:	ff d0                	call   *%eax
  106866:	83 c4 10             	add    $0x10,%esp
            default:
                break;
  106869:	90                   	nop
    while ((ch = *(fmt++))) {
  10686a:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
  106871:	8d 50 01             	lea    0x1(%eax),%edx
  106874:	89 94 24 98 00 00 00 	mov    %edx,0x98(%esp)
  10687b:	0f b6 00             	movzbl (%eax),%eax
  10687e:	88 44 24 7f          	mov    %al,0x7f(%esp)
  106882:	80 7c 24 7f 00       	cmpb   $0x0,0x7f(%esp)
  106887:	0f 85 95 fa ff ff    	jne    106322 <tfp_format+0x1c>
            }
        }
    }
abort:;
  10688d:	eb 01                	jmp    106890 <tfp_format+0x58a>
                goto abort;
  10688f:	90                   	nop
}
  106890:	90                   	nop
  106891:	81 c4 88 00 00 00    	add    $0x88,%esp
  106897:	5b                   	pop    %ebx
  106898:	c3                   	ret    

00106899 <init_printf>:
static putcf stdout_putf;
static void *stdout_putp;

void init_printf(void *putp, putcf putf)
{
    stdout_putf = putf;
  106899:	8b 44 24 08          	mov    0x8(%esp),%eax
  10689d:	a3 58 53 11 00       	mov    %eax,0x115358
    stdout_putp = putp;
  1068a2:	8b 44 24 04          	mov    0x4(%esp),%eax
  1068a6:	a3 5c 53 11 00       	mov    %eax,0x11535c
}
  1068ab:	90                   	nop
  1068ac:	c3                   	ret    

001068ad <tfp_vprintf>:

void tfp_vprintf(const char * __restrict fmt, va_list va)
{
  1068ad:	83 ec 0c             	sub    $0xc,%esp
    tfp_format(stdout_putp, stdout_putf, fmt, va);
  1068b0:	8b 15 58 53 11 00    	mov    0x115358,%edx
  1068b6:	a1 5c 53 11 00       	mov    0x11535c,%eax
  1068bb:	ff 74 24 14          	pushl  0x14(%esp)
  1068bf:	ff 74 24 14          	pushl  0x14(%esp)
  1068c3:	52                   	push   %edx
  1068c4:	50                   	push   %eax
  1068c5:	e8 3c fa ff ff       	call   106306 <tfp_format>
  1068ca:	83 c4 10             	add    $0x10,%esp
}
  1068cd:	90                   	nop
  1068ce:	83 c4 0c             	add    $0xc,%esp
  1068d1:	c3                   	ret    

001068d2 <tfp_printf>:

void tfp_printf(const char * __restrict fmt, ...)
{
  1068d2:	83 ec 1c             	sub    $0x1c,%esp
    va_list va;
    va_start(va, fmt);
  1068d5:	8d 44 24 24          	lea    0x24(%esp),%eax
  1068d9:	89 44 24 0c          	mov    %eax,0xc(%esp)
    tfp_vprintf(fmt, va);
  1068dd:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1068e1:	83 ec 08             	sub    $0x8,%esp
  1068e4:	50                   	push   %eax
  1068e5:	ff 74 24 2c          	pushl  0x2c(%esp)
  1068e9:	e8 bf ff ff ff       	call   1068ad <tfp_vprintf>
  1068ee:	83 c4 10             	add    $0x10,%esp
    va_end(va);
}
  1068f1:	90                   	nop
  1068f2:	83 c4 1c             	add    $0x1c,%esp
  1068f5:	c3                   	ret    

001068f6 <_vsnprintf_putcf>:
    char *dest;
    size_t num_chars;
};

static void _vsnprintf_putcf(void *p, char c)
{
  1068f6:	83 ec 14             	sub    $0x14,%esp
  1068f9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1068fd:	88 04 24             	mov    %al,(%esp)
    struct _vsnprintf_putcf_data *data = (struct _vsnprintf_putcf_data*)p;
  106900:	8b 44 24 18          	mov    0x18(%esp),%eax
  106904:	89 44 24 10          	mov    %eax,0x10(%esp)
    if (data->num_chars < data->dest_capacity)
  106908:	8b 44 24 10          	mov    0x10(%esp),%eax
  10690c:	8b 50 08             	mov    0x8(%eax),%edx
  10690f:	8b 44 24 10          	mov    0x10(%esp),%eax
  106913:	8b 00                	mov    (%eax),%eax
  106915:	39 c2                	cmp    %eax,%edx
  106917:	73 16                	jae    10692f <_vsnprintf_putcf+0x39>
        data->dest[data->num_chars] = c;
  106919:	8b 44 24 10          	mov    0x10(%esp),%eax
  10691d:	8b 50 04             	mov    0x4(%eax),%edx
  106920:	8b 44 24 10          	mov    0x10(%esp),%eax
  106924:	8b 40 08             	mov    0x8(%eax),%eax
  106927:	01 c2                	add    %eax,%edx
  106929:	0f b6 04 24          	movzbl (%esp),%eax
  10692d:	88 02                	mov    %al,(%edx)
    data->num_chars ++;
  10692f:	8b 44 24 10          	mov    0x10(%esp),%eax
  106933:	8b 40 08             	mov    0x8(%eax),%eax
  106936:	8d 50 01             	lea    0x1(%eax),%edx
  106939:	8b 44 24 10          	mov    0x10(%esp),%eax
  10693d:	89 50 08             	mov    %edx,0x8(%eax)
}
  106940:	90                   	nop
  106941:	83 c4 14             	add    $0x14,%esp
  106944:	c3                   	ret    

00106945 <tfp_vsnprintf>:

int tfp_vsnprintf(char *str, size_t size, const char *format, va_list ap)
{
  106945:	83 ec 1c             	sub    $0x1c,%esp
    struct _vsnprintf_putcf_data data;

    if (size < 1)
  106948:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  10694d:	75 07                	jne    106956 <tfp_vsnprintf+0x11>
        return 0;
  10694f:	b8 00 00 00 00       	mov    $0x0,%eax
  106954:	eb 61                	jmp    1069b7 <tfp_vsnprintf+0x72>

    data.dest = str;
  106956:	8b 44 24 20          	mov    0x20(%esp),%eax
  10695a:	89 44 24 08          	mov    %eax,0x8(%esp)
    data.dest_capacity = size-1;
  10695e:	8b 44 24 24          	mov    0x24(%esp),%eax
  106962:	83 e8 01             	sub    $0x1,%eax
  106965:	89 44 24 04          	mov    %eax,0x4(%esp)
    data.num_chars = 0;
  106969:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106970:	00 
    tfp_format(&data, _vsnprintf_putcf, format, ap);
  106971:	ff 74 24 2c          	pushl  0x2c(%esp)
  106975:	ff 74 24 2c          	pushl  0x2c(%esp)
  106979:	68 f6 68 10 00       	push   $0x1068f6
  10697e:	8d 44 24 10          	lea    0x10(%esp),%eax
  106982:	50                   	push   %eax
  106983:	e8 7e f9 ff ff       	call   106306 <tfp_format>
  106988:	83 c4 10             	add    $0x10,%esp

    if (data.num_chars < data.dest_capacity)
  10698b:	8b 54 24 0c          	mov    0xc(%esp),%edx
  10698f:	8b 44 24 04          	mov    0x4(%esp),%eax
  106993:	39 c2                	cmp    %eax,%edx
  106995:	73 0f                	jae    1069a6 <tfp_vsnprintf+0x61>
        data.dest[data.num_chars] = '\0';
  106997:	8b 54 24 08          	mov    0x8(%esp),%edx
  10699b:	8b 44 24 0c          	mov    0xc(%esp),%eax
  10699f:	01 d0                	add    %edx,%eax
  1069a1:	c6 00 00             	movb   $0x0,(%eax)
  1069a4:	eb 0d                	jmp    1069b3 <tfp_vsnprintf+0x6e>
    else
        data.dest[data.dest_capacity] = '\0';
  1069a6:	8b 54 24 08          	mov    0x8(%esp),%edx
  1069aa:	8b 44 24 04          	mov    0x4(%esp),%eax
  1069ae:	01 d0                	add    %edx,%eax
  1069b0:	c6 00 00             	movb   $0x0,(%eax)

    return data.num_chars;
  1069b3:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  1069b7:	83 c4 1c             	add    $0x1c,%esp
  1069ba:	c3                   	ret    

001069bb <tfp_snprintf>:

int tfp_snprintf(char *str, size_t size, const char *format, ...)
{
  1069bb:	83 ec 1c             	sub    $0x1c,%esp
    va_list ap;
    int retval;

    va_start(ap, format);
  1069be:	8d 44 24 2c          	lea    0x2c(%esp),%eax
  1069c2:	89 44 24 08          	mov    %eax,0x8(%esp)
    retval = tfp_vsnprintf(str, size, format, ap);
  1069c6:	8b 44 24 08          	mov    0x8(%esp),%eax
  1069ca:	50                   	push   %eax
  1069cb:	ff 74 24 2c          	pushl  0x2c(%esp)
  1069cf:	ff 74 24 2c          	pushl  0x2c(%esp)
  1069d3:	ff 74 24 2c          	pushl  0x2c(%esp)
  1069d7:	e8 69 ff ff ff       	call   106945 <tfp_vsnprintf>
  1069dc:	83 c4 10             	add    $0x10,%esp
  1069df:	89 44 24 0c          	mov    %eax,0xc(%esp)
    va_end(ap);
    return retval;
  1069e3:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  1069e7:	83 c4 1c             	add    $0x1c,%esp
  1069ea:	c3                   	ret    

001069eb <_vsprintf_putcf>:
    char *dest;
    size_t num_chars;
};

static void _vsprintf_putcf(void *p, char c)
{
  1069eb:	53                   	push   %ebx
  1069ec:	83 ec 14             	sub    $0x14,%esp
  1069ef:	8b 44 24 20          	mov    0x20(%esp),%eax
  1069f3:	88 04 24             	mov    %al,(%esp)
    struct _vsprintf_putcf_data *data = (struct _vsprintf_putcf_data*)p;
  1069f6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1069fa:	89 44 24 10          	mov    %eax,0x10(%esp)
    data->dest[data->num_chars++] = c;
  1069fe:	8b 44 24 10          	mov    0x10(%esp),%eax
  106a02:	8b 18                	mov    (%eax),%ebx
  106a04:	8b 44 24 10          	mov    0x10(%esp),%eax
  106a08:	8b 40 04             	mov    0x4(%eax),%eax
  106a0b:	8d 48 01             	lea    0x1(%eax),%ecx
  106a0e:	8b 54 24 10          	mov    0x10(%esp),%edx
  106a12:	89 4a 04             	mov    %ecx,0x4(%edx)
  106a15:	8d 14 03             	lea    (%ebx,%eax,1),%edx
  106a18:	0f b6 04 24          	movzbl (%esp),%eax
  106a1c:	88 02                	mov    %al,(%edx)
}
  106a1e:	90                   	nop
  106a1f:	83 c4 14             	add    $0x14,%esp
  106a22:	5b                   	pop    %ebx
  106a23:	c3                   	ret    

00106a24 <tfp_vsprintf>:

int tfp_vsprintf(char *str, const char *format, va_list ap)
{
  106a24:	83 ec 1c             	sub    $0x1c,%esp
    struct _vsprintf_putcf_data data;
    data.dest = str;
  106a27:	8b 44 24 20          	mov    0x20(%esp),%eax
  106a2b:	89 44 24 08          	mov    %eax,0x8(%esp)
    data.num_chars = 0;
  106a2f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106a36:	00 
    tfp_format(&data, _vsprintf_putcf, format, ap);
  106a37:	ff 74 24 28          	pushl  0x28(%esp)
  106a3b:	ff 74 24 28          	pushl  0x28(%esp)
  106a3f:	68 eb 69 10 00       	push   $0x1069eb
  106a44:	8d 44 24 14          	lea    0x14(%esp),%eax
  106a48:	50                   	push   %eax
  106a49:	e8 b8 f8 ff ff       	call   106306 <tfp_format>
  106a4e:	83 c4 10             	add    $0x10,%esp
    data.dest[data.num_chars] = '\0';
  106a51:	8b 54 24 08          	mov    0x8(%esp),%edx
  106a55:	8b 44 24 0c          	mov    0xc(%esp),%eax
  106a59:	01 d0                	add    %edx,%eax
  106a5b:	c6 00 00             	movb   $0x0,(%eax)
    return data.num_chars;
  106a5e:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  106a62:	83 c4 1c             	add    $0x1c,%esp
  106a65:	c3                   	ret    

00106a66 <tfp_sprintf>:

int tfp_sprintf(char *str, const char *format, ...)
{
  106a66:	83 ec 1c             	sub    $0x1c,%esp
    va_list ap;
    int retval;

    va_start(ap, format);
  106a69:	8d 44 24 28          	lea    0x28(%esp),%eax
  106a6d:	89 44 24 08          	mov    %eax,0x8(%esp)
    retval = tfp_vsprintf(str, format, ap);
  106a71:	8b 44 24 08          	mov    0x8(%esp),%eax
  106a75:	83 ec 04             	sub    $0x4,%esp
  106a78:	50                   	push   %eax
  106a79:	ff 74 24 2c          	pushl  0x2c(%esp)
  106a7d:	ff 74 24 2c          	pushl  0x2c(%esp)
  106a81:	e8 9e ff ff ff       	call   106a24 <tfp_vsprintf>
  106a86:	83 c4 10             	add    $0x10,%esp
  106a89:	89 44 24 0c          	mov    %eax,0xc(%esp)
    va_end(ap);
    return retval;
  106a8d:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  106a91:	83 c4 1c             	add    $0x1c,%esp
  106a94:	c3                   	ret    

00106a95 <atoi>:

#include <atoi.h>
#include <ctype.h>

long long int atoi(const char *c)
{
  106a95:	53                   	push   %ebx
  106a96:	83 ec 18             	sub    $0x18,%esp
    long long int value = 0;
  106a99:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  106aa0:	00 
  106aa1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106aa8:	00 
    int sign = 1;
  106aa9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  106ab0:	00 
    if( *c == '+' || *c == '-' )
  106ab1:	8b 44 24 20          	mov    0x20(%esp),%eax
  106ab5:	0f b6 00             	movzbl (%eax),%eax
  106ab8:	3c 2b                	cmp    $0x2b,%al
  106aba:	74 0b                	je     106ac7 <atoi+0x32>
  106abc:	8b 44 24 20          	mov    0x20(%esp),%eax
  106ac0:	0f b6 00             	movzbl (%eax),%eax
  106ac3:	3c 2d                	cmp    $0x2d,%al
  106ac5:	75 18                	jne    106adf <atoi+0x4a>
    {
        if( *c == '-' ) sign = -1;
  106ac7:	8b 44 24 20          	mov    0x20(%esp),%eax
  106acb:	0f b6 00             	movzbl (%eax),%eax
  106ace:	3c 2d                	cmp    $0x2d,%al
  106ad0:	75 08                	jne    106ada <atoi+0x45>
  106ad2:	c7 44 24 04 ff ff ff 	movl   $0xffffffff,0x4(%esp)
  106ad9:	ff 
        c++;
  106ada:	83 44 24 20 01       	addl   $0x1,0x20(%esp)
    }
    while (isdigit(*c))
  106adf:	8b 44 24 20          	mov    0x20(%esp),%eax
  106ae3:	0f b6 00             	movzbl (%eax),%eax
  106ae6:	0f be c0             	movsbl %al,%eax
  106ae9:	83 ec 0c             	sub    $0xc,%esp
  106aec:	50                   	push   %eax
  106aed:	e8 3c 10 00 00       	call   107b2e <_Z7isdigitDi>
  106af2:	83 c4 10             	add    $0x10,%esp
  106af5:	84 c0                	test   %al,%al
  106af7:	74 4b                	je     106b44 <atoi+0xaf>
    {
        value *= 10;
  106af9:	8b 44 24 0c          	mov    0xc(%esp),%eax
  106afd:	6b d0 0a             	imul   $0xa,%eax,%edx
  106b00:	8b 44 24 08          	mov    0x8(%esp),%eax
  106b04:	6b c0 00             	imul   $0x0,%eax,%eax
  106b07:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  106b0a:	b8 0a 00 00 00       	mov    $0xa,%eax
  106b0f:	f7 64 24 08          	mull   0x8(%esp)
  106b13:	01 d1                	add    %edx,%ecx
  106b15:	89 ca                	mov    %ecx,%edx
  106b17:	89 44 24 08          	mov    %eax,0x8(%esp)
  106b1b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  106b1f:	89 44 24 08          	mov    %eax,0x8(%esp)
  106b23:	89 54 24 0c          	mov    %edx,0xc(%esp)
        value += (int) (*c-'0');
  106b27:	8b 44 24 20          	mov    0x20(%esp),%eax
  106b2b:	0f b6 00             	movzbl (%eax),%eax
  106b2e:	0f be c0             	movsbl %al,%eax
  106b31:	83 e8 30             	sub    $0x30,%eax
  106b34:	99                   	cltd   
  106b35:	01 44 24 08          	add    %eax,0x8(%esp)
  106b39:	11 54 24 0c          	adc    %edx,0xc(%esp)
        c++;
  106b3d:	83 44 24 20 01       	addl   $0x1,0x20(%esp)
    while (isdigit(*c))
  106b42:	eb 9b                	jmp    106adf <atoi+0x4a>
    }
    return (value * sign);
  106b44:	8b 44 24 04          	mov    0x4(%esp),%eax
  106b48:	99                   	cltd   
  106b49:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  106b4d:	89 cb                	mov    %ecx,%ebx
  106b4f:	0f af da             	imul   %edx,%ebx
  106b52:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  106b56:	0f af c8             	imul   %eax,%ecx
  106b59:	01 d9                	add    %ebx,%ecx
  106b5b:	f7 64 24 08          	mull   0x8(%esp)
  106b5f:	01 d1                	add    %edx,%ecx
  106b61:	89 ca                	mov    %ecx,%edx
}
  106b63:	83 c4 18             	add    $0x18,%esp
  106b66:	5b                   	pop    %ebx
  106b67:	c3                   	ret    

00106b68 <ftoa>:
    0.0000000005,		// 9
    0.00000000005		// 10
};

char * ftoa(double f, char * buf, int precision)
{
  106b68:	83 ec 34             	sub    $0x34,%esp
  106b6b:	8b 44 24 38          	mov    0x38(%esp),%eax
  106b6f:	89 44 24 08          	mov    %eax,0x8(%esp)
  106b73:	8b 44 24 3c          	mov    0x3c(%esp),%eax
  106b77:	89 44 24 0c          	mov    %eax,0xc(%esp)
    char * ptr = buf;
  106b7b:	8b 44 24 40          	mov    0x40(%esp),%eax
  106b7f:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    char * p = ptr;
  106b83:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  106b87:	89 44 24 28          	mov    %eax,0x28(%esp)
    char * p1;
    char c;
    long intPart;

    // check precision bounds
    if (precision > MAX_PRECISION)
  106b8b:	83 7c 24 44 0a       	cmpl   $0xa,0x44(%esp)
  106b90:	7e 08                	jle    106b9a <ftoa+0x32>
        precision = MAX_PRECISION;
  106b92:	c7 44 24 44 0a 00 00 	movl   $0xa,0x44(%esp)
  106b99:	00 

    // sign stuff
    if (f < 0)
  106b9a:	dd 44 24 08          	fldl   0x8(%esp)
  106b9e:	d9 ee                	fldz   
  106ba0:	df e9                	fucomip %st(1),%st
  106ba2:	dd d8                	fstp   %st(0)
  106ba4:	76 18                	jbe    106bbe <ftoa+0x56>
    {
        f = -f;
  106ba6:	dd 44 24 08          	fldl   0x8(%esp)
  106baa:	d9 e0                	fchs   
  106bac:	dd 5c 24 08          	fstpl  0x8(%esp)
        *ptr++ = '-';
  106bb0:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  106bb4:	8d 50 01             	lea    0x1(%eax),%edx
  106bb7:	89 54 24 2c          	mov    %edx,0x2c(%esp)
  106bbb:	c6 00 2d             	movb   $0x2d,(%eax)
    }

    if (precision < 0)  // negative precision == automatic precision guess
  106bbe:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
  106bc3:	0f 89 a3 00 00 00    	jns    106c6c <ftoa+0x104>
    {
        if (f < 1.0) precision = 6;
  106bc9:	dd 44 24 08          	fldl   0x8(%esp)
  106bcd:	d9 e8                	fld1   
  106bcf:	df e9                	fucomip %st(1),%st
  106bd1:	dd d8                	fstp   %st(0)
  106bd3:	76 0d                	jbe    106be2 <ftoa+0x7a>
  106bd5:	c7 44 24 44 06 00 00 	movl   $0x6,0x44(%esp)
  106bdc:	00 
  106bdd:	e9 8a 00 00 00       	jmp    106c6c <ftoa+0x104>
        else if (f < 10.0) precision = 5;
  106be2:	dd 44 24 08          	fldl   0x8(%esp)
  106be6:	dd 05 78 ab 10 00    	fldl   0x10ab78
  106bec:	df e9                	fucomip %st(1),%st
  106bee:	dd d8                	fstp   %st(0)
  106bf0:	76 0a                	jbe    106bfc <ftoa+0x94>
  106bf2:	c7 44 24 44 05 00 00 	movl   $0x5,0x44(%esp)
  106bf9:	00 
  106bfa:	eb 70                	jmp    106c6c <ftoa+0x104>
        else if (f < 100.0) precision = 4;
  106bfc:	dd 44 24 08          	fldl   0x8(%esp)
  106c00:	dd 05 80 ab 10 00    	fldl   0x10ab80
  106c06:	df e9                	fucomip %st(1),%st
  106c08:	dd d8                	fstp   %st(0)
  106c0a:	76 0a                	jbe    106c16 <ftoa+0xae>
  106c0c:	c7 44 24 44 04 00 00 	movl   $0x4,0x44(%esp)
  106c13:	00 
  106c14:	eb 56                	jmp    106c6c <ftoa+0x104>
        else if (f < 1000.0) precision = 3;
  106c16:	dd 44 24 08          	fldl   0x8(%esp)
  106c1a:	dd 05 88 ab 10 00    	fldl   0x10ab88
  106c20:	df e9                	fucomip %st(1),%st
  106c22:	dd d8                	fstp   %st(0)
  106c24:	76 0a                	jbe    106c30 <ftoa+0xc8>
  106c26:	c7 44 24 44 03 00 00 	movl   $0x3,0x44(%esp)
  106c2d:	00 
  106c2e:	eb 3c                	jmp    106c6c <ftoa+0x104>
        else if (f < 10000.0) precision = 2;
  106c30:	dd 44 24 08          	fldl   0x8(%esp)
  106c34:	dd 05 90 ab 10 00    	fldl   0x10ab90
  106c3a:	df e9                	fucomip %st(1),%st
  106c3c:	dd d8                	fstp   %st(0)
  106c3e:	76 0a                	jbe    106c4a <ftoa+0xe2>
  106c40:	c7 44 24 44 02 00 00 	movl   $0x2,0x44(%esp)
  106c47:	00 
  106c48:	eb 22                	jmp    106c6c <ftoa+0x104>
        else if (f < 100000.0) precision = 1;
  106c4a:	dd 44 24 08          	fldl   0x8(%esp)
  106c4e:	dd 05 98 ab 10 00    	fldl   0x10ab98
  106c54:	df e9                	fucomip %st(1),%st
  106c56:	dd d8                	fstp   %st(0)
  106c58:	76 0a                	jbe    106c64 <ftoa+0xfc>
  106c5a:	c7 44 24 44 01 00 00 	movl   $0x1,0x44(%esp)
  106c61:	00 
  106c62:	eb 08                	jmp    106c6c <ftoa+0x104>
        else precision = 0;
  106c64:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
  106c6b:	00 
    }

    // round value according the precision
    if (precision)
  106c6c:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
  106c71:	74 15                	je     106c88 <ftoa+0x120>
        f += rounders[precision];
  106c73:	8b 44 24 44          	mov    0x44(%esp),%eax
  106c77:	dd 04 c5 20 ab 10 00 	fldl   0x10ab20(,%eax,8)
  106c7e:	dd 44 24 08          	fldl   0x8(%esp)
  106c82:	de c1                	faddp  %st,%st(1)
  106c84:	dd 5c 24 08          	fstpl  0x8(%esp)

    // integer part...
    intPart = f;
  106c88:	dd 44 24 08          	fldl   0x8(%esp)
  106c8c:	d9 7c 24 06          	fnstcw 0x6(%esp)
  106c90:	0f b7 44 24 06       	movzwl 0x6(%esp),%eax
  106c95:	b4 0c                	mov    $0xc,%ah
  106c97:	66 89 44 24 04       	mov    %ax,0x4(%esp)
  106c9c:	d9 6c 24 04          	fldcw  0x4(%esp)
  106ca0:	db 5c 24 24          	fistpl 0x24(%esp)
  106ca4:	d9 6c 24 06          	fldcw  0x6(%esp)
    f -= intPart;
  106ca8:	db 44 24 24          	fildl  0x24(%esp)
  106cac:	dd 44 24 08          	fldl   0x8(%esp)
  106cb0:	de e1                	fsubp  %st,%st(1)
  106cb2:	dd 5c 24 08          	fstpl  0x8(%esp)

    if (!intPart)
  106cb6:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  106cbb:	75 13                	jne    106cd0 <ftoa+0x168>
        *ptr++ = '0';
  106cbd:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  106cc1:	8d 50 01             	lea    0x1(%eax),%edx
  106cc4:	89 54 24 2c          	mov    %edx,0x2c(%esp)
  106cc8:	c6 00 30             	movb   $0x30,(%eax)
  106ccb:	e9 b1 00 00 00       	jmp    106d81 <ftoa+0x219>
    else
    {
        // save start pointer
        p = ptr;
  106cd0:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  106cd4:	89 44 24 28          	mov    %eax,0x28(%esp)

        // convert (reverse order)
        while (intPart)
  106cd8:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
  106cdd:	74 57                	je     106d36 <ftoa+0x1ce>
        {
            *p++ = '0' + intPart % 10;
  106cdf:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  106ce3:	ba 67 66 66 66       	mov    $0x66666667,%edx
  106ce8:	89 c8                	mov    %ecx,%eax
  106cea:	f7 ea                	imul   %edx
  106cec:	c1 fa 02             	sar    $0x2,%edx
  106cef:	89 c8                	mov    %ecx,%eax
  106cf1:	c1 f8 1f             	sar    $0x1f,%eax
  106cf4:	29 c2                	sub    %eax,%edx
  106cf6:	89 d0                	mov    %edx,%eax
  106cf8:	c1 e0 02             	shl    $0x2,%eax
  106cfb:	01 d0                	add    %edx,%eax
  106cfd:	01 c0                	add    %eax,%eax
  106cff:	29 c1                	sub    %eax,%ecx
  106d01:	89 ca                	mov    %ecx,%edx
  106d03:	89 d0                	mov    %edx,%eax
  106d05:	83 c0 30             	add    $0x30,%eax
  106d08:	89 c1                	mov    %eax,%ecx
  106d0a:	8b 44 24 28          	mov    0x28(%esp),%eax
  106d0e:	8d 50 01             	lea    0x1(%eax),%edx
  106d11:	89 54 24 28          	mov    %edx,0x28(%esp)
  106d15:	88 08                	mov    %cl,(%eax)
            intPart /= 10;
  106d17:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  106d1b:	ba 67 66 66 66       	mov    $0x66666667,%edx
  106d20:	89 c8                	mov    %ecx,%eax
  106d22:	f7 ea                	imul   %edx
  106d24:	c1 fa 02             	sar    $0x2,%edx
  106d27:	89 c8                	mov    %ecx,%eax
  106d29:	c1 f8 1f             	sar    $0x1f,%eax
  106d2c:	29 c2                	sub    %eax,%edx
  106d2e:	89 d0                	mov    %edx,%eax
  106d30:	89 44 24 24          	mov    %eax,0x24(%esp)
        while (intPart)
  106d34:	eb a2                	jmp    106cd8 <ftoa+0x170>
        }

        // save end pos
        p1 = p;
  106d36:	8b 44 24 28          	mov    0x28(%esp),%eax
  106d3a:	89 44 24 20          	mov    %eax,0x20(%esp)

        // reverse result
        while (p > ptr)
  106d3e:	8b 44 24 28          	mov    0x28(%esp),%eax
  106d42:	3b 44 24 2c          	cmp    0x2c(%esp),%eax
  106d46:	76 31                	jbe    106d79 <ftoa+0x211>
        {
            c = *--p;
  106d48:	83 6c 24 28 01       	subl   $0x1,0x28(%esp)
  106d4d:	8b 44 24 28          	mov    0x28(%esp),%eax
  106d51:	0f b6 00             	movzbl (%eax),%eax
  106d54:	88 44 24 1f          	mov    %al,0x1f(%esp)
            *p = *ptr;
  106d58:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  106d5c:	0f b6 10             	movzbl (%eax),%edx
  106d5f:	8b 44 24 28          	mov    0x28(%esp),%eax
  106d63:	88 10                	mov    %dl,(%eax)
            *ptr++ = c;
  106d65:	0f b6 54 24 1f       	movzbl 0x1f(%esp),%edx
  106d6a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  106d6e:	8d 48 01             	lea    0x1(%eax),%ecx
  106d71:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
  106d75:	88 10                	mov    %dl,(%eax)
        while (p > ptr)
  106d77:	eb c5                	jmp    106d3e <ftoa+0x1d6>
        }

        // restore end pos
        ptr = p1;
  106d79:	8b 44 24 20          	mov    0x20(%esp),%eax
  106d7d:	89 44 24 2c          	mov    %eax,0x2c(%esp)
    }

    // decimal part
    if (precision)
  106d81:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
  106d86:	74 7b                	je     106e03 <ftoa+0x29b>
    {
        // place decimal point
        *ptr++ = '.';
  106d88:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  106d8c:	8d 50 01             	lea    0x1(%eax),%edx
  106d8f:	89 54 24 2c          	mov    %edx,0x2c(%esp)
  106d93:	c6 00 2e             	movb   $0x2e,(%eax)

        // convert
        while (precision--)
  106d96:	8b 44 24 44          	mov    0x44(%esp),%eax
  106d9a:	8d 50 ff             	lea    -0x1(%eax),%edx
  106d9d:	89 54 24 44          	mov    %edx,0x44(%esp)
  106da1:	85 c0                	test   %eax,%eax
  106da3:	0f 95 c0             	setne  %al
  106da6:	84 c0                	test   %al,%al
  106da8:	74 59                	je     106e03 <ftoa+0x29b>
        {
            f *= 10.0;
  106daa:	dd 44 24 08          	fldl   0x8(%esp)
  106dae:	dd 05 78 ab 10 00    	fldl   0x10ab78
  106db4:	de c9                	fmulp  %st,%st(1)
  106db6:	dd 5c 24 08          	fstpl  0x8(%esp)
            c = f;
  106dba:	dd 44 24 08          	fldl   0x8(%esp)
  106dbe:	d9 6c 24 04          	fldcw  0x4(%esp)
  106dc2:	df 5c 24 02          	fistp  0x2(%esp)
  106dc6:	d9 6c 24 06          	fldcw  0x6(%esp)
  106dca:	0f b7 44 24 02       	movzwl 0x2(%esp),%eax
  106dcf:	88 44 24 1f          	mov    %al,0x1f(%esp)
            *ptr++ = '0' + c;
  106dd3:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
  106dd8:	83 c0 30             	add    $0x30,%eax
  106ddb:	89 c1                	mov    %eax,%ecx
  106ddd:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  106de1:	8d 50 01             	lea    0x1(%eax),%edx
  106de4:	89 54 24 2c          	mov    %edx,0x2c(%esp)
  106de8:	88 08                	mov    %cl,(%eax)
            f -= c;
  106dea:	66 0f be 44 24 1f    	movsbw 0x1f(%esp),%ax
  106df0:	66 89 04 24          	mov    %ax,(%esp)
  106df4:	df 04 24             	fild   (%esp)
  106df7:	dd 44 24 08          	fldl   0x8(%esp)
  106dfb:	de e1                	fsubp  %st,%st(1)
  106dfd:	dd 5c 24 08          	fstpl  0x8(%esp)
        while (precision--)
  106e01:	eb 93                	jmp    106d96 <ftoa+0x22e>
        }
    }

    // terminating zero
    *ptr = '\0';
  106e03:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  106e07:	c6 00 00             	movb   $0x0,(%eax)

    return buf;
  106e0a:	8b 44 24 40          	mov    0x40(%esp),%eax
}
  106e0e:	83 c4 34             	add    $0x34,%esp
  106e11:	c3                   	ret    

00106e12 <itoa>:

int64_t itoa(int64_t value, char *sp, int radix)
{
  106e12:	55                   	push   %ebp
  106e13:	57                   	push   %edi
  106e14:	56                   	push   %esi
  106e15:	53                   	push   %ebx
  106e16:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
  106e1c:	8b 8c 24 a0 00 00 00 	mov    0xa0(%esp),%ecx
  106e23:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  106e27:	8b 8c 24 a4 00 00 00 	mov    0xa4(%esp),%ecx
  106e2e:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
    char tmp[65];// be careful with the length of the buffer
    char *tp = tmp;
  106e32:	8d 4c 24 17          	lea    0x17(%esp),%ecx
  106e36:	89 4c 24 7c          	mov    %ecx,0x7c(%esp)
    int64_t i;
    uint64_t v;

    int64_t sign = (radix == 10 && value < 0);
  106e3a:	83 bc 24 ac 00 00 00 	cmpl   $0xa,0xac(%esp)
  106e41:	0a 
  106e42:	75 0e                	jne    106e52 <itoa+0x40>
  106e44:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
  106e49:	79 07                	jns    106e52 <itoa+0x40>
  106e4b:	b9 01 00 00 00       	mov    $0x1,%ecx
  106e50:	eb 05                	jmp    106e57 <itoa+0x45>
  106e52:	b9 00 00 00 00       	mov    $0x0,%ecx
  106e57:	0f b6 c9             	movzbl %cl,%ecx
  106e5a:	89 4c 24 60          	mov    %ecx,0x60(%esp)
  106e5e:	c7 44 24 64 00 00 00 	movl   $0x0,0x64(%esp)
  106e65:	00 
    if (sign)
  106e66:	8b 4c 24 60          	mov    0x60(%esp),%ecx
  106e6a:	80 f5 00             	xor    $0x0,%ch
  106e6d:	89 c8                	mov    %ecx,%eax
  106e6f:	8b 4c 24 64          	mov    0x64(%esp),%ecx
  106e73:	80 f5 00             	xor    $0x0,%ch
  106e76:	89 ca                	mov    %ecx,%edx
  106e78:	09 d0                	or     %edx,%eax
  106e7a:	85 c0                	test   %eax,%eax
  106e7c:	74 19                	je     106e97 <itoa+0x85>
        v = -value;
  106e7e:	8b 44 24 08          	mov    0x8(%esp),%eax
  106e82:	8b 54 24 0c          	mov    0xc(%esp),%edx
  106e86:	f7 d8                	neg    %eax
  106e88:	83 d2 00             	adc    $0x0,%edx
  106e8b:	f7 da                	neg    %edx
  106e8d:	89 44 24 70          	mov    %eax,0x70(%esp)
  106e91:	89 54 24 74          	mov    %edx,0x74(%esp)
  106e95:	eb 10                	jmp    106ea7 <itoa+0x95>
    else
        v = (uint64_t)value;
  106e97:	8b 44 24 08          	mov    0x8(%esp),%eax
  106e9b:	8b 54 24 0c          	mov    0xc(%esp),%edx
  106e9f:	89 44 24 70          	mov    %eax,0x70(%esp)
  106ea3:	89 54 24 74          	mov    %edx,0x74(%esp)

    while (v || tp == tmp)
  106ea7:	8b 44 24 70          	mov    0x70(%esp),%eax
  106eab:	80 f4 00             	xor    $0x0,%ah
  106eae:	89 c7                	mov    %eax,%edi
  106eb0:	8b 44 24 74          	mov    0x74(%esp),%eax
  106eb4:	80 f4 00             	xor    $0x0,%ah
  106eb7:	89 c5                	mov    %eax,%ebp
  106eb9:	89 e8                	mov    %ebp,%eax
  106ebb:	09 f8                	or     %edi,%eax
  106ebd:	85 c0                	test   %eax,%eax
  106ebf:	75 0e                	jne    106ecf <itoa+0xbd>
  106ec1:	8d 44 24 17          	lea    0x17(%esp),%eax
  106ec5:	39 44 24 7c          	cmp    %eax,0x7c(%esp)
  106ec9:	0f 85 9e 00 00 00    	jne    106f6d <itoa+0x15b>
    {
        i = v % radix;
  106ecf:	8b 84 24 ac 00 00 00 	mov    0xac(%esp),%eax
  106ed6:	89 04 24             	mov    %eax,(%esp)
  106ed9:	99                   	cltd   
  106eda:	89 54 24 04          	mov    %edx,0x4(%esp)
  106ede:	8b 44 24 70          	mov    0x70(%esp),%eax
  106ee2:	8b 54 24 74          	mov    0x74(%esp),%edx
  106ee6:	ff 74 24 04          	pushl  0x4(%esp)
  106eea:	ff 74 24 04          	pushl  0x4(%esp)
  106eee:	52                   	push   %edx
  106eef:	50                   	push   %eax
  106ef0:	e8 cb 03 00 00       	call   1072c0 <__umoddi3>
  106ef5:	83 c4 10             	add    $0x10,%esp
  106ef8:	89 44 24 58          	mov    %eax,0x58(%esp)
  106efc:	89 54 24 5c          	mov    %edx,0x5c(%esp)
        v /= radix; // v/=radix uses less CPU clocks than v=v/radix does
  106f00:	8b 84 24 ac 00 00 00 	mov    0xac(%esp),%eax
  106f07:	99                   	cltd   
  106f08:	52                   	push   %edx
  106f09:	50                   	push   %eax
  106f0a:	ff 74 24 7c          	pushl  0x7c(%esp)
  106f0e:	ff 74 24 7c          	pushl  0x7c(%esp)
  106f12:	e8 79 02 00 00       	call   107190 <__udivdi3>
  106f17:	83 c4 10             	add    $0x10,%esp
  106f1a:	89 44 24 70          	mov    %eax,0x70(%esp)
  106f1e:	89 54 24 74          	mov    %edx,0x74(%esp)
        if (i < 10)
  106f22:	83 7c 24 5c 00       	cmpl   $0x0,0x5c(%esp)
  106f27:	7f 29                	jg     106f52 <itoa+0x140>
  106f29:	83 7c 24 5c 00       	cmpl   $0x0,0x5c(%esp)
  106f2e:	78 07                	js     106f37 <itoa+0x125>
  106f30:	83 7c 24 58 09       	cmpl   $0x9,0x58(%esp)
  106f35:	77 1b                	ja     106f52 <itoa+0x140>
          *tp++ = i+'0';
  106f37:	8b 44 24 58          	mov    0x58(%esp),%eax
  106f3b:	83 c0 30             	add    $0x30,%eax
  106f3e:	89 c1                	mov    %eax,%ecx
  106f40:	8b 44 24 7c          	mov    0x7c(%esp),%eax
  106f44:	8d 50 01             	lea    0x1(%eax),%edx
  106f47:	89 54 24 7c          	mov    %edx,0x7c(%esp)
  106f4b:	88 08                	mov    %cl,(%eax)
  106f4d:	e9 55 ff ff ff       	jmp    106ea7 <itoa+0x95>
        else
          *tp++ = i + 'a' - 10;
  106f52:	8b 44 24 58          	mov    0x58(%esp),%eax
  106f56:	83 c0 57             	add    $0x57,%eax
  106f59:	89 c1                	mov    %eax,%ecx
  106f5b:	8b 44 24 7c          	mov    0x7c(%esp),%eax
  106f5f:	8d 50 01             	lea    0x1(%eax),%edx
  106f62:	89 54 24 7c          	mov    %edx,0x7c(%esp)
  106f66:	88 08                	mov    %cl,(%eax)
    while (v || tp == tmp)
  106f68:	e9 3a ff ff ff       	jmp    106ea7 <itoa+0x95>
    }

    int64_t len = tp - tmp;
  106f6d:	8b 54 24 7c          	mov    0x7c(%esp),%edx
  106f71:	8d 44 24 17          	lea    0x17(%esp),%eax
  106f75:	29 c2                	sub    %eax,%edx
  106f77:	89 d0                	mov    %edx,%eax
  106f79:	99                   	cltd   
  106f7a:	89 44 24 68          	mov    %eax,0x68(%esp)
  106f7e:	89 54 24 6c          	mov    %edx,0x6c(%esp)

    if (sign)
  106f82:	8b 44 24 60          	mov    0x60(%esp),%eax
  106f86:	80 f4 00             	xor    $0x0,%ah
  106f89:	89 c3                	mov    %eax,%ebx
  106f8b:	8b 44 24 64          	mov    0x64(%esp),%eax
  106f8f:	80 f4 00             	xor    $0x0,%ah
  106f92:	89 c6                	mov    %eax,%esi
  106f94:	89 f0                	mov    %esi,%eax
  106f96:	09 d8                	or     %ebx,%eax
  106f98:	85 c0                	test   %eax,%eax
  106f9a:	74 1e                	je     106fba <itoa+0x1a8>
    {
        *sp++ = '-';
  106f9c:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
  106fa3:	8d 50 01             	lea    0x1(%eax),%edx
  106fa6:	89 94 24 a8 00 00 00 	mov    %edx,0xa8(%esp)
  106fad:	c6 00 2d             	movb   $0x2d,(%eax)
        len++;
  106fb0:	83 44 24 68 01       	addl   $0x1,0x68(%esp)
  106fb5:	83 54 24 6c 00       	adcl   $0x0,0x6c(%esp)
    }

    while (tp > tmp)
  106fba:	8d 44 24 17          	lea    0x17(%esp),%eax
  106fbe:	39 44 24 7c          	cmp    %eax,0x7c(%esp)
  106fc2:	76 21                	jbe    106fe5 <itoa+0x1d3>
        *sp++ = *--tp;
  106fc4:	83 6c 24 7c 01       	subl   $0x1,0x7c(%esp)
  106fc9:	8b 44 24 7c          	mov    0x7c(%esp),%eax
  106fcd:	0f b6 10             	movzbl (%eax),%edx
  106fd0:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
  106fd7:	8d 48 01             	lea    0x1(%eax),%ecx
  106fda:	89 8c 24 a8 00 00 00 	mov    %ecx,0xa8(%esp)
  106fe1:	88 10                	mov    %dl,(%eax)
    while (tp > tmp)
  106fe3:	eb d5                	jmp    106fba <itoa+0x1a8>

    return len;
  106fe5:	8b 44 24 68          	mov    0x68(%esp),%eax
  106fe9:	8b 54 24 6c          	mov    0x6c(%esp),%edx
}
  106fed:	81 c4 8c 00 00 00    	add    $0x8c,%esp
  106ff3:	5b                   	pop    %ebx
  106ff4:	5e                   	pop    %esi
  106ff5:	5f                   	pop    %edi
  106ff6:	5d                   	pop    %ebp
  106ff7:	c3                   	ret    

00106ff8 <putchar>:
#ifdef __is_libk
#include <terminal/terminal.hpp>
#endif

void putchar(char c)
{
  106ff8:	83 ec 1c             	sub    $0x1c,%esp
  106ffb:	8b 44 24 20          	mov    0x20(%esp),%eax
  106fff:	88 44 24 0c          	mov    %al,0xc(%esp)
#ifdef __is_libk
        Terminal::put_char(c);
  107003:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  107008:	0f b6 c0             	movzbl %al,%eax
  10700b:	83 ec 0c             	sub    $0xc,%esp
  10700e:	50                   	push   %eax
  10700f:	e8 c9 0a 00 00       	call   107add <_ZN8Terminal8put_charEh>
  107014:	83 c4 10             	add    $0x10,%esp
#else
        // TODO : do !
#error Not implemented yet
#endif
}
  107017:	90                   	nop
  107018:	83 c4 1c             	add    $0x1c,%esp
  10701b:	c3                   	ret    

0010701c <_Z41__static_initialization_and_destruction_0ii>:
  10701c:	83 ec 0c             	sub    $0xc,%esp
  10701f:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
  107024:	75 2e                	jne    107054 <_Z41__static_initialization_and_destruction_0ii+0x38>
  107026:	81 7c 24 14 ff ff 00 	cmpl   $0xffff,0x14(%esp)
  10702d:	00 
  10702e:	75 24                	jne    107054 <_Z41__static_initialization_and_destruction_0ii+0x38>
  107030:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  107035:	0f b6 00             	movzbl (%eax),%eax
  107038:	84 c0                	test   %al,%al
  10703a:	75 18                	jne    107054 <_Z41__static_initialization_and_destruction_0ii+0x38>
  10703c:	b8 c0 ef 11 00       	mov    $0x11efc0,%eax
  107041:	c6 00 01             	movb   $0x1,(%eax)
  107044:	83 ec 0c             	sub    $0xc,%esp
  107047:	68 60 53 11 00       	push   $0x115360
  10704c:	e8 e9 c0 ff ff       	call   10313a <_ZN6detail12TerminalImplC1Ev>
  107051:	83 c4 10             	add    $0x10,%esp
  107054:	90                   	nop
  107055:	83 c4 0c             	add    $0xc,%esp
  107058:	c3                   	ret    

00107059 <_GLOBAL__sub_I_putchar>:
  107059:	83 ec 0c             	sub    $0xc,%esp
  10705c:	83 ec 08             	sub    $0x8,%esp
  10705f:	68 ff ff 00 00       	push   $0xffff
  107064:	6a 01                	push   $0x1
  107066:	e8 b1 ff ff ff       	call   10701c <_Z41__static_initialization_and_destruction_0ii>
  10706b:	83 c4 10             	add    $0x10,%esp
  10706e:	83 c4 0c             	add    $0xc,%esp
  107071:	c3                   	ret    

00107072 <puts>:


#include <stdio.h>

void puts(const char* string)
{
  107072:	83 ec 0c             	sub    $0xc,%esp
    printf("%s\n", string);
  107075:	83 ec 08             	sub    $0x8,%esp
  107078:	ff 74 24 18          	pushl  0x18(%esp)
  10707c:	68 a4 ab 10 00       	push   $0x10aba4
  107081:	e8 4c f8 ff ff       	call   1068d2 <tfp_printf>
  107086:	83 c4 10             	add    $0x10,%esp
}
  107089:	90                   	nop
  10708a:	83 c4 0c             	add    $0xc,%esp
  10708d:	c3                   	ret    

0010708e <memcpy>:

*/
#include <string.h>

void* memcpy(void* __restrict dstptr, const void* __restrict srcptr, size_t size)
{
  10708e:	83 ec 10             	sub    $0x10,%esp
        unsigned char* dst = (unsigned char*) dstptr;
  107091:	8b 44 24 14          	mov    0x14(%esp),%eax
  107095:	89 44 24 08          	mov    %eax,0x8(%esp)
        const unsigned char* src = (const unsigned char*) srcptr;
  107099:	8b 44 24 18          	mov    0x18(%esp),%eax
  10709d:	89 44 24 04          	mov    %eax,0x4(%esp)
        for (size_t i = 0; i < size; i++)
  1070a1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1070a8:	00 
  1070a9:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1070ad:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
  1070b1:	73 20                	jae    1070d3 <memcpy+0x45>
                dst[i] = src[i];
  1070b3:	8b 54 24 04          	mov    0x4(%esp),%edx
  1070b7:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1070bb:	01 d0                	add    %edx,%eax
  1070bd:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  1070c1:	8b 54 24 0c          	mov    0xc(%esp),%edx
  1070c5:	01 ca                	add    %ecx,%edx
  1070c7:	0f b6 00             	movzbl (%eax),%eax
  1070ca:	88 02                	mov    %al,(%edx)
        for (size_t i = 0; i < size; i++)
  1070cc:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
  1070d1:	eb d6                	jmp    1070a9 <memcpy+0x1b>
        return dstptr;
  1070d3:	8b 44 24 14          	mov    0x14(%esp),%eax
}
  1070d7:	83 c4 10             	add    $0x10,%esp
  1070da:	c3                   	ret    

001070db <memset>:

*/
#include <string.h>

void* memset(void* bufptr, int value, size_t size)
{
  1070db:	83 ec 10             	sub    $0x10,%esp
    unsigned char* buf = (unsigned char*) bufptr;
  1070de:	8b 44 24 14          	mov    0x14(%esp),%eax
  1070e2:	89 44 24 08          	mov    %eax,0x8(%esp)
    for (size_t i = 0; i < size; i++)
  1070e6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1070ed:	00 
  1070ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
  1070f2:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
  1070f6:	73 17                	jae    10710f <memset+0x34>
        buf[i] = (unsigned char) value;
  1070f8:	8b 54 24 08          	mov    0x8(%esp),%edx
  1070fc:	8b 44 24 0c          	mov    0xc(%esp),%eax
  107100:	01 d0                	add    %edx,%eax
  107102:	8b 54 24 18          	mov    0x18(%esp),%edx
  107106:	88 10                	mov    %dl,(%eax)
    for (size_t i = 0; i < size; i++)
  107108:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
  10710d:	eb df                	jmp    1070ee <memset+0x13>
    return bufptr;
  10710f:	8b 44 24 14          	mov    0x14(%esp),%eax
}
  107113:	83 c4 10             	add    $0x10,%esp
  107116:	c3                   	ret    

00107117 <memsetw>:

void* memsetw(void* bufptr, uint16_t value, size_t size)
{
  107117:	83 ec 14             	sub    $0x14,%esp
  10711a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  10711e:	66 89 04 24          	mov    %ax,(%esp)
    uint16_t* buf = (uint16_t*) bufptr;
  107122:	8b 44 24 18          	mov    0x18(%esp),%eax
  107126:	89 44 24 0c          	mov    %eax,0xc(%esp)
    for (size_t i = 0; i < size/2; i++)
  10712a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  107131:	00 
  107132:	8b 44 24 20          	mov    0x20(%esp),%eax
  107136:	d1 e8                	shr    %eax
  107138:	39 44 24 10          	cmp    %eax,0x10(%esp)
  10713c:	73 1b                	jae    107159 <memsetw+0x42>
    {
        buf[i] = value;
  10713e:	8b 44 24 10          	mov    0x10(%esp),%eax
  107142:	8d 14 00             	lea    (%eax,%eax,1),%edx
  107145:	8b 44 24 0c          	mov    0xc(%esp),%eax
  107149:	01 c2                	add    %eax,%edx
  10714b:	0f b7 04 24          	movzwl (%esp),%eax
  10714f:	66 89 02             	mov    %ax,(%edx)
    for (size_t i = 0; i < size/2; i++)
  107152:	83 44 24 10 01       	addl   $0x1,0x10(%esp)
  107157:	eb d9                	jmp    107132 <memsetw+0x1b>
    }
    return bufptr;
  107159:	8b 44 24 18          	mov    0x18(%esp),%eax
}
  10715d:	83 c4 14             	add    $0x14,%esp
  107160:	c3                   	ret    

00107161 <strlen>:
*/

#include <string.h>

size_t strlen(const char* str)
{
  107161:	83 ec 10             	sub    $0x10,%esp
        size_t len = 0;
  107164:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10716b:	00 
        while (str[len])
  10716c:	8b 54 24 14          	mov    0x14(%esp),%edx
  107170:	8b 44 24 0c          	mov    0xc(%esp),%eax
  107174:	01 d0                	add    %edx,%eax
  107176:	0f b6 00             	movzbl (%eax),%eax
  107179:	84 c0                	test   %al,%al
  10717b:	74 07                	je     107184 <strlen+0x23>
                len++;
  10717d:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
        while (str[len])
  107182:	eb e8                	jmp    10716c <strlen+0xb>
        return len;
  107184:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  107188:	83 c4 10             	add    $0x10,%esp
  10718b:	c3                   	ret    
  10718c:	66 90                	xchg   %ax,%ax
  10718e:	66 90                	xchg   %ax,%ax

00107190 <__udivdi3>:
#endif

#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  107190:	55                   	push   %ebp
  107191:	57                   	push   %edi
  107192:	56                   	push   %esi
  107193:	53                   	push   %ebx
  107194:	83 ec 1c             	sub    $0x1c,%esp
  107197:	8b 54 24 3c          	mov    0x3c(%esp),%edx
  10719b:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  10719f:	8b 74 24 34          	mov    0x34(%esp),%esi
  1071a3:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  if (d1 == 0)
  1071a7:	85 d2                	test   %edx,%edx
  1071a9:	75 35                	jne    1071e0 <__udivdi3+0x50>
      if (d0 > n1)
  1071ab:	39 f3                	cmp    %esi,%ebx
  1071ad:	0f 87 bd 00 00 00    	ja     107270 <__udivdi3+0xe0>
	  if (d0 == 0)
  1071b3:	85 db                	test   %ebx,%ebx
  1071b5:	89 d9                	mov    %ebx,%ecx
  1071b7:	75 0b                	jne    1071c4 <__udivdi3+0x34>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
  1071b9:	b8 01 00 00 00       	mov    $0x1,%eax
  1071be:	31 d2                	xor    %edx,%edx
  1071c0:	f7 f3                	div    %ebx
  1071c2:	89 c1                	mov    %eax,%ecx
	  udiv_qrnnd (q1, n1, 0, n1, d0);
  1071c4:	31 d2                	xor    %edx,%edx
  1071c6:	89 f0                	mov    %esi,%eax
  1071c8:	f7 f1                	div    %ecx
  1071ca:	89 c6                	mov    %eax,%esi
	  udiv_qrnnd (q0, n0, n1, n0, d0);
  1071cc:	89 e8                	mov    %ebp,%eax
  1071ce:	89 f7                	mov    %esi,%edi
  1071d0:	f7 f1                	div    %ecx
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
  1071d2:	89 fa                	mov    %edi,%edx
  1071d4:	83 c4 1c             	add    $0x1c,%esp
  1071d7:	5b                   	pop    %ebx
  1071d8:	5e                   	pop    %esi
  1071d9:	5f                   	pop    %edi
  1071da:	5d                   	pop    %ebp
  1071db:	c3                   	ret    
  1071dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
      if (d1 > n1)
  1071e0:	39 f2                	cmp    %esi,%edx
  1071e2:	77 7c                	ja     107260 <__udivdi3+0xd0>
	  count_leading_zeros (bm, d1);
  1071e4:	0f bd fa             	bsr    %edx,%edi
	  if (bm == 0)
  1071e7:	83 f7 1f             	xor    $0x1f,%edi
  1071ea:	0f 84 a0 00 00 00    	je     107290 <__udivdi3+0x100>
	      d1 = (d1 << bm) | (d0 >> b);
  1071f0:	89 f9                	mov    %edi,%ecx
	      b = W_TYPE_SIZE - bm;
  1071f2:	b8 20 00 00 00       	mov    $0x20,%eax
  1071f7:	29 f8                	sub    %edi,%eax
	      d1 = (d1 << bm) | (d0 >> b);
  1071f9:	d3 e2                	shl    %cl,%edx
  1071fb:	89 54 24 08          	mov    %edx,0x8(%esp)
  1071ff:	89 c1                	mov    %eax,%ecx
  107201:	89 da                	mov    %ebx,%edx
  107203:	d3 ea                	shr    %cl,%edx
  107205:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  107209:	09 d1                	or     %edx,%ecx
	      n2 = n1 >> b;
  10720b:	89 f2                	mov    %esi,%edx
	      d1 = (d1 << bm) | (d0 >> b);
  10720d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
	      d0 = d0 << bm;
  107211:	89 f9                	mov    %edi,%ecx
  107213:	d3 e3                	shl    %cl,%ebx
	      n2 = n1 >> b;
  107215:	89 c1                	mov    %eax,%ecx
  107217:	d3 ea                	shr    %cl,%edx
	      n1 = (n1 << bm) | (n0 >> b);
  107219:	89 f9                	mov    %edi,%ecx
	      d0 = d0 << bm;
  10721b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
	      n1 = (n1 << bm) | (n0 >> b);
  10721f:	d3 e6                	shl    %cl,%esi
  107221:	89 eb                	mov    %ebp,%ebx
  107223:	89 c1                	mov    %eax,%ecx
  107225:	d3 eb                	shr    %cl,%ebx
  107227:	09 de                	or     %ebx,%esi
	      udiv_qrnnd (q0, n1, n2, n1, d1);
  107229:	89 f0                	mov    %esi,%eax
  10722b:	f7 74 24 08          	divl   0x8(%esp)
  10722f:	89 d6                	mov    %edx,%esi
  107231:	89 c3                	mov    %eax,%ebx
	      umul_ppmm (m1, m0, q0, d0);
  107233:	f7 64 24 0c          	mull   0xc(%esp)
	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  107237:	39 d6                	cmp    %edx,%esi
  107239:	72 0c                	jb     107247 <__udivdi3+0xb7>
	      n0 = n0 << bm;
  10723b:	89 f9                	mov    %edi,%ecx
  10723d:	d3 e5                	shl    %cl,%ebp
	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  10723f:	39 c5                	cmp    %eax,%ebp
  107241:	73 6d                	jae    1072b0 <__udivdi3+0x120>
  107243:	39 d6                	cmp    %edx,%esi
  107245:	75 69                	jne    1072b0 <__udivdi3+0x120>
		  q0--;
  107247:	8d 43 ff             	lea    -0x1(%ebx),%eax
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
  10724a:	31 ff                	xor    %edi,%edi
}
  10724c:	89 fa                	mov    %edi,%edx
  10724e:	83 c4 1c             	add    $0x1c,%esp
  107251:	5b                   	pop    %ebx
  107252:	5e                   	pop    %esi
  107253:	5f                   	pop    %edi
  107254:	5d                   	pop    %ebp
  107255:	c3                   	ret    
  107256:	8d 76 00             	lea    0x0(%esi),%esi
  107259:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
      if (d1 > n1)
  107260:	31 ff                	xor    %edi,%edi
  107262:	31 c0                	xor    %eax,%eax
}
  107264:	89 fa                	mov    %edi,%edx
  107266:	83 c4 1c             	add    $0x1c,%esp
  107269:	5b                   	pop    %ebx
  10726a:	5e                   	pop    %esi
  10726b:	5f                   	pop    %edi
  10726c:	5d                   	pop    %ebp
  10726d:	c3                   	ret    
  10726e:	66 90                	xchg   %ax,%ax
	  udiv_qrnnd (q0, n0, n1, n0, d0);
  107270:	31 ff                	xor    %edi,%edi
  107272:	89 e8                	mov    %ebp,%eax
  107274:	89 f2                	mov    %esi,%edx
  107276:	f7 f3                	div    %ebx
}
  107278:	89 fa                	mov    %edi,%edx
  10727a:	83 c4 1c             	add    $0x1c,%esp
  10727d:	5b                   	pop    %ebx
  10727e:	5e                   	pop    %esi
  10727f:	5f                   	pop    %edi
  107280:	5d                   	pop    %ebp
  107281:	c3                   	ret    
  107282:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  107289:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	      if (n1 > d1 || n0 >= d0)
  107290:	39 f2                	cmp    %esi,%edx
  107292:	72 06                	jb     10729a <__udivdi3+0x10a>
  107294:	31 c0                	xor    %eax,%eax
  107296:	39 eb                	cmp    %ebp,%ebx
  107298:	77 ca                	ja     107264 <__udivdi3+0xd4>
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
  10729a:	b8 01 00 00 00       	mov    $0x1,%eax
  10729f:	eb c3                	jmp    107264 <__udivdi3+0xd4>
  1072a1:	eb 0d                	jmp    1072b0 <__udivdi3+0x120>
  1072a3:	90                   	nop
  1072a4:	90                   	nop
  1072a5:	90                   	nop
  1072a6:	90                   	nop
  1072a7:	90                   	nop
  1072a8:	90                   	nop
  1072a9:	90                   	nop
  1072aa:	90                   	nop
  1072ab:	90                   	nop
  1072ac:	90                   	nop
  1072ad:	90                   	nop
  1072ae:	90                   	nop
  1072af:	90                   	nop
  1072b0:	89 d8                	mov    %ebx,%eax
	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  1072b2:	31 ff                	xor    %edi,%edi
  1072b4:	eb ae                	jmp    107264 <__udivdi3+0xd4>
  1072b6:	66 90                	xchg   %ax,%ax
  1072b8:	66 90                	xchg   %ax,%ax
  1072ba:	66 90                	xchg   %ax,%ax
  1072bc:	66 90                	xchg   %ax,%ax
  1072be:	66 90                	xchg   %ax,%ax

001072c0 <__umoddi3>:
{
  1072c0:	55                   	push   %ebp
  1072c1:	57                   	push   %edi
  1072c2:	56                   	push   %esi
  1072c3:	53                   	push   %ebx
  1072c4:	83 ec 1c             	sub    $0x1c,%esp
  1072c7:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
  1072cb:	8b 74 24 30          	mov    0x30(%esp),%esi
  1072cf:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  1072d3:	8b 7c 24 38          	mov    0x38(%esp),%edi
  if (d1 == 0)
  1072d7:	85 ed                	test   %ebp,%ebp
  n0 = nn.s.low;
  1072d9:	89 f0                	mov    %esi,%eax
  n1 = nn.s.high;
  1072db:	89 da                	mov    %ebx,%edx
  if (d1 == 0)
  1072dd:	75 21                	jne    107300 <__umoddi3+0x40>
      if (d0 > n1)
  1072df:	39 df                	cmp    %ebx,%edi
  1072e1:	0f 86 b9 00 00 00    	jbe    1073a0 <__umoddi3+0xe0>
	  udiv_qrnnd (q0, n0, n1, n0, d0);
  1072e7:	f7 f7                	div    %edi
	  *rp = rr.ll;
  1072e9:	89 d0                	mov    %edx,%eax
  1072eb:	31 d2                	xor    %edx,%edx
}
  1072ed:	83 c4 1c             	add    $0x1c,%esp
  1072f0:	5b                   	pop    %ebx
  1072f1:	5e                   	pop    %esi
  1072f2:	5f                   	pop    %edi
  1072f3:	5d                   	pop    %ebp
  1072f4:	c3                   	ret    
  1072f5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  1072f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
      if (d1 > n1)
  107300:	39 dd                	cmp    %ebx,%ebp
  107302:	77 e9                	ja     1072ed <__umoddi3+0x2d>
	  count_leading_zeros (bm, d1);
  107304:	0f bd cd             	bsr    %ebp,%ecx
	  if (bm == 0)
  107307:	83 f1 1f             	xor    $0x1f,%ecx
  10730a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10730e:	0f 84 ac 00 00 00    	je     1073c0 <__umoddi3+0x100>
	      b = W_TYPE_SIZE - bm;
  107314:	b8 20 00 00 00       	mov    $0x20,%eax
  107319:	89 c2                	mov    %eax,%edx
  10731b:	8b 44 24 04          	mov    0x4(%esp),%eax
  10731f:	29 c2                	sub    %eax,%edx
	      d1 = (d1 << bm) | (d0 >> b);
  107321:	89 c1                	mov    %eax,%ecx
  107323:	89 f8                	mov    %edi,%eax
  107325:	d3 e5                	shl    %cl,%ebp
  107327:	89 d1                	mov    %edx,%ecx
	      b = W_TYPE_SIZE - bm;
  107329:	89 54 24 0c          	mov    %edx,0xc(%esp)
	      d1 = (d1 << bm) | (d0 >> b);
  10732d:	d3 e8                	shr    %cl,%eax
  10732f:	09 c5                	or     %eax,%ebp
	      d0 = d0 << bm;
  107331:	8b 44 24 04          	mov    0x4(%esp),%eax
  107335:	89 c1                	mov    %eax,%ecx
  107337:	d3 e7                	shl    %cl,%edi
	      n2 = n1 >> b;
  107339:	89 d1                	mov    %edx,%ecx
	      d0 = d0 << bm;
  10733b:	89 7c 24 08          	mov    %edi,0x8(%esp)
	      n2 = n1 >> b;
  10733f:	89 df                	mov    %ebx,%edi
  107341:	d3 ef                	shr    %cl,%edi
	      n1 = (n1 << bm) | (n0 >> b);
  107343:	89 c1                	mov    %eax,%ecx
  107345:	89 f0                	mov    %esi,%eax
  107347:	d3 e3                	shl    %cl,%ebx
  107349:	89 d1                	mov    %edx,%ecx
	      udiv_qrnnd (q0, n1, n2, n1, d1);
  10734b:	89 fa                	mov    %edi,%edx
	      n1 = (n1 << bm) | (n0 >> b);
  10734d:	d3 e8                	shr    %cl,%eax
	      n0 = n0 << bm;
  10734f:	0f b6 4c 24 04       	movzbl 0x4(%esp),%ecx
	      n1 = (n1 << bm) | (n0 >> b);
  107354:	09 d8                	or     %ebx,%eax
	      udiv_qrnnd (q0, n1, n2, n1, d1);
  107356:	f7 f5                	div    %ebp
	      n0 = n0 << bm;
  107358:	d3 e6                	shl    %cl,%esi
	      udiv_qrnnd (q0, n1, n2, n1, d1);
  10735a:	89 d1                	mov    %edx,%ecx
	      umul_ppmm (m1, m0, q0, d0);
  10735c:	f7 64 24 08          	mull   0x8(%esp)
	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  107360:	39 d1                	cmp    %edx,%ecx
	      umul_ppmm (m1, m0, q0, d0);
  107362:	89 c3                	mov    %eax,%ebx
  107364:	89 d7                	mov    %edx,%edi
	      if (m1 > n1 || (m1 == n1 && m0 > n0))
  107366:	72 06                	jb     10736e <__umoddi3+0xae>
  107368:	75 0e                	jne    107378 <__umoddi3+0xb8>
  10736a:	39 c6                	cmp    %eax,%esi
  10736c:	73 0a                	jae    107378 <__umoddi3+0xb8>
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
  10736e:	2b 44 24 08          	sub    0x8(%esp),%eax
  107372:	19 ea                	sbb    %ebp,%edx
  107374:	89 d7                	mov    %edx,%edi
  107376:	89 c3                	mov    %eax,%ebx
		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
  107378:	89 ca                	mov    %ecx,%edx
		  rr.s.low = (n1 << b) | (n0 >> bm);
  10737a:	0f b6 4c 24 0c       	movzbl 0xc(%esp),%ecx
		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
  10737f:	29 de                	sub    %ebx,%esi
  107381:	19 fa                	sbb    %edi,%edx
		  rr.s.low = (n1 << b) | (n0 >> bm);
  107383:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  107387:	89 d0                	mov    %edx,%eax
  107389:	d3 e0                	shl    %cl,%eax
  10738b:	89 d9                	mov    %ebx,%ecx
  10738d:	d3 ee                	shr    %cl,%esi
		  *rp = rr.ll;
  10738f:	d3 ea                	shr    %cl,%edx
  107391:	09 f0                	or     %esi,%eax
}
  107393:	83 c4 1c             	add    $0x1c,%esp
  107396:	5b                   	pop    %ebx
  107397:	5e                   	pop    %esi
  107398:	5f                   	pop    %edi
  107399:	5d                   	pop    %ebp
  10739a:	c3                   	ret    
  10739b:	90                   	nop
  10739c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	  if (d0 == 0)
  1073a0:	85 ff                	test   %edi,%edi
  1073a2:	89 f9                	mov    %edi,%ecx
  1073a4:	75 0b                	jne    1073b1 <__umoddi3+0xf1>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
  1073a6:	b8 01 00 00 00       	mov    $0x1,%eax
  1073ab:	31 d2                	xor    %edx,%edx
  1073ad:	f7 f7                	div    %edi
  1073af:	89 c1                	mov    %eax,%ecx
	  udiv_qrnnd (q1, n1, 0, n1, d0);
  1073b1:	89 d8                	mov    %ebx,%eax
  1073b3:	31 d2                	xor    %edx,%edx
  1073b5:	f7 f1                	div    %ecx
	  udiv_qrnnd (q0, n0, n1, n0, d0);
  1073b7:	89 f0                	mov    %esi,%eax
  1073b9:	f7 f1                	div    %ecx
  1073bb:	e9 29 ff ff ff       	jmp    1072e9 <__umoddi3+0x29>
	      if (n1 > d1 || n0 >= d0)
  1073c0:	39 dd                	cmp    %ebx,%ebp
  1073c2:	72 08                	jb     1073cc <__umoddi3+0x10c>
  1073c4:	39 f7                	cmp    %esi,%edi
  1073c6:	0f 87 21 ff ff ff    	ja     1072ed <__umoddi3+0x2d>
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
  1073cc:	89 da                	mov    %ebx,%edx
  1073ce:	89 f0                	mov    %esi,%eax
  1073d0:	29 f8                	sub    %edi,%eax
  1073d2:	19 ea                	sbb    %ebp,%edx
  1073d4:	e9 14 ff ff ff       	jmp    1072ed <__umoddi3+0x2d>

Déassemblage de la section .text._ZZ3logPKczENKUlPvcE_clES1_c :

001073da <_ZZ3logPKczENKUlPvcE_clES1_c>:
{
    printf("[%f] ", uptime());

    va_list va;
    va_start(va, fmt);
    tfp_format(nullptr, [](void*, char c){putchar(c);}, fmt, va);
  1073da:	83 ec 1c             	sub    $0x1c,%esp
  1073dd:	8b 44 24 28          	mov    0x28(%esp),%eax
  1073e1:	88 44 24 0c          	mov    %al,0xc(%esp)
  1073e5:	0f be 44 24 0c       	movsbl 0xc(%esp),%eax
  1073ea:	83 ec 0c             	sub    $0xc,%esp
  1073ed:	50                   	push   %eax
  1073ee:	e8 05 fc ff ff       	call   106ff8 <putchar>
  1073f3:	83 c4 10             	add    $0x10,%esp
  1073f6:	90                   	nop
  1073f7:	83 c4 1c             	add    $0x1c,%esp
  1073fa:	c3                   	ret    

Déassemblage de la section .text._ZZ3logPKczENUlPvcE_4_FUNES1_c :

001073fb <_ZZ3logPKczENUlPvcE_4_FUNES1_c>:
  1073fb:	83 ec 1c             	sub    $0x1c,%esp
  1073fe:	8b 44 24 24          	mov    0x24(%esp),%eax
  107402:	88 44 24 0c          	mov    %al,0xc(%esp)
  107406:	83 ec 04             	sub    $0x4,%esp
  107409:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
  10740e:	50                   	push   %eax
  10740f:	ff 74 24 28          	pushl  0x28(%esp)
  107413:	6a 00                	push   $0x0
  107415:	e8 c0 ff ff ff       	call   1073da <_ZZ3logPKczENKUlPvcE_clES1_c>
  10741a:	83 c4 10             	add    $0x10,%esp
  10741d:	83 c4 1c             	add    $0x1c,%esp
  107420:	c3                   	ret    

Déassemblage de la section .text._ZZ3logPKczENKUlPvcE_cvPFvS1_cEEv :

00107422 <_ZZ3logPKczENKUlPvcE_cvPFvS1_cEEv>:
  107422:	b8 fb 73 10 00       	mov    $0x1073fb,%eax
  107427:	c3                   	ret    

Déassemblage de la section .text._Z3logPKcz :

00107428 <_Z3logPKcz>:
{
  107428:	53                   	push   %ebx
  107429:	83 ec 18             	sub    $0x18,%esp
    printf("[%f] ", uptime());
  10742c:	e8 3f b9 ff ff       	call   102d70 <_Z6uptimev>
  107431:	83 ec 04             	sub    $0x4,%esp
  107434:	8d 64 24 f8          	lea    -0x8(%esp),%esp
  107438:	dd 1c 24             	fstpl  (%esp)
  10743b:	68 38 80 10 00       	push   $0x108038
  107440:	e8 8d f4 ff ff       	call   1068d2 <tfp_printf>
  107445:	83 c4 10             	add    $0x10,%esp
    va_start(va, fmt);
  107448:	8d 44 24 24          	lea    0x24(%esp),%eax
  10744c:	89 44 24 08          	mov    %eax,0x8(%esp)
    tfp_format(nullptr, [](void*, char c){putchar(c);}, fmt, va);
  107450:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  107454:	83 ec 0c             	sub    $0xc,%esp
  107457:	8d 44 24 1b          	lea    0x1b(%esp),%eax
  10745b:	50                   	push   %eax
  10745c:	e8 c1 ff ff ff       	call   107422 <_ZZ3logPKczENKUlPvcE_cvPFvS1_cEEv>
  107461:	83 c4 10             	add    $0x10,%esp
  107464:	53                   	push   %ebx
  107465:	ff 74 24 24          	pushl  0x24(%esp)
  107469:	50                   	push   %eax
  10746a:	6a 00                	push   $0x0
  10746c:	e8 95 ee ff ff       	call   106306 <tfp_format>
  107471:	83 c4 10             	add    $0x10,%esp
    va_end(va);
}
  107474:	90                   	nop
  107475:	83 c4 18             	add    $0x18,%esp
  107478:	5b                   	pop    %ebx
  107479:	c3                   	ret    

Déassemblage de la section .text._Z9bit_checkImEbRT_m :

0010747a <_Z9bit_checkImEbRT_m>:
}

template <typename T>
inline bool bit_check(T& val, size_t pos)
{
    return (val >> pos) & 1;
  10747a:	8b 44 24 04          	mov    0x4(%esp),%eax
  10747e:	8b 10                	mov    (%eax),%edx
  107480:	8b 44 24 08          	mov    0x8(%esp),%eax
  107484:	89 c1                	mov    %eax,%ecx
  107486:	d3 ea                	shr    %cl,%edx
  107488:	89 d0                	mov    %edx,%eax
  10748a:	83 e0 01             	and    $0x1,%eax
  10748d:	85 c0                	test   %eax,%eax
  10748f:	0f 95 c0             	setne  %al
}
  107492:	c3                   	ret    

Déassemblage de la section .text._Z4sizeIN3gdt5entryELm6EEmRAT0__T_ :

00107493 <_Z4sizeIN3gdt5entryELm6EEmRAT0__T_>:
#define ARRAY_HPP

#include "utils/stdint.h"

template<class T, size_t N>
constexpr size_t size(T (&)[N]) { return N; }
  107493:	b8 06 00 00 00       	mov    $0x6,%eax
  107498:	c3                   	ret    

Déassemblage de la section .text._Z3stiv :

00107499 <_Z3stiv>:
    asm volatile ("cli");
}

inline void sti()
{
    asm volatile ("sti");
  107499:	fb                   	sti    
}
  10749a:	90                   	nop
  10749b:	c3                   	ret    

Déassemblage de la section .text._Z4sizeIN3idt5entryELm256EEmRAT0__T_ :

0010749c <_Z4sizeIN3idt5entryELm256EEmRAT0__T_>:
  10749c:	b8 00 01 00 00       	mov    $0x100,%eax
  1074a1:	c3                   	ret    

Déassemblage de la section .text._Z3cr0v :

001074a2 <_Z3cr0v>:
    uint32_t esp;
    uint32_t ss;
} __attribute__((packed));

inline uint32_t cr0()
{
  1074a2:	83 ec 10             	sub    $0x10,%esp
    uint32_t out;
    asm volatile("mov %%cr0, %[var]" : [var] "=r" (out));
  1074a5:	0f 20 c0             	mov    %cr0,%eax
  1074a8:	89 44 24 0c          	mov    %eax,0xc(%esp)
    return out;
  1074ac:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  1074b0:	83 c4 10             	add    $0x10,%esp
  1074b3:	c3                   	ret    

Déassemblage de la section .text._Z3cr2v :

001074b4 <_Z3cr2v>:
inline uint32_t cr2()
{
  1074b4:	83 ec 10             	sub    $0x10,%esp
    uint32_t out;
    asm volatile("mov %%cr2, %[var]" : [var] "=r" (out));
  1074b7:	0f 20 d0             	mov    %cr2,%eax
  1074ba:	89 44 24 0c          	mov    %eax,0xc(%esp)
    return out;
  1074be:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  1074c2:	83 c4 10             	add    $0x10,%esp
  1074c5:	c3                   	ret    

Déassemblage de la section .text._Z3cr3v :

001074c6 <_Z3cr3v>:
inline uint32_t cr3()
{
  1074c6:	83 ec 10             	sub    $0x10,%esp
    uint32_t out;
    asm volatile("mov %%cr3, %[var]" : [var] "=r" (out));
  1074c9:	0f 20 d8             	mov    %cr3,%eax
  1074cc:	89 44 24 0c          	mov    %eax,0xc(%esp)
    return out;
  1074d0:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  1074d4:	83 c4 10             	add    $0x10,%esp
  1074d7:	c3                   	ret    

Déassemblage de la section .text._Z3cr4v :

001074d8 <_Z3cr4v>:
inline uint32_t cr4()
{
  1074d8:	83 ec 10             	sub    $0x10,%esp
    uint32_t out;
    asm volatile("mov %%cr4, %[var]" : [var] "=r" (out));
  1074db:	0f 20 e0             	mov    %cr4,%eax
  1074de:	89 44 24 0c          	mov    %eax,0xc(%esp)
    return out;
  1074e2:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
  1074e6:	83 c4 10             	add    $0x10,%esp
  1074e9:	c3                   	ret    

Déassemblage de la section .text._Z4dumpPK9registers :

001074ea <_Z4dumpPK9registers>:


inline void dump(const registers* regs)
{
  1074ea:	53                   	push   %ebx
  1074eb:	83 ec 08             	sub    $0x8,%esp

    printf("eip : 0x%x\n", regs->eip);
  1074ee:	8b 44 24 10          	mov    0x10(%esp),%eax
  1074f2:	8b 40 34             	mov    0x34(%eax),%eax
  1074f5:	83 ec 08             	sub    $0x8,%esp
  1074f8:	50                   	push   %eax
  1074f9:	68 a4 87 10 00       	push   $0x1087a4
  1074fe:	e8 cf f3 ff ff       	call   1068d2 <tfp_printf>
  107503:	83 c4 10             	add    $0x10,%esp

    printf("eax : 0x%x  ebx : 0x%x\n", regs->eax, regs->ebx);
  107506:	8b 44 24 10          	mov    0x10(%esp),%eax
  10750a:	8b 50 1c             	mov    0x1c(%eax),%edx
  10750d:	8b 44 24 10          	mov    0x10(%esp),%eax
  107511:	8b 40 10             	mov    0x10(%eax),%eax
  107514:	83 ec 04             	sub    $0x4,%esp
  107517:	52                   	push   %edx
  107518:	50                   	push   %eax
  107519:	68 b0 87 10 00       	push   $0x1087b0
  10751e:	e8 af f3 ff ff       	call   1068d2 <tfp_printf>
  107523:	83 c4 10             	add    $0x10,%esp

    printf("ecx : 0x%x  edx : 0x%x\n", regs->ecx, regs->edx);
  107526:	8b 44 24 10          	mov    0x10(%esp),%eax
  10752a:	8b 50 18             	mov    0x18(%eax),%edx
  10752d:	8b 44 24 10          	mov    0x10(%esp),%eax
  107531:	8b 40 14             	mov    0x14(%eax),%eax
  107534:	83 ec 04             	sub    $0x4,%esp
  107537:	52                   	push   %edx
  107538:	50                   	push   %eax
  107539:	68 c8 87 10 00       	push   $0x1087c8
  10753e:	e8 8f f3 ff ff       	call   1068d2 <tfp_printf>
  107543:	83 c4 10             	add    $0x10,%esp
    printf("ebx : 0x%x  esi : 0x%x\n", regs->ebp, regs->esi);
  107546:	8b 44 24 10          	mov    0x10(%esp),%eax
  10754a:	8b 50 24             	mov    0x24(%eax),%edx
  10754d:	8b 44 24 10          	mov    0x10(%esp),%eax
  107551:	8b 40 20             	mov    0x20(%eax),%eax
  107554:	83 ec 04             	sub    $0x4,%esp
  107557:	52                   	push   %edx
  107558:	50                   	push   %eax
  107559:	68 e0 87 10 00       	push   $0x1087e0
  10755e:	e8 6f f3 ff ff       	call   1068d2 <tfp_printf>
  107563:	83 c4 10             	add    $0x10,%esp
    printf("edi : 0x%x\n\n", regs->edi);
  107566:	8b 44 24 10          	mov    0x10(%esp),%eax
  10756a:	8b 40 28             	mov    0x28(%eax),%eax
  10756d:	83 ec 08             	sub    $0x8,%esp
  107570:	50                   	push   %eax
  107571:	68 f8 87 10 00       	push   $0x1087f8
  107576:	e8 57 f3 ff ff       	call   1068d2 <tfp_printf>
  10757b:	83 c4 10             	add    $0x10,%esp

    printf("cr0 : 0x%x  cr2 : 0x%x\n", cr0(), cr2());
  10757e:	e8 31 ff ff ff       	call   1074b4 <_Z3cr2v>
  107583:	89 c3                	mov    %eax,%ebx
  107585:	e8 18 ff ff ff       	call   1074a2 <_Z3cr0v>
  10758a:	83 ec 04             	sub    $0x4,%esp
  10758d:	53                   	push   %ebx
  10758e:	50                   	push   %eax
  10758f:	68 05 88 10 00       	push   $0x108805
  107594:	e8 39 f3 ff ff       	call   1068d2 <tfp_printf>
  107599:	83 c4 10             	add    $0x10,%esp
    printf("cr3 : 0x%x  cr4 : 0x%x\n\n", cr3(), cr4());
  10759c:	e8 37 ff ff ff       	call   1074d8 <_Z3cr4v>
  1075a1:	89 c3                	mov    %eax,%ebx
  1075a3:	e8 1e ff ff ff       	call   1074c6 <_Z3cr3v>
  1075a8:	83 ec 04             	sub    $0x4,%esp
  1075ab:	53                   	push   %ebx
  1075ac:	50                   	push   %eax
  1075ad:	68 1d 88 10 00       	push   $0x10881d
  1075b2:	e8 1b f3 ff ff       	call   1068d2 <tfp_printf>
  1075b7:	83 c4 10             	add    $0x10,%esp

    printf("gs : 0x%x  fs : 0x%x\n", regs->gs, regs->fs);
  1075ba:	8b 44 24 10          	mov    0x10(%esp),%eax
  1075be:	8b 50 04             	mov    0x4(%eax),%edx
  1075c1:	8b 44 24 10          	mov    0x10(%esp),%eax
  1075c5:	8b 00                	mov    (%eax),%eax
  1075c7:	83 ec 04             	sub    $0x4,%esp
  1075ca:	52                   	push   %edx
  1075cb:	50                   	push   %eax
  1075cc:	68 36 88 10 00       	push   $0x108836
  1075d1:	e8 fc f2 ff ff       	call   1068d2 <tfp_printf>
  1075d6:	83 c4 10             	add    $0x10,%esp
    printf("es : 0x%x  ds : 0x%x\n\n", regs->es, regs->ds);
  1075d9:	8b 44 24 10          	mov    0x10(%esp),%eax
  1075dd:	8b 50 0c             	mov    0xc(%eax),%edx
  1075e0:	8b 44 24 10          	mov    0x10(%esp),%eax
  1075e4:	8b 40 08             	mov    0x8(%eax),%eax
  1075e7:	83 ec 04             	sub    $0x4,%esp
  1075ea:	52                   	push   %edx
  1075eb:	50                   	push   %eax
  1075ec:	68 4c 88 10 00       	push   $0x10884c
  1075f1:	e8 dc f2 ff ff       	call   1068d2 <tfp_printf>
  1075f6:	83 c4 10             	add    $0x10,%esp

    printf("cs : 0x%x  eflags : 0x%x\n", regs->cs, regs->eflags);
  1075f9:	8b 44 24 10          	mov    0x10(%esp),%eax
  1075fd:	8b 50 3c             	mov    0x3c(%eax),%edx
  107600:	8b 44 24 10          	mov    0x10(%esp),%eax
  107604:	8b 40 38             	mov    0x38(%eax),%eax
  107607:	83 ec 04             	sub    $0x4,%esp
  10760a:	52                   	push   %edx
  10760b:	50                   	push   %eax
  10760c:	68 63 88 10 00       	push   $0x108863
  107611:	e8 bc f2 ff ff       	call   1068d2 <tfp_printf>
  107616:	83 c4 10             	add    $0x10,%esp
    printf("ss : 0x%x  esp : 0x%x\n", regs->ss, regs->esp);
  107619:	8b 44 24 10          	mov    0x10(%esp),%eax
  10761d:	8b 50 40             	mov    0x40(%eax),%edx
  107620:	8b 44 24 10          	mov    0x10(%esp),%eax
  107624:	8b 40 44             	mov    0x44(%eax),%eax
  107627:	83 ec 04             	sub    $0x4,%esp
  10762a:	52                   	push   %edx
  10762b:	50                   	push   %eax
  10762c:	68 7d 88 10 00       	push   $0x10887d
  107631:	e8 9c f2 ff ff       	call   1068d2 <tfp_printf>
  107636:	83 c4 10             	add    $0x10,%esp
}
  107639:	90                   	nop
  10763a:	83 c4 08             	add    $0x8,%esp
  10763d:	5b                   	pop    %ebx
  10763e:	c3                   	ret    

Déassemblage de la section .text._Z4physm :

0010763f <_Z4physm>:

static constexpr uintptr_t kernel_virtual_base { 0x00000000 };

inline uintptr_t phys(uintptr_t ptr)
{
    return kernel_virtual_base + ptr;
  10763f:	8b 44 24 04          	mov    0x4(%esp),%eax
}
  107643:	c3                   	ret    

Déassemblage de la section .text._Z4virtm :

00107644 <_Z4virtm>:

inline uintptr_t virt(uintptr_t ptr)
{
    return ptr - kernel_virtual_base;
  107644:	8b 44 24 04          	mov    0x4(%esp),%eax
}
  107648:	c3                   	ret    

Déassemblage de la section .text._ZN8Terminal10push_colorEh :

00107649 <_ZN8Terminal10push_colorEh>:
    static void push_color(uint8_t color) { impl.push_color(color); }
  107649:	83 ec 1c             	sub    $0x1c,%esp
  10764c:	8b 44 24 20          	mov    0x20(%esp),%eax
  107650:	88 44 24 0c          	mov    %al,0xc(%esp)
  107654:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  107659:	83 ec 08             	sub    $0x8,%esp
  10765c:	50                   	push   %eax
  10765d:	68 60 53 11 00       	push   $0x115360
  107662:	e8 91 be ff ff       	call   1034f8 <_ZN6detail12TerminalImpl10push_colorEh>
  107667:	83 c4 10             	add    $0x10,%esp
  10766a:	90                   	nop
  10766b:	83 c4 1c             	add    $0x1c,%esp
  10766e:	c3                   	ret    

Déassemblage de la section .text._ZN8Terminal9pop_colorEv :

0010766f <_ZN8Terminal9pop_colorEv>:
    static void pop_color() { impl.pop_color(); }
  10766f:	83 ec 0c             	sub    $0xc,%esp
  107672:	83 ec 0c             	sub    $0xc,%esp
  107675:	68 60 53 11 00       	push   $0x115360
  10767a:	e8 a9 be ff ff       	call   103528 <_ZN6detail12TerminalImpl9pop_colorEv>
  10767f:	83 c4 10             	add    $0x10,%esp
  107682:	90                   	nop
  107683:	83 c4 0c             	add    $0xc,%esp
  107686:	c3                   	ret    

Déassemblage de la section .text._ZZ4warnPKczENKUlPvcE_clES1_c :

00107688 <_ZZ4warnPKczENKUlPvcE_clES1_c>:

    printf("[%f] ", uptime());

    va_list va;
    va_start(va, fmt);
    tfp_format(nullptr, [](void*, char c){putchar(c);}, fmt, va);
  107688:	83 ec 1c             	sub    $0x1c,%esp
  10768b:	8b 44 24 28          	mov    0x28(%esp),%eax
  10768f:	88 44 24 0c          	mov    %al,0xc(%esp)
  107693:	0f be 44 24 0c       	movsbl 0xc(%esp),%eax
  107698:	83 ec 0c             	sub    $0xc,%esp
  10769b:	50                   	push   %eax
  10769c:	e8 57 f9 ff ff       	call   106ff8 <putchar>
  1076a1:	83 c4 10             	add    $0x10,%esp
  1076a4:	90                   	nop
  1076a5:	83 c4 1c             	add    $0x1c,%esp
  1076a8:	c3                   	ret    

Déassemblage de la section .text._ZZ4warnPKczENUlPvcE_4_FUNES1_c :

001076a9 <_ZZ4warnPKczENUlPvcE_4_FUNES1_c>:
  1076a9:	83 ec 1c             	sub    $0x1c,%esp
  1076ac:	8b 44 24 24          	mov    0x24(%esp),%eax
  1076b0:	88 44 24 0c          	mov    %al,0xc(%esp)
  1076b4:	83 ec 04             	sub    $0x4,%esp
  1076b7:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
  1076bc:	50                   	push   %eax
  1076bd:	ff 74 24 28          	pushl  0x28(%esp)
  1076c1:	6a 00                	push   $0x0
  1076c3:	e8 c0 ff ff ff       	call   107688 <_ZZ4warnPKczENKUlPvcE_clES1_c>
  1076c8:	83 c4 10             	add    $0x10,%esp
  1076cb:	83 c4 1c             	add    $0x1c,%esp
  1076ce:	c3                   	ret    

Déassemblage de la section .text._ZZ4warnPKczENKUlPvcE_cvPFvS1_cEEv :

001076d0 <_ZZ4warnPKczENKUlPvcE_cvPFvS1_cEEv>:
  1076d0:	b8 a9 76 10 00       	mov    $0x1076a9,%eax
  1076d5:	c3                   	ret    

Déassemblage de la section .text._Z4warnPKcz :

001076d6 <_Z4warnPKcz>:
{
  1076d6:	53                   	push   %ebx
  1076d7:	83 ec 18             	sub    $0x18,%esp
    Terminal::push_color(VGA_COLOR_LIGHT_RED);
  1076da:	83 ec 0c             	sub    $0xc,%esp
  1076dd:	6a 0c                	push   $0xc
  1076df:	e8 65 ff ff ff       	call   107649 <_ZN8Terminal10push_colorEh>
  1076e4:	83 c4 10             	add    $0x10,%esp
    printf("[%f] ", uptime());
  1076e7:	e8 84 b6 ff ff       	call   102d70 <_Z6uptimev>
  1076ec:	83 ec 04             	sub    $0x4,%esp
  1076ef:	8d 64 24 f8          	lea    -0x8(%esp),%esp
  1076f3:	dd 1c 24             	fstpl  (%esp)
  1076f6:	68 04 89 10 00       	push   $0x108904
  1076fb:	e8 d2 f1 ff ff       	call   1068d2 <tfp_printf>
  107700:	83 c4 10             	add    $0x10,%esp
    va_start(va, fmt);
  107703:	8d 44 24 24          	lea    0x24(%esp),%eax
  107707:	89 44 24 08          	mov    %eax,0x8(%esp)
    tfp_format(nullptr, [](void*, char c){putchar(c);}, fmt, va);
  10770b:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  10770f:	83 ec 0c             	sub    $0xc,%esp
  107712:	8d 44 24 1b          	lea    0x1b(%esp),%eax
  107716:	50                   	push   %eax
  107717:	e8 b4 ff ff ff       	call   1076d0 <_ZZ4warnPKczENKUlPvcE_cvPFvS1_cEEv>
  10771c:	83 c4 10             	add    $0x10,%esp
  10771f:	53                   	push   %ebx
  107720:	ff 74 24 24          	pushl  0x24(%esp)
  107724:	50                   	push   %eax
  107725:	6a 00                	push   $0x0
  107727:	e8 da eb ff ff       	call   106306 <tfp_format>
  10772c:	83 c4 10             	add    $0x10,%esp
    va_end(va);

    Terminal::pop_color();
  10772f:	e8 3b ff ff ff       	call   10766f <_ZN8Terminal9pop_colorEv>
}
  107734:	90                   	nop
  107735:	83 c4 18             	add    $0x18,%esp
  107738:	5b                   	pop    %ebx
  107739:	c3                   	ret    

Déassemblage de la section .text._Z9bit_checkIhEbRT_m :

0010773a <_Z9bit_checkIhEbRT_m>:
    return (val >> pos) & 1;
  10773a:	8b 44 24 04          	mov    0x4(%esp),%eax
  10773e:	0f b6 00             	movzbl (%eax),%eax
  107741:	0f b6 d0             	movzbl %al,%edx
  107744:	8b 44 24 08          	mov    0x8(%esp),%eax
  107748:	89 c1                	mov    %eax,%ecx
  10774a:	d3 fa                	sar    %cl,%edx
  10774c:	89 d0                	mov    %edx,%eax
  10774e:	83 e0 01             	and    $0x1,%eax
  107751:	85 c0                	test   %eax,%eax
  107753:	0f 95 c0             	setne  %al
}
  107756:	c3                   	ret    

Déassemblage de la section .text._Z5rdtscv :

00107757 <_Z5rdtscv>:
#define TIMESTAMP_HPP

#include "utils/stdint.h"

inline uint64_t rdtsc()
{
  107757:	83 ec 14             	sub    $0x14,%esp
    uint64_t ret;
    asm volatile ( "rdtsc" : "=A"(ret) );
  10775a:	0f 31                	rdtsc  
  10775c:	89 44 24 08          	mov    %eax,0x8(%esp)
  107760:	89 54 24 0c          	mov    %edx,0xc(%esp)
    return ret;
  107764:	8b 44 24 08          	mov    0x8(%esp),%eax
  107768:	8b 54 24 0c          	mov    0xc(%esp),%edx
}
  10776c:	83 c4 14             	add    $0x14,%esp
  10776f:	c3                   	ret    

Déassemblage de la section .text._ZN5Timer5ticksEv :

00107770 <_ZN5Timer5ticksEv>:
        while (m_ticks < interval) { NOP(); }
    }

    static inline uint32_t ticks()
    {
        return m_ticks;
  107770:	a1 d4 ef 11 00       	mov    0x11efd4,%eax
    }
  107775:	c3                   	ret    

Déassemblage de la section .text._ZN5Timer4freqEv :

00107776 <_ZN5Timer4freqEv>:

    static inline uint32_t freq()
    {
        return m_freq;
  107776:	a1 d8 ef 11 00       	mov    0x11efd8,%eax
    }
  10777b:	c3                   	ret    

Déassemblage de la section .text._Z11clock_speedb :

0010777c <_Z11clock_speedb>:
#include "nop.hpp"
#include "timer.hpp"

// in Mhz
inline uint64_t clock_speed(bool recompute = false)
{
  10777c:	53                   	push   %ebx
  10777d:	83 ec 38             	sub    $0x38,%esp
  107780:	8b 44 24 40          	mov    0x40(%esp),%eax
  107784:	88 44 24 0c          	mov    %al,0xc(%esp)
    static uint64_t speed;
    static bool computed = false;
    if (computed && !recompute)
  107788:	0f b6 05 e8 ef 11 00 	movzbl 0x11efe8,%eax
  10778f:	84 c0                	test   %al,%al
  107791:	74 1c                	je     1077af <_Z11clock_speedb+0x33>
  107793:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  107798:	83 f0 01             	xor    $0x1,%eax
  10779b:	84 c0                	test   %al,%al
  10779d:	74 10                	je     1077af <_Z11clock_speedb+0x33>
    {
        return speed;
  10779f:	a1 e0 ef 11 00       	mov    0x11efe0,%eax
  1077a4:	8b 15 e4 ef 11 00    	mov    0x11efe4,%edx
  1077aa:	e9 9d 00 00 00       	jmp    10784c <_Z11clock_speedb+0xd0>
    }

    const uint32_t step { 10 };
  1077af:	c7 44 24 2c 0a 00 00 	movl   $0xa,0x2c(%esp)
  1077b6:	00 

    uint64_t current = rdtsc();
  1077b7:	e8 9b ff ff ff       	call   107757 <_Z5rdtscv>
  1077bc:	89 44 24 20          	mov    %eax,0x20(%esp)
  1077c0:	89 54 24 24          	mov    %edx,0x24(%esp)
    uint32_t ticks = Timer::ticks();
  1077c4:	e8 a7 ff ff ff       	call   107770 <_ZN5Timer5ticksEv>
  1077c9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    while (ticks + step > Timer::ticks()) { NOP(); } // wait 'til a tick is elapsed
  1077cd:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  1077d1:	8d 58 0a             	lea    0xa(%eax),%ebx
  1077d4:	e8 97 ff ff ff       	call   107770 <_ZN5Timer5ticksEv>
  1077d9:	39 c3                	cmp    %eax,%ebx
  1077db:	0f 97 c0             	seta   %al
  1077de:	84 c0                	test   %al,%al
  1077e0:	74 03                	je     1077e5 <_Z11clock_speedb+0x69>
  1077e2:	90                   	nop
  1077e3:	eb e8                	jmp    1077cd <_Z11clock_speedb+0x51>

    uint64_t elapsed = rdtsc() - current;
  1077e5:	e8 6d ff ff ff       	call   107757 <_Z5rdtscv>
  1077ea:	2b 44 24 20          	sub    0x20(%esp),%eax
  1077ee:	1b 54 24 24          	sbb    0x24(%esp),%edx
  1077f2:	89 44 24 10          	mov    %eax,0x10(%esp)
  1077f6:	89 54 24 14          	mov    %edx,0x14(%esp)
    speed = elapsed*Timer::freq()/1'000'000/step;
  1077fa:	e8 77 ff ff ff       	call   107776 <_ZN5Timer4freqEv>
  1077ff:	ba 00 00 00 00       	mov    $0x0,%edx
  107804:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  107808:	89 cb                	mov    %ecx,%ebx
  10780a:	0f af da             	imul   %edx,%ebx
  10780d:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  107811:	0f af c8             	imul   %eax,%ecx
  107814:	01 d9                	add    %ebx,%ecx
  107816:	f7 64 24 10          	mull   0x10(%esp)
  10781a:	01 d1                	add    %edx,%ecx
  10781c:	89 ca                	mov    %ecx,%edx
  10781e:	6a 00                	push   $0x0
  107820:	68 80 96 98 00       	push   $0x989680
  107825:	52                   	push   %edx
  107826:	50                   	push   %eax
  107827:	e8 64 f9 ff ff       	call   107190 <__udivdi3>
  10782c:	83 c4 10             	add    $0x10,%esp
  10782f:	a3 e0 ef 11 00       	mov    %eax,0x11efe0
  107834:	89 15 e4 ef 11 00    	mov    %edx,0x11efe4
    computed = true;
  10783a:	c6 05 e8 ef 11 00 01 	movb   $0x1,0x11efe8
    return speed; // MHz
  107841:	a1 e0 ef 11 00       	mov    0x11efe0,%eax
  107846:	8b 15 e4 ef 11 00    	mov    0x11efe4,%edx
}
  10784c:	83 c4 38             	add    $0x38,%esp
  10784f:	5b                   	pop    %ebx
  107850:	c3                   	ret    

Déassemblage de la section .text._Z7isprintDi :

00107851 <_Z7isprintDi>:
inline bool isdigit(char32_t c)  { return ASCIIRANGE(c, 0x30, 10); }
inline bool isbdigit(char32_t c) { return ASCIIRANGE(c, 0x30,  2); }
inline bool isodigit(char32_t c) { return ASCIIRANGE(c, 0x30,  8); }
inline bool isxdigit(char32_t c) { return ASCIIRANGE(c | 32, 0x61, 6) || isdigit(c); }
inline bool isalpha(char32_t c)  { return ASCIIRANGE(c | 32, 0x61, 26); }
inline bool isprint(char32_t c)  { return ASCIIRANGE(c, 0x20, 95) || ASCIIRANGE(c, 128, 127); }
  107851:	8b 44 24 04          	mov    0x4(%esp),%eax
  107855:	83 e8 20             	sub    $0x20,%eax
  107858:	83 f8 5e             	cmp    $0x5e,%eax
  10785b:	76 0c                	jbe    107869 <_Z7isprintDi+0x18>
  10785d:	8b 44 24 04          	mov    0x4(%esp),%eax
  107861:	83 c0 80             	add    $0xffffff80,%eax
  107864:	83 f8 7e             	cmp    $0x7e,%eax
  107867:	77 06                	ja     10786f <_Z7isprintDi+0x1e>
  107869:	b8 01 00 00 00       	mov    $0x1,%eax
  10786e:	c3                   	ret    
  10786f:	b8 00 00 00 00       	mov    $0x0,%eax
  107874:	90                   	nop
  107875:	c3                   	ret    

Déassemblage de la section .text._ZN14CircularBufferIA80_tLm250EEC2Ev :

00107876 <_ZN14CircularBufferIA80_tLm250EEC1Ev>:
};

template<typename T, size_t Size>
CircularBuffer<T, Size>::CircularBuffer()
    : _front(0)
    , _full(false)
  107876:	8b 44 24 04          	mov    0x4(%esp),%eax
  10787a:	c7 80 40 9c 00 00 00 	movl   $0x0,0x9c40(%eax)
  107881:	00 00 00 
  107884:	8b 44 24 04          	mov    0x4(%esp),%eax
  107888:	c6 80 44 9c 00 00 00 	movb   $0x0,0x9c44(%eax)
{
}
  10788f:	90                   	nop
  107890:	c3                   	ret    

Déassemblage de la section .text._ZNK14CircularBufferIA80_tLm250EE4sizeEv :

00107892 <_ZNK14CircularBufferIA80_tLm250EE4sizeEv>:
        if (_full)
  107892:	8b 44 24 04          	mov    0x4(%esp),%eax
  107896:	0f b6 80 44 9c 00 00 	movzbl 0x9c44(%eax),%eax
  10789d:	84 c0                	test   %al,%al
  10789f:	74 06                	je     1078a7 <_ZNK14CircularBufferIA80_tLm250EE4sizeEv+0x15>
            return Size;
  1078a1:	b8 fa 00 00 00       	mov    $0xfa,%eax
  1078a6:	c3                   	ret    
            return _front;
  1078a7:	8b 44 24 04          	mov    0x4(%esp),%eax
  1078ab:	8b 80 40 9c 00 00    	mov    0x9c40(%eax),%eax
    }
  1078b1:	c3                   	ret    

Déassemblage de la section .text._ZN14CircularBufferIA80_tLm250EEixEm :

001078b2 <_ZN14CircularBufferIA80_tLm250EEixEm>:
    }
}

template<typename T, size_t Size>
typename CircularBuffer<T, Size>::reference
CircularBuffer<T, Size>::operator[](size_type index)
  1078b2:	83 ec 0c             	sub    $0xc,%esp
{
    return const_cast<reference>(static_cast<const CircularBuffer<T, Size>&>(*this)[index]);
  1078b5:	83 ec 08             	sub    $0x8,%esp
  1078b8:	ff 74 24 1c          	pushl  0x1c(%esp)
  1078bc:	ff 74 24 1c          	pushl  0x1c(%esp)
  1078c0:	e8 97 00 00 00       	call   10795c <_ZNK14CircularBufferIA80_tLm250EEixEm>
  1078c5:	83 c4 10             	add    $0x10,%esp
}
  1078c8:	83 c4 0c             	add    $0xc,%esp
  1078cb:	c3                   	ret    

Déassemblage de la section .text._Z4sizeIKtLm80EEmRAT0__T_ :

001078cc <_Z4sizeIKtLm80EEmRAT0__T_>:
  1078cc:	b8 50 00 00 00       	mov    $0x50,%eax
  1078d1:	c3                   	ret    

Déassemblage de la section .text._ZN14CircularBufferIA80_tLm250EE3addERA80_Kt :

001078d2 <_ZN14CircularBufferIA80_tLm250EE3addERA80_Kt>:
    return *this;
}

template<typename T, size_t Size>
void
CircularBuffer<T, Size>::add(const T& item)
  1078d2:	53                   	push   %ebx
  1078d3:	83 ec 08             	sub    $0x8,%esp
{
    memcpy(_buffer[_front++], item, ::size(item) * sizeof(T));
  1078d6:	83 ec 0c             	sub    $0xc,%esp
  1078d9:	ff 74 24 20          	pushl  0x20(%esp)
  1078dd:	e8 ea ff ff ff       	call   1078cc <_Z4sizeIKtLm80EEmRAT0__T_>
  1078e2:	83 c4 10             	add    $0x10,%esp
  1078e5:	89 c2                	mov    %eax,%edx
  1078e7:	89 d0                	mov    %edx,%eax
  1078e9:	c1 e0 02             	shl    $0x2,%eax
  1078ec:	01 d0                	add    %edx,%eax
  1078ee:	c1 e0 05             	shl    $0x5,%eax
  1078f1:	89 c3                	mov    %eax,%ebx
  1078f3:	8b 44 24 10          	mov    0x10(%esp),%eax
  1078f7:	8b 90 40 9c 00 00    	mov    0x9c40(%eax),%edx
  1078fd:	8d 4a 01             	lea    0x1(%edx),%ecx
  107900:	8b 44 24 10          	mov    0x10(%esp),%eax
  107904:	89 88 40 9c 00 00    	mov    %ecx,0x9c40(%eax)
  10790a:	89 d0                	mov    %edx,%eax
  10790c:	c1 e0 02             	shl    $0x2,%eax
  10790f:	01 d0                	add    %edx,%eax
  107911:	c1 e0 05             	shl    $0x5,%eax
  107914:	8b 54 24 10          	mov    0x10(%esp),%edx
  107918:	01 d0                	add    %edx,%eax
  10791a:	83 ec 04             	sub    $0x4,%esp
  10791d:	53                   	push   %ebx
  10791e:	ff 74 24 1c          	pushl  0x1c(%esp)
  107922:	50                   	push   %eax
  107923:	e8 66 f7 ff ff       	call   10708e <memcpy>
  107928:	83 c4 10             	add    $0x10,%esp
    if (_front == Size)
  10792b:	8b 44 24 10          	mov    0x10(%esp),%eax
  10792f:	8b 80 40 9c 00 00    	mov    0x9c40(%eax),%eax
  107935:	3d fa 00 00 00       	cmp    $0xfa,%eax
  10793a:	75 19                	jne    107955 <_ZN14CircularBufferIA80_tLm250EE3addERA80_Kt+0x83>
    {
        _front = 0;
  10793c:	8b 44 24 10          	mov    0x10(%esp),%eax
  107940:	c7 80 40 9c 00 00 00 	movl   $0x0,0x9c40(%eax)
  107947:	00 00 00 
        _full = true;
  10794a:	8b 44 24 10          	mov    0x10(%esp),%eax
  10794e:	c6 80 44 9c 00 00 01 	movb   $0x1,0x9c44(%eax)
    }
}
  107955:	90                   	nop
  107956:	83 c4 08             	add    $0x8,%esp
  107959:	5b                   	pop    %ebx
  10795a:	c3                   	ret    

Déassemblage de la section .text._ZNK14CircularBufferIA80_tLm250EEixEm :

0010795c <_ZNK14CircularBufferIA80_tLm250EEixEm>:
CircularBuffer<T, Size>::operator[](size_type index) const
  10795c:	53                   	push   %ebx
  10795d:	83 ec 08             	sub    $0x8,%esp
    if (_full)
  107960:	8b 44 24 10          	mov    0x10(%esp),%eax
  107964:	0f b6 80 44 9c 00 00 	movzbl 0x9c44(%eax),%eax
  10796b:	84 c0                	test   %al,%al
  10796d:	74 6c                	je     1079db <_ZNK14CircularBufferIA80_tLm250EEixEm+0x7f>
        if (index >= size())
  10796f:	83 ec 0c             	sub    $0xc,%esp
  107972:	ff 74 24 1c          	pushl  0x1c(%esp)
  107976:	e8 17 ff ff ff       	call   107892 <_ZNK14CircularBufferIA80_tLm250EE4sizeEv>
  10797b:	83 c4 10             	add    $0x10,%esp
  10797e:	39 44 24 14          	cmp    %eax,0x14(%esp)
  107982:	0f 93 c0             	setae  %al
  107985:	84 c0                	test   %al,%al
  107987:	74 15                	je     10799e <_ZNK14CircularBufferIA80_tLm250EEixEm+0x42>
            panic("Invalid access of circular buffer %p at index %d !", this, index);
  107989:	83 ec 04             	sub    $0x4,%esp
  10798c:	ff 74 24 18          	pushl  0x18(%esp)
  107990:	ff 74 24 18          	pushl  0x18(%esp)
  107994:	68 3c 9b 10 00       	push   $0x109b3c
  107999:	e8 64 d0 ff ff       	call   104a02 <_Z5panicPKcz>
        return _buffer[(_front + index) % size()];
  10799e:	8b 44 24 10          	mov    0x10(%esp),%eax
  1079a2:	8b 90 40 9c 00 00    	mov    0x9c40(%eax),%edx
  1079a8:	8b 44 24 14          	mov    0x14(%esp),%eax
  1079ac:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  1079af:	83 ec 0c             	sub    $0xc,%esp
  1079b2:	ff 74 24 1c          	pushl  0x1c(%esp)
  1079b6:	e8 d7 fe ff ff       	call   107892 <_ZNK14CircularBufferIA80_tLm250EE4sizeEv>
  1079bb:	83 c4 10             	add    $0x10,%esp
  1079be:	89 c1                	mov    %eax,%ecx
  1079c0:	89 d8                	mov    %ebx,%eax
  1079c2:	ba 00 00 00 00       	mov    $0x0,%edx
  1079c7:	f7 f1                	div    %ecx
  1079c9:	89 d0                	mov    %edx,%eax
  1079cb:	c1 e0 02             	shl    $0x2,%eax
  1079ce:	01 d0                	add    %edx,%eax
  1079d0:	c1 e0 05             	shl    $0x5,%eax
  1079d3:	8b 54 24 10          	mov    0x10(%esp),%edx
  1079d7:	01 d0                	add    %edx,%eax
  1079d9:	eb 41                	jmp    107a1c <_ZNK14CircularBufferIA80_tLm250EEixEm+0xc0>
        if (index >= _front)
  1079db:	8b 44 24 10          	mov    0x10(%esp),%eax
  1079df:	8b 80 40 9c 00 00    	mov    0x9c40(%eax),%eax
  1079e5:	39 44 24 14          	cmp    %eax,0x14(%esp)
  1079e9:	72 1d                	jb     107a08 <_ZNK14CircularBufferIA80_tLm250EEixEm+0xac>
            panic("Invalid access of circular buffer %p at index %d with _front %d !", this, index, _front);
  1079eb:	8b 44 24 10          	mov    0x10(%esp),%eax
  1079ef:	8b 80 40 9c 00 00    	mov    0x9c40(%eax),%eax
  1079f5:	50                   	push   %eax
  1079f6:	ff 74 24 18          	pushl  0x18(%esp)
  1079fa:	ff 74 24 18          	pushl  0x18(%esp)
  1079fe:	68 70 9b 10 00       	push   $0x109b70
  107a03:	e8 fa cf ff ff       	call   104a02 <_Z5panicPKcz>
        return _buffer[index];
  107a08:	8b 54 24 14          	mov    0x14(%esp),%edx
  107a0c:	89 d0                	mov    %edx,%eax
  107a0e:	c1 e0 02             	shl    $0x2,%eax
  107a11:	01 d0                	add    %edx,%eax
  107a13:	c1 e0 05             	shl    $0x5,%eax
  107a16:	8b 54 24 10          	mov    0x10(%esp),%edx
  107a1a:	01 d0                	add    %edx,%eax
}
  107a1c:	83 c4 08             	add    $0x8,%esp
  107a1f:	5b                   	pop    %ebx
  107a20:	c3                   	ret    

Déassemblage de la section .text._ZNK6detail12TerminalImpl15current_historyEv :

00107a22 <_ZNK6detail12TerminalImpl15current_historyEv>:
    uint8_t current_history() const { return current_history_page; }
  107a22:	8b 44 24 04          	mov    0x4(%esp),%eax
  107a26:	0f b6 80 58 9c 00 00 	movzbl 0x9c58(%eax),%eax
  107a2d:	c3                   	ret    

Déassemblage de la section .text._ZN8Terminal12show_historyEi :

00107a2e <_ZN8Terminal12show_historyEi>:
    static void show_history(int page) { impl.show_history(page); }
  107a2e:	83 ec 0c             	sub    $0xc,%esp
  107a31:	83 ec 08             	sub    $0x8,%esp
  107a34:	ff 74 24 18          	pushl  0x18(%esp)
  107a38:	68 60 53 11 00       	push   $0x115360
  107a3d:	e8 00 bb ff ff       	call   103542 <_ZN6detail12TerminalImpl12show_historyEi>
  107a42:	83 c4 10             	add    $0x10,%esp
  107a45:	90                   	nop
  107a46:	83 c4 0c             	add    $0xc,%esp
  107a49:	c3                   	ret    

Déassemblage de la section .text._ZN8Terminal15current_historyEv :

00107a4a <_ZN8Terminal15current_historyEv>:
    static uint8_t current_history() { return impl.current_history(); }
  107a4a:	83 ec 0c             	sub    $0xc,%esp
  107a4d:	83 ec 0c             	sub    $0xc,%esp
  107a50:	68 60 53 11 00       	push   $0x115360
  107a55:	e8 c8 ff ff ff       	call   107a22 <_ZNK6detail12TerminalImpl15current_historyEv>
  107a5a:	83 c4 10             	add    $0x10,%esp
  107a5d:	83 c4 0c             	add    $0xc,%esp
  107a60:	c3                   	ret    

Déassemblage de la section .text._ZN5Timer13set_frequencyEm :

00107a61 <_ZN5Timer13set_frequencyEm>:
    static inline void set_frequency(uint32_t freq)
  107a61:	83 ec 0c             	sub    $0xc,%esp
        Timer::m_freq = freq;
  107a64:	8b 44 24 10          	mov    0x10(%esp),%eax
  107a68:	a3 d8 ef 11 00       	mov    %eax,0x11efd8
        if (!m_set_frequency_callback)
  107a6d:	a1 08 f4 11 00       	mov    0x11f408,%eax
  107a72:	85 c0                	test   %eax,%eax
  107a74:	75 0d                	jne    107a83 <_ZN5Timer13set_frequencyEm+0x22>
            panic("set_frequency_callback is not set !");
  107a76:	83 ec 0c             	sub    $0xc,%esp
  107a79:	68 c0 a0 10 00       	push   $0x10a0c0
  107a7e:	e8 7f cf ff ff       	call   104a02 <_Z5panicPKcz>
        m_set_frequency_callback(freq);
  107a83:	a1 08 f4 11 00       	mov    0x11f408,%eax
  107a88:	83 ec 0c             	sub    $0xc,%esp
  107a8b:	ff 74 24 1c          	pushl  0x1c(%esp)
  107a8f:	ff d0                	call   *%eax
  107a91:	83 c4 10             	add    $0x10,%esp
    }
  107a94:	90                   	nop
  107a95:	83 c4 0c             	add    $0xc,%esp
  107a98:	c3                   	ret    

Déassemblage de la section .text._ZN5Timer5sleepEm :

00107a99 <_ZN5Timer5sleepEm>:
    static inline void sleep(uint32_t time)
  107a99:	83 ec 1c             	sub    $0x1c,%esp
        uint32_t interval = time/(1000/freq());
  107a9c:	e8 d5 fc ff ff       	call   107776 <_ZN5Timer4freqEv>
  107aa1:	89 c1                	mov    %eax,%ecx
  107aa3:	b8 e8 03 00 00       	mov    $0x3e8,%eax
  107aa8:	ba 00 00 00 00       	mov    $0x0,%edx
  107aad:	f7 f1                	div    %ecx
  107aaf:	89 c1                	mov    %eax,%ecx
  107ab1:	8b 44 24 20          	mov    0x20(%esp),%eax
  107ab5:	ba 00 00 00 00       	mov    $0x0,%edx
  107aba:	f7 f1                	div    %ecx
  107abc:	89 44 24 0c          	mov    %eax,0xc(%esp)
        m_ticks = 0;
  107ac0:	c7 05 d4 ef 11 00 00 	movl   $0x0,0x11efd4
  107ac7:	00 00 00 
        while (m_ticks < interval) { NOP(); }
  107aca:	a1 d4 ef 11 00       	mov    0x11efd4,%eax
  107acf:	39 44 24 0c          	cmp    %eax,0xc(%esp)
  107ad3:	76 03                	jbe    107ad8 <_ZN5Timer5sleepEm+0x3f>
  107ad5:	90                   	nop
  107ad6:	eb f2                	jmp    107aca <_ZN5Timer5sleepEm+0x31>
    }
  107ad8:	90                   	nop
  107ad9:	83 c4 1c             	add    $0x1c,%esp
  107adc:	c3                   	ret    

Déassemblage de la section .text._ZN8Terminal8put_charEh :

00107add <_ZN8Terminal8put_charEh>:
    static void put_char(uint8_t c) { impl.put_char(c); };
  107add:	83 ec 1c             	sub    $0x1c,%esp
  107ae0:	8b 44 24 20          	mov    0x20(%esp),%eax
  107ae4:	88 44 24 0c          	mov    %al,0xc(%esp)
  107ae8:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  107aed:	83 ec 08             	sub    $0x8,%esp
  107af0:	50                   	push   %eax
  107af1:	68 60 53 11 00       	push   $0x115360
  107af6:	e8 53 b7 ff ff       	call   10324e <_ZN6detail12TerminalImpl8put_charEh>
  107afb:	83 c4 10             	add    $0x10,%esp
  107afe:	90                   	nop
  107aff:	83 c4 1c             	add    $0x1c,%esp
  107b02:	c3                   	ret    

Déassemblage de la section .text._ZN8Terminal9set_colorEh :

00107b03 <_ZN8Terminal9set_colorEh>:
    static void set_color(uint8_t color) { impl.set_color(color); }
  107b03:	83 ec 1c             	sub    $0x1c,%esp
  107b06:	8b 44 24 20          	mov    0x20(%esp),%eax
  107b0a:	88 44 24 0c          	mov    %al,0xc(%esp)
  107b0e:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
  107b13:	83 ec 08             	sub    $0x8,%esp
  107b16:	50                   	push   %eax
  107b17:	68 60 53 11 00       	push   $0x115360
  107b1c:	e8 a7 b6 ff ff       	call   1031c8 <_ZN6detail12TerminalImpl9set_colorEh>
  107b21:	83 c4 10             	add    $0x10,%esp
  107b24:	90                   	nop
  107b25:	83 c4 1c             	add    $0x1c,%esp
  107b28:	c3                   	ret    

Déassemblage de la section .text._Z3cliv :

00107b29 <_Z3cliv>:
    asm volatile ("cli");
  107b29:	fa                   	cli    
}
  107b2a:	90                   	nop
  107b2b:	c3                   	ret    

Déassemblage de la section .text._Z4haltv :

00107b2c <_Z4haltv>:
#define HALT_HPP

[[noreturn]]
inline void halt()
{
    while (true) {}
  107b2c:	eb fe                	jmp    107b2c <_Z4haltv>

Déassemblage de la section .text._Z7isdigitDi :

00107b2e <_Z7isdigitDi>:
inline bool isdigit(char32_t c)  { return ASCIIRANGE(c, 0x30, 10); }
  107b2e:	8b 44 24 04          	mov    0x4(%esp),%eax
  107b32:	83 e8 30             	sub    $0x30,%eax
  107b35:	83 f8 09             	cmp    $0x9,%eax
  107b38:	0f 96 c0             	setbe  %al
  107b3b:	c3                   	ret    
